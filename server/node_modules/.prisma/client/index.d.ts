
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Customer
 * 
 */
export type Customer = $Result.DefaultSelection<Prisma.$CustomerPayload>
/**
 * Model MasterItem
 * 
 */
export type MasterItem = $Result.DefaultSelection<Prisma.$MasterItemPayload>
/**
 * Model MasterTouch
 * 
 */
export type MasterTouch = $Result.DefaultSelection<Prisma.$MasterTouchPayload>
/**
 * Model JewelStock
 * 
 */
export type JewelStock = $Result.DefaultSelection<Prisma.$JewelStockPayload>
/**
 * Model Transaction
 * 
 */
export type Transaction = $Result.DefaultSelection<Prisma.$TransactionPayload>
/**
 * Model Entry
 * 
 */
export type Entry = $Result.DefaultSelection<Prisma.$EntryPayload>
/**
 * Model customer_order
 * 
 */
export type customer_order = $Result.DefaultSelection<Prisma.$customer_orderPayload>
/**
 * Model product_multiple_images
 * 
 */
export type product_multiple_images = $Result.DefaultSelection<Prisma.$product_multiple_imagesPayload>
/**
 * Model MasterBullion
 * 
 */
export type MasterBullion = $Result.DefaultSelection<Prisma.$MasterBullionPayload>
/**
 * Model BullionPurchase
 * 
 */
export type BullionPurchase = $Result.DefaultSelection<Prisma.$BullionPurchasePayload>
/**
 * Model GivenDetail
 * 
 */
export type GivenDetail = $Result.DefaultSelection<Prisma.$GivenDetailPayload>
/**
 * Model Goldsmith
 * 
 */
export type Goldsmith = $Result.DefaultSelection<Prisma.$GoldsmithPayload>
/**
 * Model Jobcard
 * 
 */
export type Jobcard = $Result.DefaultSelection<Prisma.$JobcardPayload>
/**
 * Model givenGold
 * 
 */
export type givenGold = $Result.DefaultSelection<Prisma.$givenGoldPayload>
/**
 * Model Total
 * 
 */
export type Total = $Result.DefaultSelection<Prisma.$TotalPayload>
/**
 * Model itemDelivery
 * 
 */
export type itemDelivery = $Result.DefaultSelection<Prisma.$itemDeliveryPayload>
/**
 * Model Receivedsection
 * 
 */
export type Receivedsection = $Result.DefaultSelection<Prisma.$ReceivedsectionPayload>
/**
 * Model Balances
 * 
 */
export type Balances = $Result.DefaultSelection<Prisma.$BalancesPayload>
/**
 * Model Repair
 * 
 */
export type Repair = $Result.DefaultSelection<Prisma.$RepairPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const WastageType: {
  PERCENTAGE: 'PERCENTAGE',
  ADDITION: 'ADDITION',
  TOUCH: 'TOUCH'
};

export type WastageType = (typeof WastageType)[keyof typeof WastageType]

}

export type WastageType = $Enums.WastageType

export const WastageType: typeof $Enums.WastageType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customer`: Exposes CRUD operations for the **Customer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customer.findMany()
    * ```
    */
  get customer(): Prisma.CustomerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.masterItem`: Exposes CRUD operations for the **MasterItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MasterItems
    * const masterItems = await prisma.masterItem.findMany()
    * ```
    */
  get masterItem(): Prisma.MasterItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.masterTouch`: Exposes CRUD operations for the **MasterTouch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MasterTouches
    * const masterTouches = await prisma.masterTouch.findMany()
    * ```
    */
  get masterTouch(): Prisma.MasterTouchDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.jewelStock`: Exposes CRUD operations for the **JewelStock** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JewelStocks
    * const jewelStocks = await prisma.jewelStock.findMany()
    * ```
    */
  get jewelStock(): Prisma.JewelStockDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transaction`: Exposes CRUD operations for the **Transaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transactions
    * const transactions = await prisma.transaction.findMany()
    * ```
    */
  get transaction(): Prisma.TransactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.entry`: Exposes CRUD operations for the **Entry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Entries
    * const entries = await prisma.entry.findMany()
    * ```
    */
  get entry(): Prisma.EntryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customer_order`: Exposes CRUD operations for the **customer_order** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customer_orders
    * const customer_orders = await prisma.customer_order.findMany()
    * ```
    */
  get customer_order(): Prisma.customer_orderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.product_multiple_images`: Exposes CRUD operations for the **product_multiple_images** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Product_multiple_images
    * const product_multiple_images = await prisma.product_multiple_images.findMany()
    * ```
    */
  get product_multiple_images(): Prisma.product_multiple_imagesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.masterBullion`: Exposes CRUD operations for the **MasterBullion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MasterBullions
    * const masterBullions = await prisma.masterBullion.findMany()
    * ```
    */
  get masterBullion(): Prisma.MasterBullionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bullionPurchase`: Exposes CRUD operations for the **BullionPurchase** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BullionPurchases
    * const bullionPurchases = await prisma.bullionPurchase.findMany()
    * ```
    */
  get bullionPurchase(): Prisma.BullionPurchaseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.givenDetail`: Exposes CRUD operations for the **GivenDetail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GivenDetails
    * const givenDetails = await prisma.givenDetail.findMany()
    * ```
    */
  get givenDetail(): Prisma.GivenDetailDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.goldsmith`: Exposes CRUD operations for the **Goldsmith** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Goldsmiths
    * const goldsmiths = await prisma.goldsmith.findMany()
    * ```
    */
  get goldsmith(): Prisma.GoldsmithDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.jobcard`: Exposes CRUD operations for the **Jobcard** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Jobcards
    * const jobcards = await prisma.jobcard.findMany()
    * ```
    */
  get jobcard(): Prisma.JobcardDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.givenGold`: Exposes CRUD operations for the **givenGold** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GivenGolds
    * const givenGolds = await prisma.givenGold.findMany()
    * ```
    */
  get givenGold(): Prisma.givenGoldDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.total`: Exposes CRUD operations for the **Total** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Totals
    * const totals = await prisma.total.findMany()
    * ```
    */
  get total(): Prisma.TotalDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.itemDelivery`: Exposes CRUD operations for the **itemDelivery** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ItemDeliveries
    * const itemDeliveries = await prisma.itemDelivery.findMany()
    * ```
    */
  get itemDelivery(): Prisma.itemDeliveryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.receivedsection`: Exposes CRUD operations for the **Receivedsection** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Receivedsections
    * const receivedsections = await prisma.receivedsection.findMany()
    * ```
    */
  get receivedsection(): Prisma.ReceivedsectionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.balances`: Exposes CRUD operations for the **Balances** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Balances
    * const balances = await prisma.balances.findMany()
    * ```
    */
  get balances(): Prisma.BalancesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.repair`: Exposes CRUD operations for the **Repair** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Repairs
    * const repairs = await prisma.repair.findMany()
    * ```
    */
  get repair(): Prisma.RepairDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.7.0
   * Query Engine version: 3cff47a7f5d65c3ea74883f1d736e41d68ce91ed
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Customer: 'Customer',
    MasterItem: 'MasterItem',
    MasterTouch: 'MasterTouch',
    JewelStock: 'JewelStock',
    Transaction: 'Transaction',
    Entry: 'Entry',
    customer_order: 'customer_order',
    product_multiple_images: 'product_multiple_images',
    MasterBullion: 'MasterBullion',
    BullionPurchase: 'BullionPurchase',
    GivenDetail: 'GivenDetail',
    Goldsmith: 'Goldsmith',
    Jobcard: 'Jobcard',
    givenGold: 'givenGold',
    Total: 'Total',
    itemDelivery: 'itemDelivery',
    Receivedsection: 'Receivedsection',
    Balances: 'Balances',
    Repair: 'Repair'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "customer" | "masterItem" | "masterTouch" | "jewelStock" | "transaction" | "entry" | "customer_order" | "product_multiple_images" | "masterBullion" | "bullionPurchase" | "givenDetail" | "goldsmith" | "jobcard" | "givenGold" | "total" | "itemDelivery" | "receivedsection" | "balances" | "repair"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Customer: {
        payload: Prisma.$CustomerPayload<ExtArgs>
        fields: Prisma.CustomerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findFirst: {
            args: Prisma.CustomerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findMany: {
            args: Prisma.CustomerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          create: {
            args: Prisma.CustomerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          createMany: {
            args: Prisma.CustomerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CustomerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          update: {
            args: Prisma.CustomerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          deleteMany: {
            args: Prisma.CustomerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CustomerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          aggregate: {
            args: Prisma.CustomerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomer>
          }
          groupBy: {
            args: Prisma.CustomerGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerCountAggregateOutputType> | number
          }
        }
      }
      MasterItem: {
        payload: Prisma.$MasterItemPayload<ExtArgs>
        fields: Prisma.MasterItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MasterItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MasterItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MasterItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MasterItemPayload>
          }
          findFirst: {
            args: Prisma.MasterItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MasterItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MasterItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MasterItemPayload>
          }
          findMany: {
            args: Prisma.MasterItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MasterItemPayload>[]
          }
          create: {
            args: Prisma.MasterItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MasterItemPayload>
          }
          createMany: {
            args: Prisma.MasterItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MasterItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MasterItemPayload>
          }
          update: {
            args: Prisma.MasterItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MasterItemPayload>
          }
          deleteMany: {
            args: Prisma.MasterItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MasterItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MasterItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MasterItemPayload>
          }
          aggregate: {
            args: Prisma.MasterItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMasterItem>
          }
          groupBy: {
            args: Prisma.MasterItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<MasterItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.MasterItemCountArgs<ExtArgs>
            result: $Utils.Optional<MasterItemCountAggregateOutputType> | number
          }
        }
      }
      MasterTouch: {
        payload: Prisma.$MasterTouchPayload<ExtArgs>
        fields: Prisma.MasterTouchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MasterTouchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MasterTouchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MasterTouchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MasterTouchPayload>
          }
          findFirst: {
            args: Prisma.MasterTouchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MasterTouchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MasterTouchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MasterTouchPayload>
          }
          findMany: {
            args: Prisma.MasterTouchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MasterTouchPayload>[]
          }
          create: {
            args: Prisma.MasterTouchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MasterTouchPayload>
          }
          createMany: {
            args: Prisma.MasterTouchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MasterTouchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MasterTouchPayload>
          }
          update: {
            args: Prisma.MasterTouchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MasterTouchPayload>
          }
          deleteMany: {
            args: Prisma.MasterTouchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MasterTouchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MasterTouchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MasterTouchPayload>
          }
          aggregate: {
            args: Prisma.MasterTouchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMasterTouch>
          }
          groupBy: {
            args: Prisma.MasterTouchGroupByArgs<ExtArgs>
            result: $Utils.Optional<MasterTouchGroupByOutputType>[]
          }
          count: {
            args: Prisma.MasterTouchCountArgs<ExtArgs>
            result: $Utils.Optional<MasterTouchCountAggregateOutputType> | number
          }
        }
      }
      JewelStock: {
        payload: Prisma.$JewelStockPayload<ExtArgs>
        fields: Prisma.JewelStockFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JewelStockFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JewelStockPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JewelStockFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JewelStockPayload>
          }
          findFirst: {
            args: Prisma.JewelStockFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JewelStockPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JewelStockFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JewelStockPayload>
          }
          findMany: {
            args: Prisma.JewelStockFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JewelStockPayload>[]
          }
          create: {
            args: Prisma.JewelStockCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JewelStockPayload>
          }
          createMany: {
            args: Prisma.JewelStockCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.JewelStockDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JewelStockPayload>
          }
          update: {
            args: Prisma.JewelStockUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JewelStockPayload>
          }
          deleteMany: {
            args: Prisma.JewelStockDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JewelStockUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.JewelStockUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JewelStockPayload>
          }
          aggregate: {
            args: Prisma.JewelStockAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJewelStock>
          }
          groupBy: {
            args: Prisma.JewelStockGroupByArgs<ExtArgs>
            result: $Utils.Optional<JewelStockGroupByOutputType>[]
          }
          count: {
            args: Prisma.JewelStockCountArgs<ExtArgs>
            result: $Utils.Optional<JewelStockCountAggregateOutputType> | number
          }
        }
      }
      Transaction: {
        payload: Prisma.$TransactionPayload<ExtArgs>
        fields: Prisma.TransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findFirst: {
            args: Prisma.TransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findMany: {
            args: Prisma.TransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          create: {
            args: Prisma.TransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          createMany: {
            args: Prisma.TransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          update: {
            args: Prisma.TransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          deleteMany: {
            args: Prisma.TransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          aggregate: {
            args: Prisma.TransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransaction>
          }
          groupBy: {
            args: Prisma.TransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransactionCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionCountAggregateOutputType> | number
          }
        }
      }
      Entry: {
        payload: Prisma.$EntryPayload<ExtArgs>
        fields: Prisma.EntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntryPayload>
          }
          findFirst: {
            args: Prisma.EntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntryPayload>
          }
          findMany: {
            args: Prisma.EntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntryPayload>[]
          }
          create: {
            args: Prisma.EntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntryPayload>
          }
          createMany: {
            args: Prisma.EntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntryPayload>
          }
          update: {
            args: Prisma.EntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntryPayload>
          }
          deleteMany: {
            args: Prisma.EntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntryPayload>
          }
          aggregate: {
            args: Prisma.EntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEntry>
          }
          groupBy: {
            args: Prisma.EntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<EntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.EntryCountArgs<ExtArgs>
            result: $Utils.Optional<EntryCountAggregateOutputType> | number
          }
        }
      }
      customer_order: {
        payload: Prisma.$customer_orderPayload<ExtArgs>
        fields: Prisma.customer_orderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.customer_orderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customer_orderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.customer_orderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customer_orderPayload>
          }
          findFirst: {
            args: Prisma.customer_orderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customer_orderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.customer_orderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customer_orderPayload>
          }
          findMany: {
            args: Prisma.customer_orderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customer_orderPayload>[]
          }
          create: {
            args: Prisma.customer_orderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customer_orderPayload>
          }
          createMany: {
            args: Prisma.customer_orderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.customer_orderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customer_orderPayload>
          }
          update: {
            args: Prisma.customer_orderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customer_orderPayload>
          }
          deleteMany: {
            args: Prisma.customer_orderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.customer_orderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.customer_orderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customer_orderPayload>
          }
          aggregate: {
            args: Prisma.Customer_orderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomer_order>
          }
          groupBy: {
            args: Prisma.customer_orderGroupByArgs<ExtArgs>
            result: $Utils.Optional<Customer_orderGroupByOutputType>[]
          }
          count: {
            args: Prisma.customer_orderCountArgs<ExtArgs>
            result: $Utils.Optional<Customer_orderCountAggregateOutputType> | number
          }
        }
      }
      product_multiple_images: {
        payload: Prisma.$product_multiple_imagesPayload<ExtArgs>
        fields: Prisma.product_multiple_imagesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.product_multiple_imagesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$product_multiple_imagesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.product_multiple_imagesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$product_multiple_imagesPayload>
          }
          findFirst: {
            args: Prisma.product_multiple_imagesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$product_multiple_imagesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.product_multiple_imagesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$product_multiple_imagesPayload>
          }
          findMany: {
            args: Prisma.product_multiple_imagesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$product_multiple_imagesPayload>[]
          }
          create: {
            args: Prisma.product_multiple_imagesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$product_multiple_imagesPayload>
          }
          createMany: {
            args: Prisma.product_multiple_imagesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.product_multiple_imagesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$product_multiple_imagesPayload>
          }
          update: {
            args: Prisma.product_multiple_imagesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$product_multiple_imagesPayload>
          }
          deleteMany: {
            args: Prisma.product_multiple_imagesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.product_multiple_imagesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.product_multiple_imagesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$product_multiple_imagesPayload>
          }
          aggregate: {
            args: Prisma.Product_multiple_imagesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct_multiple_images>
          }
          groupBy: {
            args: Prisma.product_multiple_imagesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Product_multiple_imagesGroupByOutputType>[]
          }
          count: {
            args: Prisma.product_multiple_imagesCountArgs<ExtArgs>
            result: $Utils.Optional<Product_multiple_imagesCountAggregateOutputType> | number
          }
        }
      }
      MasterBullion: {
        payload: Prisma.$MasterBullionPayload<ExtArgs>
        fields: Prisma.MasterBullionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MasterBullionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MasterBullionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MasterBullionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MasterBullionPayload>
          }
          findFirst: {
            args: Prisma.MasterBullionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MasterBullionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MasterBullionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MasterBullionPayload>
          }
          findMany: {
            args: Prisma.MasterBullionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MasterBullionPayload>[]
          }
          create: {
            args: Prisma.MasterBullionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MasterBullionPayload>
          }
          createMany: {
            args: Prisma.MasterBullionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MasterBullionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MasterBullionPayload>
          }
          update: {
            args: Prisma.MasterBullionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MasterBullionPayload>
          }
          deleteMany: {
            args: Prisma.MasterBullionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MasterBullionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MasterBullionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MasterBullionPayload>
          }
          aggregate: {
            args: Prisma.MasterBullionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMasterBullion>
          }
          groupBy: {
            args: Prisma.MasterBullionGroupByArgs<ExtArgs>
            result: $Utils.Optional<MasterBullionGroupByOutputType>[]
          }
          count: {
            args: Prisma.MasterBullionCountArgs<ExtArgs>
            result: $Utils.Optional<MasterBullionCountAggregateOutputType> | number
          }
        }
      }
      BullionPurchase: {
        payload: Prisma.$BullionPurchasePayload<ExtArgs>
        fields: Prisma.BullionPurchaseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BullionPurchaseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BullionPurchasePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BullionPurchaseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BullionPurchasePayload>
          }
          findFirst: {
            args: Prisma.BullionPurchaseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BullionPurchasePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BullionPurchaseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BullionPurchasePayload>
          }
          findMany: {
            args: Prisma.BullionPurchaseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BullionPurchasePayload>[]
          }
          create: {
            args: Prisma.BullionPurchaseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BullionPurchasePayload>
          }
          createMany: {
            args: Prisma.BullionPurchaseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BullionPurchaseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BullionPurchasePayload>
          }
          update: {
            args: Prisma.BullionPurchaseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BullionPurchasePayload>
          }
          deleteMany: {
            args: Prisma.BullionPurchaseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BullionPurchaseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BullionPurchaseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BullionPurchasePayload>
          }
          aggregate: {
            args: Prisma.BullionPurchaseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBullionPurchase>
          }
          groupBy: {
            args: Prisma.BullionPurchaseGroupByArgs<ExtArgs>
            result: $Utils.Optional<BullionPurchaseGroupByOutputType>[]
          }
          count: {
            args: Prisma.BullionPurchaseCountArgs<ExtArgs>
            result: $Utils.Optional<BullionPurchaseCountAggregateOutputType> | number
          }
        }
      }
      GivenDetail: {
        payload: Prisma.$GivenDetailPayload<ExtArgs>
        fields: Prisma.GivenDetailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GivenDetailFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GivenDetailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GivenDetailFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GivenDetailPayload>
          }
          findFirst: {
            args: Prisma.GivenDetailFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GivenDetailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GivenDetailFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GivenDetailPayload>
          }
          findMany: {
            args: Prisma.GivenDetailFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GivenDetailPayload>[]
          }
          create: {
            args: Prisma.GivenDetailCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GivenDetailPayload>
          }
          createMany: {
            args: Prisma.GivenDetailCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.GivenDetailDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GivenDetailPayload>
          }
          update: {
            args: Prisma.GivenDetailUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GivenDetailPayload>
          }
          deleteMany: {
            args: Prisma.GivenDetailDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GivenDetailUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GivenDetailUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GivenDetailPayload>
          }
          aggregate: {
            args: Prisma.GivenDetailAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGivenDetail>
          }
          groupBy: {
            args: Prisma.GivenDetailGroupByArgs<ExtArgs>
            result: $Utils.Optional<GivenDetailGroupByOutputType>[]
          }
          count: {
            args: Prisma.GivenDetailCountArgs<ExtArgs>
            result: $Utils.Optional<GivenDetailCountAggregateOutputType> | number
          }
        }
      }
      Goldsmith: {
        payload: Prisma.$GoldsmithPayload<ExtArgs>
        fields: Prisma.GoldsmithFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GoldsmithFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoldsmithPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GoldsmithFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoldsmithPayload>
          }
          findFirst: {
            args: Prisma.GoldsmithFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoldsmithPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GoldsmithFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoldsmithPayload>
          }
          findMany: {
            args: Prisma.GoldsmithFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoldsmithPayload>[]
          }
          create: {
            args: Prisma.GoldsmithCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoldsmithPayload>
          }
          createMany: {
            args: Prisma.GoldsmithCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.GoldsmithDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoldsmithPayload>
          }
          update: {
            args: Prisma.GoldsmithUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoldsmithPayload>
          }
          deleteMany: {
            args: Prisma.GoldsmithDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GoldsmithUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GoldsmithUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoldsmithPayload>
          }
          aggregate: {
            args: Prisma.GoldsmithAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGoldsmith>
          }
          groupBy: {
            args: Prisma.GoldsmithGroupByArgs<ExtArgs>
            result: $Utils.Optional<GoldsmithGroupByOutputType>[]
          }
          count: {
            args: Prisma.GoldsmithCountArgs<ExtArgs>
            result: $Utils.Optional<GoldsmithCountAggregateOutputType> | number
          }
        }
      }
      Jobcard: {
        payload: Prisma.$JobcardPayload<ExtArgs>
        fields: Prisma.JobcardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JobcardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobcardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JobcardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobcardPayload>
          }
          findFirst: {
            args: Prisma.JobcardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobcardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JobcardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobcardPayload>
          }
          findMany: {
            args: Prisma.JobcardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobcardPayload>[]
          }
          create: {
            args: Prisma.JobcardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobcardPayload>
          }
          createMany: {
            args: Prisma.JobcardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.JobcardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobcardPayload>
          }
          update: {
            args: Prisma.JobcardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobcardPayload>
          }
          deleteMany: {
            args: Prisma.JobcardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JobcardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.JobcardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobcardPayload>
          }
          aggregate: {
            args: Prisma.JobcardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJobcard>
          }
          groupBy: {
            args: Prisma.JobcardGroupByArgs<ExtArgs>
            result: $Utils.Optional<JobcardGroupByOutputType>[]
          }
          count: {
            args: Prisma.JobcardCountArgs<ExtArgs>
            result: $Utils.Optional<JobcardCountAggregateOutputType> | number
          }
        }
      }
      givenGold: {
        payload: Prisma.$givenGoldPayload<ExtArgs>
        fields: Prisma.givenGoldFieldRefs
        operations: {
          findUnique: {
            args: Prisma.givenGoldFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$givenGoldPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.givenGoldFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$givenGoldPayload>
          }
          findFirst: {
            args: Prisma.givenGoldFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$givenGoldPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.givenGoldFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$givenGoldPayload>
          }
          findMany: {
            args: Prisma.givenGoldFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$givenGoldPayload>[]
          }
          create: {
            args: Prisma.givenGoldCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$givenGoldPayload>
          }
          createMany: {
            args: Prisma.givenGoldCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.givenGoldDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$givenGoldPayload>
          }
          update: {
            args: Prisma.givenGoldUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$givenGoldPayload>
          }
          deleteMany: {
            args: Prisma.givenGoldDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.givenGoldUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.givenGoldUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$givenGoldPayload>
          }
          aggregate: {
            args: Prisma.GivenGoldAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGivenGold>
          }
          groupBy: {
            args: Prisma.givenGoldGroupByArgs<ExtArgs>
            result: $Utils.Optional<GivenGoldGroupByOutputType>[]
          }
          count: {
            args: Prisma.givenGoldCountArgs<ExtArgs>
            result: $Utils.Optional<GivenGoldCountAggregateOutputType> | number
          }
        }
      }
      Total: {
        payload: Prisma.$TotalPayload<ExtArgs>
        fields: Prisma.TotalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TotalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TotalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TotalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TotalPayload>
          }
          findFirst: {
            args: Prisma.TotalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TotalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TotalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TotalPayload>
          }
          findMany: {
            args: Prisma.TotalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TotalPayload>[]
          }
          create: {
            args: Prisma.TotalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TotalPayload>
          }
          createMany: {
            args: Prisma.TotalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TotalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TotalPayload>
          }
          update: {
            args: Prisma.TotalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TotalPayload>
          }
          deleteMany: {
            args: Prisma.TotalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TotalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TotalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TotalPayload>
          }
          aggregate: {
            args: Prisma.TotalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTotal>
          }
          groupBy: {
            args: Prisma.TotalGroupByArgs<ExtArgs>
            result: $Utils.Optional<TotalGroupByOutputType>[]
          }
          count: {
            args: Prisma.TotalCountArgs<ExtArgs>
            result: $Utils.Optional<TotalCountAggregateOutputType> | number
          }
        }
      }
      itemDelivery: {
        payload: Prisma.$itemDeliveryPayload<ExtArgs>
        fields: Prisma.itemDeliveryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.itemDeliveryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itemDeliveryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.itemDeliveryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itemDeliveryPayload>
          }
          findFirst: {
            args: Prisma.itemDeliveryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itemDeliveryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.itemDeliveryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itemDeliveryPayload>
          }
          findMany: {
            args: Prisma.itemDeliveryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itemDeliveryPayload>[]
          }
          create: {
            args: Prisma.itemDeliveryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itemDeliveryPayload>
          }
          createMany: {
            args: Prisma.itemDeliveryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.itemDeliveryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itemDeliveryPayload>
          }
          update: {
            args: Prisma.itemDeliveryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itemDeliveryPayload>
          }
          deleteMany: {
            args: Prisma.itemDeliveryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.itemDeliveryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.itemDeliveryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itemDeliveryPayload>
          }
          aggregate: {
            args: Prisma.ItemDeliveryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateItemDelivery>
          }
          groupBy: {
            args: Prisma.itemDeliveryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ItemDeliveryGroupByOutputType>[]
          }
          count: {
            args: Prisma.itemDeliveryCountArgs<ExtArgs>
            result: $Utils.Optional<ItemDeliveryCountAggregateOutputType> | number
          }
        }
      }
      Receivedsection: {
        payload: Prisma.$ReceivedsectionPayload<ExtArgs>
        fields: Prisma.ReceivedsectionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReceivedsectionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceivedsectionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReceivedsectionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceivedsectionPayload>
          }
          findFirst: {
            args: Prisma.ReceivedsectionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceivedsectionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReceivedsectionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceivedsectionPayload>
          }
          findMany: {
            args: Prisma.ReceivedsectionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceivedsectionPayload>[]
          }
          create: {
            args: Prisma.ReceivedsectionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceivedsectionPayload>
          }
          createMany: {
            args: Prisma.ReceivedsectionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ReceivedsectionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceivedsectionPayload>
          }
          update: {
            args: Prisma.ReceivedsectionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceivedsectionPayload>
          }
          deleteMany: {
            args: Prisma.ReceivedsectionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReceivedsectionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReceivedsectionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceivedsectionPayload>
          }
          aggregate: {
            args: Prisma.ReceivedsectionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReceivedsection>
          }
          groupBy: {
            args: Prisma.ReceivedsectionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReceivedsectionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReceivedsectionCountArgs<ExtArgs>
            result: $Utils.Optional<ReceivedsectionCountAggregateOutputType> | number
          }
        }
      }
      Balances: {
        payload: Prisma.$BalancesPayload<ExtArgs>
        fields: Prisma.BalancesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BalancesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalancesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BalancesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalancesPayload>
          }
          findFirst: {
            args: Prisma.BalancesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalancesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BalancesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalancesPayload>
          }
          findMany: {
            args: Prisma.BalancesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalancesPayload>[]
          }
          create: {
            args: Prisma.BalancesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalancesPayload>
          }
          createMany: {
            args: Prisma.BalancesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BalancesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalancesPayload>
          }
          update: {
            args: Prisma.BalancesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalancesPayload>
          }
          deleteMany: {
            args: Prisma.BalancesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BalancesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BalancesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalancesPayload>
          }
          aggregate: {
            args: Prisma.BalancesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBalances>
          }
          groupBy: {
            args: Prisma.BalancesGroupByArgs<ExtArgs>
            result: $Utils.Optional<BalancesGroupByOutputType>[]
          }
          count: {
            args: Prisma.BalancesCountArgs<ExtArgs>
            result: $Utils.Optional<BalancesCountAggregateOutputType> | number
          }
        }
      }
      Repair: {
        payload: Prisma.$RepairPayload<ExtArgs>
        fields: Prisma.RepairFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RepairFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RepairPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RepairFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RepairPayload>
          }
          findFirst: {
            args: Prisma.RepairFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RepairPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RepairFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RepairPayload>
          }
          findMany: {
            args: Prisma.RepairFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RepairPayload>[]
          }
          create: {
            args: Prisma.RepairCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RepairPayload>
          }
          createMany: {
            args: Prisma.RepairCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RepairDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RepairPayload>
          }
          update: {
            args: Prisma.RepairUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RepairPayload>
          }
          deleteMany: {
            args: Prisma.RepairDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RepairUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RepairUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RepairPayload>
          }
          aggregate: {
            args: Prisma.RepairAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRepair>
          }
          groupBy: {
            args: Prisma.RepairGroupByArgs<ExtArgs>
            result: $Utils.Optional<RepairGroupByOutputType>[]
          }
          count: {
            args: Prisma.RepairCountArgs<ExtArgs>
            result: $Utils.Optional<RepairCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    customer?: CustomerOmit
    masterItem?: MasterItemOmit
    masterTouch?: MasterTouchOmit
    jewelStock?: JewelStockOmit
    transaction?: TransactionOmit
    entry?: EntryOmit
    customer_order?: customer_orderOmit
    product_multiple_images?: product_multiple_imagesOmit
    masterBullion?: MasterBullionOmit
    bullionPurchase?: BullionPurchaseOmit
    givenDetail?: GivenDetailOmit
    goldsmith?: GoldsmithOmit
    jobcard?: JobcardOmit
    givenGold?: givenGoldOmit
    total?: TotalOmit
    itemDelivery?: itemDeliveryOmit
    receivedsection?: ReceivedsectionOmit
    balances?: BalancesOmit
    repair?: RepairOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CustomerCountOutputType
   */

  export type CustomerCountOutputType = {
    transactions: number
    customerOrders: number
  }

  export type CustomerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | CustomerCountOutputTypeCountTransactionsArgs
    customerOrders?: boolean | CustomerCountOutputTypeCountCustomerOrdersArgs
  }

  // Custom InputTypes
  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerCountOutputType
     */
    select?: CustomerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountCustomerOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: customer_orderWhereInput
  }


  /**
   * Count Type Customer_orderCountOutputType
   */

  export type Customer_orderCountOutputType = {
    productImages: number
  }

  export type Customer_orderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productImages?: boolean | Customer_orderCountOutputTypeCountProductImagesArgs
  }

  // Custom InputTypes
  /**
   * Customer_orderCountOutputType without action
   */
  export type Customer_orderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer_orderCountOutputType
     */
    select?: Customer_orderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Customer_orderCountOutputType without action
   */
  export type Customer_orderCountOutputTypeCountProductImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: product_multiple_imagesWhereInput
  }


  /**
   * Count Type MasterBullionCountOutputType
   */

  export type MasterBullionCountOutputType = {
    purchases: number
  }

  export type MasterBullionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchases?: boolean | MasterBullionCountOutputTypeCountPurchasesArgs
  }

  // Custom InputTypes
  /**
   * MasterBullionCountOutputType without action
   */
  export type MasterBullionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterBullionCountOutputType
     */
    select?: MasterBullionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MasterBullionCountOutputType without action
   */
  export type MasterBullionCountOutputTypeCountPurchasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BullionPurchaseWhereInput
  }


  /**
   * Count Type BullionPurchaseCountOutputType
   */

  export type BullionPurchaseCountOutputType = {
    givenDetails: number
  }

  export type BullionPurchaseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    givenDetails?: boolean | BullionPurchaseCountOutputTypeCountGivenDetailsArgs
  }

  // Custom InputTypes
  /**
   * BullionPurchaseCountOutputType without action
   */
  export type BullionPurchaseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BullionPurchaseCountOutputType
     */
    select?: BullionPurchaseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BullionPurchaseCountOutputType without action
   */
  export type BullionPurchaseCountOutputTypeCountGivenDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GivenDetailWhereInput
  }


  /**
   * Count Type GoldsmithCountOutputType
   */

  export type GoldsmithCountOutputType = {
    jobcards: number
    totals: number
    givenGold: number
    deliveries: number
    received: number
    repairs: number
    summaries: number
  }

  export type GoldsmithCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jobcards?: boolean | GoldsmithCountOutputTypeCountJobcardsArgs
    totals?: boolean | GoldsmithCountOutputTypeCountTotalsArgs
    givenGold?: boolean | GoldsmithCountOutputTypeCountGivenGoldArgs
    deliveries?: boolean | GoldsmithCountOutputTypeCountDeliveriesArgs
    received?: boolean | GoldsmithCountOutputTypeCountReceivedArgs
    repairs?: boolean | GoldsmithCountOutputTypeCountRepairsArgs
    summaries?: boolean | GoldsmithCountOutputTypeCountSummariesArgs
  }

  // Custom InputTypes
  /**
   * GoldsmithCountOutputType without action
   */
  export type GoldsmithCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoldsmithCountOutputType
     */
    select?: GoldsmithCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GoldsmithCountOutputType without action
   */
  export type GoldsmithCountOutputTypeCountJobcardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobcardWhereInput
  }

  /**
   * GoldsmithCountOutputType without action
   */
  export type GoldsmithCountOutputTypeCountTotalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TotalWhereInput
  }

  /**
   * GoldsmithCountOutputType without action
   */
  export type GoldsmithCountOutputTypeCountGivenGoldArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: givenGoldWhereInput
  }

  /**
   * GoldsmithCountOutputType without action
   */
  export type GoldsmithCountOutputTypeCountDeliveriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: itemDeliveryWhereInput
  }

  /**
   * GoldsmithCountOutputType without action
   */
  export type GoldsmithCountOutputTypeCountReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReceivedsectionWhereInput
  }

  /**
   * GoldsmithCountOutputType without action
   */
  export type GoldsmithCountOutputTypeCountRepairsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RepairWhereInput
  }

  /**
   * GoldsmithCountOutputType without action
   */
  export type GoldsmithCountOutputTypeCountSummariesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BalancesWhereInput
  }


  /**
   * Count Type JobcardCountOutputType
   */

  export type JobcardCountOutputType = {
    givenGold: number
    deliveries: number
    received: number
  }

  export type JobcardCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    givenGold?: boolean | JobcardCountOutputTypeCountGivenGoldArgs
    deliveries?: boolean | JobcardCountOutputTypeCountDeliveriesArgs
    received?: boolean | JobcardCountOutputTypeCountReceivedArgs
  }

  // Custom InputTypes
  /**
   * JobcardCountOutputType without action
   */
  export type JobcardCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobcardCountOutputType
     */
    select?: JobcardCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * JobcardCountOutputType without action
   */
  export type JobcardCountOutputTypeCountGivenGoldArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: givenGoldWhereInput
  }

  /**
   * JobcardCountOutputType without action
   */
  export type JobcardCountOutputTypeCountDeliveriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: itemDeliveryWhereInput
  }

  /**
   * JobcardCountOutputType without action
   */
  export type JobcardCountOutputTypeCountReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReceivedsectionWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    username: string | null
    password: string | null
    createdAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    username: string | null
    password: string | null
    createdAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    username: number
    password: number
    createdAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    username?: true
    password?: true
    createdAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    username?: true
    password?: true
    createdAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    username?: true
    password?: true
    createdAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    username: string
    password: string
    createdAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    password?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["user"]>



  export type UserSelectScalar = {
    id?: boolean
    username?: boolean
    password?: boolean
    createdAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "username" | "password" | "createdAt", ExtArgs["result"]["user"]>

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      username: string
      password: string
      createdAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly username: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
  }


  /**
   * Model Customer
   */

  export type AggregateCustomer = {
    _count: CustomerCountAggregateOutputType | null
    _avg: CustomerAvgAggregateOutputType | null
    _sum: CustomerSumAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  export type CustomerAvgAggregateOutputType = {
    id: number | null
  }

  export type CustomerSumAggregateOutputType = {
    id: number | null
  }

  export type CustomerMinAggregateOutputType = {
    id: number | null
    name: string | null
    phone: string | null
    address: string | null
    createdAt: Date | null
  }

  export type CustomerMaxAggregateOutputType = {
    id: number | null
    name: string | null
    phone: string | null
    address: string | null
    createdAt: Date | null
  }

  export type CustomerCountAggregateOutputType = {
    id: number
    name: number
    phone: number
    address: number
    createdAt: number
    _all: number
  }


  export type CustomerAvgAggregateInputType = {
    id?: true
  }

  export type CustomerSumAggregateInputType = {
    id?: true
  }

  export type CustomerMinAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    address?: true
    createdAt?: true
  }

  export type CustomerMaxAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    address?: true
    createdAt?: true
  }

  export type CustomerCountAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    address?: true
    createdAt?: true
    _all?: true
  }

  export type CustomerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customer to aggregate.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Customers
    **/
    _count?: true | CustomerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerMaxAggregateInputType
  }

  export type GetCustomerAggregateType<T extends CustomerAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomer[P]>
      : GetScalarType<T[P], AggregateCustomer[P]>
  }




  export type CustomerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithAggregationInput | CustomerOrderByWithAggregationInput[]
    by: CustomerScalarFieldEnum[] | CustomerScalarFieldEnum
    having?: CustomerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerCountAggregateInputType | true
    _avg?: CustomerAvgAggregateInputType
    _sum?: CustomerSumAggregateInputType
    _min?: CustomerMinAggregateInputType
    _max?: CustomerMaxAggregateInputType
  }

  export type CustomerGroupByOutputType = {
    id: number
    name: string
    phone: string | null
    address: string | null
    createdAt: Date
    _count: CustomerCountAggregateOutputType | null
    _avg: CustomerAvgAggregateOutputType | null
    _sum: CustomerSumAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  type GetCustomerGroupByPayload<T extends CustomerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerGroupByOutputType[P]>
        }
      >
    >


  export type CustomerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    phone?: boolean
    address?: boolean
    createdAt?: boolean
    transactions?: boolean | Customer$transactionsArgs<ExtArgs>
    customerOrders?: boolean | Customer$customerOrdersArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>



  export type CustomerSelectScalar = {
    id?: boolean
    name?: boolean
    phone?: boolean
    address?: boolean
    createdAt?: boolean
  }

  export type CustomerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "phone" | "address" | "createdAt", ExtArgs["result"]["customer"]>
  export type CustomerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | Customer$transactionsArgs<ExtArgs>
    customerOrders?: boolean | Customer$customerOrdersArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CustomerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Customer"
    objects: {
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
      customerOrders: Prisma.$customer_orderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      phone: string | null
      address: string | null
      createdAt: Date
    }, ExtArgs["result"]["customer"]>
    composites: {}
  }

  type CustomerGetPayload<S extends boolean | null | undefined | CustomerDefaultArgs> = $Result.GetResult<Prisma.$CustomerPayload, S>

  type CustomerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerCountAggregateInputType | true
    }

  export interface CustomerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Customer'], meta: { name: 'Customer' } }
    /**
     * Find zero or one Customer that matches the filter.
     * @param {CustomerFindUniqueArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerFindUniqueArgs>(args: SelectSubset<T, CustomerFindUniqueArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Customer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerFindUniqueOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerFindFirstArgs>(args?: SelectSubset<T, CustomerFindFirstArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customer.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerWithIdOnly = await prisma.customer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerFindManyArgs>(args?: SelectSubset<T, CustomerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Customer.
     * @param {CustomerCreateArgs} args - Arguments to create a Customer.
     * @example
     * // Create one Customer
     * const Customer = await prisma.customer.create({
     *   data: {
     *     // ... data to create a Customer
     *   }
     * })
     * 
     */
    create<T extends CustomerCreateArgs>(args: SelectSubset<T, CustomerCreateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Customers.
     * @param {CustomerCreateManyArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerCreateManyArgs>(args?: SelectSubset<T, CustomerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Customer.
     * @param {CustomerDeleteArgs} args - Arguments to delete one Customer.
     * @example
     * // Delete one Customer
     * const Customer = await prisma.customer.delete({
     *   where: {
     *     // ... filter to delete one Customer
     *   }
     * })
     * 
     */
    delete<T extends CustomerDeleteArgs>(args: SelectSubset<T, CustomerDeleteArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Customer.
     * @param {CustomerUpdateArgs} args - Arguments to update one Customer.
     * @example
     * // Update one Customer
     * const customer = await prisma.customer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerUpdateArgs>(args: SelectSubset<T, CustomerUpdateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Customers.
     * @param {CustomerDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerDeleteManyArgs>(args?: SelectSubset<T, CustomerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerUpdateManyArgs>(args: SelectSubset<T, CustomerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Customer.
     * @param {CustomerUpsertArgs} args - Arguments to update or create a Customer.
     * @example
     * // Update or create a Customer
     * const customer = await prisma.customer.upsert({
     *   create: {
     *     // ... data to create a Customer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customer we want to update
     *   }
     * })
     */
    upsert<T extends CustomerUpsertArgs>(args: SelectSubset<T, CustomerUpsertArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customer.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends CustomerCountArgs>(
      args?: Subset<T, CustomerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerAggregateArgs>(args: Subset<T, CustomerAggregateArgs>): Prisma.PrismaPromise<GetCustomerAggregateType<T>>

    /**
     * Group by Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerGroupByArgs['orderBy'] }
        : { orderBy?: CustomerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Customer model
   */
  readonly fields: CustomerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Customer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    transactions<T extends Customer$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, Customer$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    customerOrders<T extends Customer$customerOrdersArgs<ExtArgs> = {}>(args?: Subset<T, Customer$customerOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$customer_orderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Customer model
   */
  interface CustomerFieldRefs {
    readonly id: FieldRef<"Customer", 'Int'>
    readonly name: FieldRef<"Customer", 'String'>
    readonly phone: FieldRef<"Customer", 'String'>
    readonly address: FieldRef<"Customer", 'String'>
    readonly createdAt: FieldRef<"Customer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Customer findUnique
   */
  export type CustomerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findUniqueOrThrow
   */
  export type CustomerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findFirst
   */
  export type CustomerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findFirstOrThrow
   */
  export type CustomerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findMany
   */
  export type CustomerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer create
   */
  export type CustomerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to create a Customer.
     */
    data: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
  }

  /**
   * Customer createMany
   */
  export type CustomerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Customer update
   */
  export type CustomerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to update a Customer.
     */
    data: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
    /**
     * Choose, which Customer to update.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer updateMany
   */
  export type CustomerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to update.
     */
    limit?: number
  }

  /**
   * Customer upsert
   */
  export type CustomerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The filter to search for the Customer to update in case it exists.
     */
    where: CustomerWhereUniqueInput
    /**
     * In case the Customer found by the `where` argument doesn't exist, create a new Customer with this data.
     */
    create: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
    /**
     * In case the Customer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
  }

  /**
   * Customer delete
   */
  export type CustomerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter which Customer to delete.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer deleteMany
   */
  export type CustomerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customers to delete
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to delete.
     */
    limit?: number
  }

  /**
   * Customer.transactions
   */
  export type Customer$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Customer.customerOrders
   */
  export type Customer$customerOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer_order
     */
    select?: customer_orderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer_order
     */
    omit?: customer_orderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customer_orderInclude<ExtArgs> | null
    where?: customer_orderWhereInput
    orderBy?: customer_orderOrderByWithRelationInput | customer_orderOrderByWithRelationInput[]
    cursor?: customer_orderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Customer_orderScalarFieldEnum | Customer_orderScalarFieldEnum[]
  }

  /**
   * Customer without action
   */
  export type CustomerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
  }


  /**
   * Model MasterItem
   */

  export type AggregateMasterItem = {
    _count: MasterItemCountAggregateOutputType | null
    _avg: MasterItemAvgAggregateOutputType | null
    _sum: MasterItemSumAggregateOutputType | null
    _min: MasterItemMinAggregateOutputType | null
    _max: MasterItemMaxAggregateOutputType | null
  }

  export type MasterItemAvgAggregateOutputType = {
    id: number | null
  }

  export type MasterItemSumAggregateOutputType = {
    id: number | null
  }

  export type MasterItemMinAggregateOutputType = {
    id: number | null
    itemName: string | null
    createdAt: Date | null
  }

  export type MasterItemMaxAggregateOutputType = {
    id: number | null
    itemName: string | null
    createdAt: Date | null
  }

  export type MasterItemCountAggregateOutputType = {
    id: number
    itemName: number
    createdAt: number
    _all: number
  }


  export type MasterItemAvgAggregateInputType = {
    id?: true
  }

  export type MasterItemSumAggregateInputType = {
    id?: true
  }

  export type MasterItemMinAggregateInputType = {
    id?: true
    itemName?: true
    createdAt?: true
  }

  export type MasterItemMaxAggregateInputType = {
    id?: true
    itemName?: true
    createdAt?: true
  }

  export type MasterItemCountAggregateInputType = {
    id?: true
    itemName?: true
    createdAt?: true
    _all?: true
  }

  export type MasterItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MasterItem to aggregate.
     */
    where?: MasterItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MasterItems to fetch.
     */
    orderBy?: MasterItemOrderByWithRelationInput | MasterItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MasterItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MasterItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MasterItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MasterItems
    **/
    _count?: true | MasterItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MasterItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MasterItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MasterItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MasterItemMaxAggregateInputType
  }

  export type GetMasterItemAggregateType<T extends MasterItemAggregateArgs> = {
        [P in keyof T & keyof AggregateMasterItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMasterItem[P]>
      : GetScalarType<T[P], AggregateMasterItem[P]>
  }




  export type MasterItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MasterItemWhereInput
    orderBy?: MasterItemOrderByWithAggregationInput | MasterItemOrderByWithAggregationInput[]
    by: MasterItemScalarFieldEnum[] | MasterItemScalarFieldEnum
    having?: MasterItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MasterItemCountAggregateInputType | true
    _avg?: MasterItemAvgAggregateInputType
    _sum?: MasterItemSumAggregateInputType
    _min?: MasterItemMinAggregateInputType
    _max?: MasterItemMaxAggregateInputType
  }

  export type MasterItemGroupByOutputType = {
    id: number
    itemName: string
    createdAt: Date
    _count: MasterItemCountAggregateOutputType | null
    _avg: MasterItemAvgAggregateOutputType | null
    _sum: MasterItemSumAggregateOutputType | null
    _min: MasterItemMinAggregateOutputType | null
    _max: MasterItemMaxAggregateOutputType | null
  }

  type GetMasterItemGroupByPayload<T extends MasterItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MasterItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MasterItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MasterItemGroupByOutputType[P]>
            : GetScalarType<T[P], MasterItemGroupByOutputType[P]>
        }
      >
    >


  export type MasterItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    itemName?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["masterItem"]>



  export type MasterItemSelectScalar = {
    id?: boolean
    itemName?: boolean
    createdAt?: boolean
  }

  export type MasterItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "itemName" | "createdAt", ExtArgs["result"]["masterItem"]>

  export type $MasterItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MasterItem"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      itemName: string
      createdAt: Date
    }, ExtArgs["result"]["masterItem"]>
    composites: {}
  }

  type MasterItemGetPayload<S extends boolean | null | undefined | MasterItemDefaultArgs> = $Result.GetResult<Prisma.$MasterItemPayload, S>

  type MasterItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MasterItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MasterItemCountAggregateInputType | true
    }

  export interface MasterItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MasterItem'], meta: { name: 'MasterItem' } }
    /**
     * Find zero or one MasterItem that matches the filter.
     * @param {MasterItemFindUniqueArgs} args - Arguments to find a MasterItem
     * @example
     * // Get one MasterItem
     * const masterItem = await prisma.masterItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MasterItemFindUniqueArgs>(args: SelectSubset<T, MasterItemFindUniqueArgs<ExtArgs>>): Prisma__MasterItemClient<$Result.GetResult<Prisma.$MasterItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MasterItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MasterItemFindUniqueOrThrowArgs} args - Arguments to find a MasterItem
     * @example
     * // Get one MasterItem
     * const masterItem = await prisma.masterItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MasterItemFindUniqueOrThrowArgs>(args: SelectSubset<T, MasterItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MasterItemClient<$Result.GetResult<Prisma.$MasterItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MasterItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterItemFindFirstArgs} args - Arguments to find a MasterItem
     * @example
     * // Get one MasterItem
     * const masterItem = await prisma.masterItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MasterItemFindFirstArgs>(args?: SelectSubset<T, MasterItemFindFirstArgs<ExtArgs>>): Prisma__MasterItemClient<$Result.GetResult<Prisma.$MasterItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MasterItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterItemFindFirstOrThrowArgs} args - Arguments to find a MasterItem
     * @example
     * // Get one MasterItem
     * const masterItem = await prisma.masterItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MasterItemFindFirstOrThrowArgs>(args?: SelectSubset<T, MasterItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__MasterItemClient<$Result.GetResult<Prisma.$MasterItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MasterItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MasterItems
     * const masterItems = await prisma.masterItem.findMany()
     * 
     * // Get first 10 MasterItems
     * const masterItems = await prisma.masterItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const masterItemWithIdOnly = await prisma.masterItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MasterItemFindManyArgs>(args?: SelectSubset<T, MasterItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MasterItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MasterItem.
     * @param {MasterItemCreateArgs} args - Arguments to create a MasterItem.
     * @example
     * // Create one MasterItem
     * const MasterItem = await prisma.masterItem.create({
     *   data: {
     *     // ... data to create a MasterItem
     *   }
     * })
     * 
     */
    create<T extends MasterItemCreateArgs>(args: SelectSubset<T, MasterItemCreateArgs<ExtArgs>>): Prisma__MasterItemClient<$Result.GetResult<Prisma.$MasterItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MasterItems.
     * @param {MasterItemCreateManyArgs} args - Arguments to create many MasterItems.
     * @example
     * // Create many MasterItems
     * const masterItem = await prisma.masterItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MasterItemCreateManyArgs>(args?: SelectSubset<T, MasterItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MasterItem.
     * @param {MasterItemDeleteArgs} args - Arguments to delete one MasterItem.
     * @example
     * // Delete one MasterItem
     * const MasterItem = await prisma.masterItem.delete({
     *   where: {
     *     // ... filter to delete one MasterItem
     *   }
     * })
     * 
     */
    delete<T extends MasterItemDeleteArgs>(args: SelectSubset<T, MasterItemDeleteArgs<ExtArgs>>): Prisma__MasterItemClient<$Result.GetResult<Prisma.$MasterItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MasterItem.
     * @param {MasterItemUpdateArgs} args - Arguments to update one MasterItem.
     * @example
     * // Update one MasterItem
     * const masterItem = await prisma.masterItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MasterItemUpdateArgs>(args: SelectSubset<T, MasterItemUpdateArgs<ExtArgs>>): Prisma__MasterItemClient<$Result.GetResult<Prisma.$MasterItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MasterItems.
     * @param {MasterItemDeleteManyArgs} args - Arguments to filter MasterItems to delete.
     * @example
     * // Delete a few MasterItems
     * const { count } = await prisma.masterItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MasterItemDeleteManyArgs>(args?: SelectSubset<T, MasterItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MasterItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MasterItems
     * const masterItem = await prisma.masterItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MasterItemUpdateManyArgs>(args: SelectSubset<T, MasterItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MasterItem.
     * @param {MasterItemUpsertArgs} args - Arguments to update or create a MasterItem.
     * @example
     * // Update or create a MasterItem
     * const masterItem = await prisma.masterItem.upsert({
     *   create: {
     *     // ... data to create a MasterItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MasterItem we want to update
     *   }
     * })
     */
    upsert<T extends MasterItemUpsertArgs>(args: SelectSubset<T, MasterItemUpsertArgs<ExtArgs>>): Prisma__MasterItemClient<$Result.GetResult<Prisma.$MasterItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MasterItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterItemCountArgs} args - Arguments to filter MasterItems to count.
     * @example
     * // Count the number of MasterItems
     * const count = await prisma.masterItem.count({
     *   where: {
     *     // ... the filter for the MasterItems we want to count
     *   }
     * })
    **/
    count<T extends MasterItemCountArgs>(
      args?: Subset<T, MasterItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MasterItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MasterItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MasterItemAggregateArgs>(args: Subset<T, MasterItemAggregateArgs>): Prisma.PrismaPromise<GetMasterItemAggregateType<T>>

    /**
     * Group by MasterItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MasterItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MasterItemGroupByArgs['orderBy'] }
        : { orderBy?: MasterItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MasterItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMasterItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MasterItem model
   */
  readonly fields: MasterItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MasterItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MasterItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MasterItem model
   */
  interface MasterItemFieldRefs {
    readonly id: FieldRef<"MasterItem", 'Int'>
    readonly itemName: FieldRef<"MasterItem", 'String'>
    readonly createdAt: FieldRef<"MasterItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MasterItem findUnique
   */
  export type MasterItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterItem
     */
    select?: MasterItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MasterItem
     */
    omit?: MasterItemOmit<ExtArgs> | null
    /**
     * Filter, which MasterItem to fetch.
     */
    where: MasterItemWhereUniqueInput
  }

  /**
   * MasterItem findUniqueOrThrow
   */
  export type MasterItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterItem
     */
    select?: MasterItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MasterItem
     */
    omit?: MasterItemOmit<ExtArgs> | null
    /**
     * Filter, which MasterItem to fetch.
     */
    where: MasterItemWhereUniqueInput
  }

  /**
   * MasterItem findFirst
   */
  export type MasterItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterItem
     */
    select?: MasterItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MasterItem
     */
    omit?: MasterItemOmit<ExtArgs> | null
    /**
     * Filter, which MasterItem to fetch.
     */
    where?: MasterItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MasterItems to fetch.
     */
    orderBy?: MasterItemOrderByWithRelationInput | MasterItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MasterItems.
     */
    cursor?: MasterItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MasterItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MasterItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MasterItems.
     */
    distinct?: MasterItemScalarFieldEnum | MasterItemScalarFieldEnum[]
  }

  /**
   * MasterItem findFirstOrThrow
   */
  export type MasterItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterItem
     */
    select?: MasterItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MasterItem
     */
    omit?: MasterItemOmit<ExtArgs> | null
    /**
     * Filter, which MasterItem to fetch.
     */
    where?: MasterItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MasterItems to fetch.
     */
    orderBy?: MasterItemOrderByWithRelationInput | MasterItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MasterItems.
     */
    cursor?: MasterItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MasterItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MasterItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MasterItems.
     */
    distinct?: MasterItemScalarFieldEnum | MasterItemScalarFieldEnum[]
  }

  /**
   * MasterItem findMany
   */
  export type MasterItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterItem
     */
    select?: MasterItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MasterItem
     */
    omit?: MasterItemOmit<ExtArgs> | null
    /**
     * Filter, which MasterItems to fetch.
     */
    where?: MasterItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MasterItems to fetch.
     */
    orderBy?: MasterItemOrderByWithRelationInput | MasterItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MasterItems.
     */
    cursor?: MasterItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MasterItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MasterItems.
     */
    skip?: number
    distinct?: MasterItemScalarFieldEnum | MasterItemScalarFieldEnum[]
  }

  /**
   * MasterItem create
   */
  export type MasterItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterItem
     */
    select?: MasterItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MasterItem
     */
    omit?: MasterItemOmit<ExtArgs> | null
    /**
     * The data needed to create a MasterItem.
     */
    data: XOR<MasterItemCreateInput, MasterItemUncheckedCreateInput>
  }

  /**
   * MasterItem createMany
   */
  export type MasterItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MasterItems.
     */
    data: MasterItemCreateManyInput | MasterItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MasterItem update
   */
  export type MasterItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterItem
     */
    select?: MasterItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MasterItem
     */
    omit?: MasterItemOmit<ExtArgs> | null
    /**
     * The data needed to update a MasterItem.
     */
    data: XOR<MasterItemUpdateInput, MasterItemUncheckedUpdateInput>
    /**
     * Choose, which MasterItem to update.
     */
    where: MasterItemWhereUniqueInput
  }

  /**
   * MasterItem updateMany
   */
  export type MasterItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MasterItems.
     */
    data: XOR<MasterItemUpdateManyMutationInput, MasterItemUncheckedUpdateManyInput>
    /**
     * Filter which MasterItems to update
     */
    where?: MasterItemWhereInput
    /**
     * Limit how many MasterItems to update.
     */
    limit?: number
  }

  /**
   * MasterItem upsert
   */
  export type MasterItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterItem
     */
    select?: MasterItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MasterItem
     */
    omit?: MasterItemOmit<ExtArgs> | null
    /**
     * The filter to search for the MasterItem to update in case it exists.
     */
    where: MasterItemWhereUniqueInput
    /**
     * In case the MasterItem found by the `where` argument doesn't exist, create a new MasterItem with this data.
     */
    create: XOR<MasterItemCreateInput, MasterItemUncheckedCreateInput>
    /**
     * In case the MasterItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MasterItemUpdateInput, MasterItemUncheckedUpdateInput>
  }

  /**
   * MasterItem delete
   */
  export type MasterItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterItem
     */
    select?: MasterItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MasterItem
     */
    omit?: MasterItemOmit<ExtArgs> | null
    /**
     * Filter which MasterItem to delete.
     */
    where: MasterItemWhereUniqueInput
  }

  /**
   * MasterItem deleteMany
   */
  export type MasterItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MasterItems to delete
     */
    where?: MasterItemWhereInput
    /**
     * Limit how many MasterItems to delete.
     */
    limit?: number
  }

  /**
   * MasterItem without action
   */
  export type MasterItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterItem
     */
    select?: MasterItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MasterItem
     */
    omit?: MasterItemOmit<ExtArgs> | null
  }


  /**
   * Model MasterTouch
   */

  export type AggregateMasterTouch = {
    _count: MasterTouchCountAggregateOutputType | null
    _avg: MasterTouchAvgAggregateOutputType | null
    _sum: MasterTouchSumAggregateOutputType | null
    _min: MasterTouchMinAggregateOutputType | null
    _max: MasterTouchMaxAggregateOutputType | null
  }

  export type MasterTouchAvgAggregateOutputType = {
    id: number | null
    touch: number | null
  }

  export type MasterTouchSumAggregateOutputType = {
    id: number | null
    touch: number | null
  }

  export type MasterTouchMinAggregateOutputType = {
    id: number | null
    touch: number | null
    createdAt: Date | null
  }

  export type MasterTouchMaxAggregateOutputType = {
    id: number | null
    touch: number | null
    createdAt: Date | null
  }

  export type MasterTouchCountAggregateOutputType = {
    id: number
    touch: number
    createdAt: number
    _all: number
  }


  export type MasterTouchAvgAggregateInputType = {
    id?: true
    touch?: true
  }

  export type MasterTouchSumAggregateInputType = {
    id?: true
    touch?: true
  }

  export type MasterTouchMinAggregateInputType = {
    id?: true
    touch?: true
    createdAt?: true
  }

  export type MasterTouchMaxAggregateInputType = {
    id?: true
    touch?: true
    createdAt?: true
  }

  export type MasterTouchCountAggregateInputType = {
    id?: true
    touch?: true
    createdAt?: true
    _all?: true
  }

  export type MasterTouchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MasterTouch to aggregate.
     */
    where?: MasterTouchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MasterTouches to fetch.
     */
    orderBy?: MasterTouchOrderByWithRelationInput | MasterTouchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MasterTouchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MasterTouches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MasterTouches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MasterTouches
    **/
    _count?: true | MasterTouchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MasterTouchAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MasterTouchSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MasterTouchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MasterTouchMaxAggregateInputType
  }

  export type GetMasterTouchAggregateType<T extends MasterTouchAggregateArgs> = {
        [P in keyof T & keyof AggregateMasterTouch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMasterTouch[P]>
      : GetScalarType<T[P], AggregateMasterTouch[P]>
  }




  export type MasterTouchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MasterTouchWhereInput
    orderBy?: MasterTouchOrderByWithAggregationInput | MasterTouchOrderByWithAggregationInput[]
    by: MasterTouchScalarFieldEnum[] | MasterTouchScalarFieldEnum
    having?: MasterTouchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MasterTouchCountAggregateInputType | true
    _avg?: MasterTouchAvgAggregateInputType
    _sum?: MasterTouchSumAggregateInputType
    _min?: MasterTouchMinAggregateInputType
    _max?: MasterTouchMaxAggregateInputType
  }

  export type MasterTouchGroupByOutputType = {
    id: number
    touch: number
    createdAt: Date
    _count: MasterTouchCountAggregateOutputType | null
    _avg: MasterTouchAvgAggregateOutputType | null
    _sum: MasterTouchSumAggregateOutputType | null
    _min: MasterTouchMinAggregateOutputType | null
    _max: MasterTouchMaxAggregateOutputType | null
  }

  type GetMasterTouchGroupByPayload<T extends MasterTouchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MasterTouchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MasterTouchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MasterTouchGroupByOutputType[P]>
            : GetScalarType<T[P], MasterTouchGroupByOutputType[P]>
        }
      >
    >


  export type MasterTouchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    touch?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["masterTouch"]>



  export type MasterTouchSelectScalar = {
    id?: boolean
    touch?: boolean
    createdAt?: boolean
  }

  export type MasterTouchOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "touch" | "createdAt", ExtArgs["result"]["masterTouch"]>

  export type $MasterTouchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MasterTouch"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      touch: number
      createdAt: Date
    }, ExtArgs["result"]["masterTouch"]>
    composites: {}
  }

  type MasterTouchGetPayload<S extends boolean | null | undefined | MasterTouchDefaultArgs> = $Result.GetResult<Prisma.$MasterTouchPayload, S>

  type MasterTouchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MasterTouchFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MasterTouchCountAggregateInputType | true
    }

  export interface MasterTouchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MasterTouch'], meta: { name: 'MasterTouch' } }
    /**
     * Find zero or one MasterTouch that matches the filter.
     * @param {MasterTouchFindUniqueArgs} args - Arguments to find a MasterTouch
     * @example
     * // Get one MasterTouch
     * const masterTouch = await prisma.masterTouch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MasterTouchFindUniqueArgs>(args: SelectSubset<T, MasterTouchFindUniqueArgs<ExtArgs>>): Prisma__MasterTouchClient<$Result.GetResult<Prisma.$MasterTouchPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MasterTouch that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MasterTouchFindUniqueOrThrowArgs} args - Arguments to find a MasterTouch
     * @example
     * // Get one MasterTouch
     * const masterTouch = await prisma.masterTouch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MasterTouchFindUniqueOrThrowArgs>(args: SelectSubset<T, MasterTouchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MasterTouchClient<$Result.GetResult<Prisma.$MasterTouchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MasterTouch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterTouchFindFirstArgs} args - Arguments to find a MasterTouch
     * @example
     * // Get one MasterTouch
     * const masterTouch = await prisma.masterTouch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MasterTouchFindFirstArgs>(args?: SelectSubset<T, MasterTouchFindFirstArgs<ExtArgs>>): Prisma__MasterTouchClient<$Result.GetResult<Prisma.$MasterTouchPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MasterTouch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterTouchFindFirstOrThrowArgs} args - Arguments to find a MasterTouch
     * @example
     * // Get one MasterTouch
     * const masterTouch = await prisma.masterTouch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MasterTouchFindFirstOrThrowArgs>(args?: SelectSubset<T, MasterTouchFindFirstOrThrowArgs<ExtArgs>>): Prisma__MasterTouchClient<$Result.GetResult<Prisma.$MasterTouchPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MasterTouches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterTouchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MasterTouches
     * const masterTouches = await prisma.masterTouch.findMany()
     * 
     * // Get first 10 MasterTouches
     * const masterTouches = await prisma.masterTouch.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const masterTouchWithIdOnly = await prisma.masterTouch.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MasterTouchFindManyArgs>(args?: SelectSubset<T, MasterTouchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MasterTouchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MasterTouch.
     * @param {MasterTouchCreateArgs} args - Arguments to create a MasterTouch.
     * @example
     * // Create one MasterTouch
     * const MasterTouch = await prisma.masterTouch.create({
     *   data: {
     *     // ... data to create a MasterTouch
     *   }
     * })
     * 
     */
    create<T extends MasterTouchCreateArgs>(args: SelectSubset<T, MasterTouchCreateArgs<ExtArgs>>): Prisma__MasterTouchClient<$Result.GetResult<Prisma.$MasterTouchPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MasterTouches.
     * @param {MasterTouchCreateManyArgs} args - Arguments to create many MasterTouches.
     * @example
     * // Create many MasterTouches
     * const masterTouch = await prisma.masterTouch.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MasterTouchCreateManyArgs>(args?: SelectSubset<T, MasterTouchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MasterTouch.
     * @param {MasterTouchDeleteArgs} args - Arguments to delete one MasterTouch.
     * @example
     * // Delete one MasterTouch
     * const MasterTouch = await prisma.masterTouch.delete({
     *   where: {
     *     // ... filter to delete one MasterTouch
     *   }
     * })
     * 
     */
    delete<T extends MasterTouchDeleteArgs>(args: SelectSubset<T, MasterTouchDeleteArgs<ExtArgs>>): Prisma__MasterTouchClient<$Result.GetResult<Prisma.$MasterTouchPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MasterTouch.
     * @param {MasterTouchUpdateArgs} args - Arguments to update one MasterTouch.
     * @example
     * // Update one MasterTouch
     * const masterTouch = await prisma.masterTouch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MasterTouchUpdateArgs>(args: SelectSubset<T, MasterTouchUpdateArgs<ExtArgs>>): Prisma__MasterTouchClient<$Result.GetResult<Prisma.$MasterTouchPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MasterTouches.
     * @param {MasterTouchDeleteManyArgs} args - Arguments to filter MasterTouches to delete.
     * @example
     * // Delete a few MasterTouches
     * const { count } = await prisma.masterTouch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MasterTouchDeleteManyArgs>(args?: SelectSubset<T, MasterTouchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MasterTouches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterTouchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MasterTouches
     * const masterTouch = await prisma.masterTouch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MasterTouchUpdateManyArgs>(args: SelectSubset<T, MasterTouchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MasterTouch.
     * @param {MasterTouchUpsertArgs} args - Arguments to update or create a MasterTouch.
     * @example
     * // Update or create a MasterTouch
     * const masterTouch = await prisma.masterTouch.upsert({
     *   create: {
     *     // ... data to create a MasterTouch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MasterTouch we want to update
     *   }
     * })
     */
    upsert<T extends MasterTouchUpsertArgs>(args: SelectSubset<T, MasterTouchUpsertArgs<ExtArgs>>): Prisma__MasterTouchClient<$Result.GetResult<Prisma.$MasterTouchPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MasterTouches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterTouchCountArgs} args - Arguments to filter MasterTouches to count.
     * @example
     * // Count the number of MasterTouches
     * const count = await prisma.masterTouch.count({
     *   where: {
     *     // ... the filter for the MasterTouches we want to count
     *   }
     * })
    **/
    count<T extends MasterTouchCountArgs>(
      args?: Subset<T, MasterTouchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MasterTouchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MasterTouch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterTouchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MasterTouchAggregateArgs>(args: Subset<T, MasterTouchAggregateArgs>): Prisma.PrismaPromise<GetMasterTouchAggregateType<T>>

    /**
     * Group by MasterTouch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterTouchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MasterTouchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MasterTouchGroupByArgs['orderBy'] }
        : { orderBy?: MasterTouchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MasterTouchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMasterTouchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MasterTouch model
   */
  readonly fields: MasterTouchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MasterTouch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MasterTouchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MasterTouch model
   */
  interface MasterTouchFieldRefs {
    readonly id: FieldRef<"MasterTouch", 'Int'>
    readonly touch: FieldRef<"MasterTouch", 'Float'>
    readonly createdAt: FieldRef<"MasterTouch", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MasterTouch findUnique
   */
  export type MasterTouchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterTouch
     */
    select?: MasterTouchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MasterTouch
     */
    omit?: MasterTouchOmit<ExtArgs> | null
    /**
     * Filter, which MasterTouch to fetch.
     */
    where: MasterTouchWhereUniqueInput
  }

  /**
   * MasterTouch findUniqueOrThrow
   */
  export type MasterTouchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterTouch
     */
    select?: MasterTouchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MasterTouch
     */
    omit?: MasterTouchOmit<ExtArgs> | null
    /**
     * Filter, which MasterTouch to fetch.
     */
    where: MasterTouchWhereUniqueInput
  }

  /**
   * MasterTouch findFirst
   */
  export type MasterTouchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterTouch
     */
    select?: MasterTouchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MasterTouch
     */
    omit?: MasterTouchOmit<ExtArgs> | null
    /**
     * Filter, which MasterTouch to fetch.
     */
    where?: MasterTouchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MasterTouches to fetch.
     */
    orderBy?: MasterTouchOrderByWithRelationInput | MasterTouchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MasterTouches.
     */
    cursor?: MasterTouchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MasterTouches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MasterTouches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MasterTouches.
     */
    distinct?: MasterTouchScalarFieldEnum | MasterTouchScalarFieldEnum[]
  }

  /**
   * MasterTouch findFirstOrThrow
   */
  export type MasterTouchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterTouch
     */
    select?: MasterTouchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MasterTouch
     */
    omit?: MasterTouchOmit<ExtArgs> | null
    /**
     * Filter, which MasterTouch to fetch.
     */
    where?: MasterTouchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MasterTouches to fetch.
     */
    orderBy?: MasterTouchOrderByWithRelationInput | MasterTouchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MasterTouches.
     */
    cursor?: MasterTouchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MasterTouches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MasterTouches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MasterTouches.
     */
    distinct?: MasterTouchScalarFieldEnum | MasterTouchScalarFieldEnum[]
  }

  /**
   * MasterTouch findMany
   */
  export type MasterTouchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterTouch
     */
    select?: MasterTouchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MasterTouch
     */
    omit?: MasterTouchOmit<ExtArgs> | null
    /**
     * Filter, which MasterTouches to fetch.
     */
    where?: MasterTouchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MasterTouches to fetch.
     */
    orderBy?: MasterTouchOrderByWithRelationInput | MasterTouchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MasterTouches.
     */
    cursor?: MasterTouchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MasterTouches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MasterTouches.
     */
    skip?: number
    distinct?: MasterTouchScalarFieldEnum | MasterTouchScalarFieldEnum[]
  }

  /**
   * MasterTouch create
   */
  export type MasterTouchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterTouch
     */
    select?: MasterTouchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MasterTouch
     */
    omit?: MasterTouchOmit<ExtArgs> | null
    /**
     * The data needed to create a MasterTouch.
     */
    data: XOR<MasterTouchCreateInput, MasterTouchUncheckedCreateInput>
  }

  /**
   * MasterTouch createMany
   */
  export type MasterTouchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MasterTouches.
     */
    data: MasterTouchCreateManyInput | MasterTouchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MasterTouch update
   */
  export type MasterTouchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterTouch
     */
    select?: MasterTouchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MasterTouch
     */
    omit?: MasterTouchOmit<ExtArgs> | null
    /**
     * The data needed to update a MasterTouch.
     */
    data: XOR<MasterTouchUpdateInput, MasterTouchUncheckedUpdateInput>
    /**
     * Choose, which MasterTouch to update.
     */
    where: MasterTouchWhereUniqueInput
  }

  /**
   * MasterTouch updateMany
   */
  export type MasterTouchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MasterTouches.
     */
    data: XOR<MasterTouchUpdateManyMutationInput, MasterTouchUncheckedUpdateManyInput>
    /**
     * Filter which MasterTouches to update
     */
    where?: MasterTouchWhereInput
    /**
     * Limit how many MasterTouches to update.
     */
    limit?: number
  }

  /**
   * MasterTouch upsert
   */
  export type MasterTouchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterTouch
     */
    select?: MasterTouchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MasterTouch
     */
    omit?: MasterTouchOmit<ExtArgs> | null
    /**
     * The filter to search for the MasterTouch to update in case it exists.
     */
    where: MasterTouchWhereUniqueInput
    /**
     * In case the MasterTouch found by the `where` argument doesn't exist, create a new MasterTouch with this data.
     */
    create: XOR<MasterTouchCreateInput, MasterTouchUncheckedCreateInput>
    /**
     * In case the MasterTouch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MasterTouchUpdateInput, MasterTouchUncheckedUpdateInput>
  }

  /**
   * MasterTouch delete
   */
  export type MasterTouchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterTouch
     */
    select?: MasterTouchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MasterTouch
     */
    omit?: MasterTouchOmit<ExtArgs> | null
    /**
     * Filter which MasterTouch to delete.
     */
    where: MasterTouchWhereUniqueInput
  }

  /**
   * MasterTouch deleteMany
   */
  export type MasterTouchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MasterTouches to delete
     */
    where?: MasterTouchWhereInput
    /**
     * Limit how many MasterTouches to delete.
     */
    limit?: number
  }

  /**
   * MasterTouch without action
   */
  export type MasterTouchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterTouch
     */
    select?: MasterTouchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MasterTouch
     */
    omit?: MasterTouchOmit<ExtArgs> | null
  }


  /**
   * Model JewelStock
   */

  export type AggregateJewelStock = {
    _count: JewelStockCountAggregateOutputType | null
    _avg: JewelStockAvgAggregateOutputType | null
    _sum: JewelStockSumAggregateOutputType | null
    _min: JewelStockMinAggregateOutputType | null
    _max: JewelStockMaxAggregateOutputType | null
  }

  export type JewelStockAvgAggregateOutputType = {
    id: number | null
    weight: number | null
    stoneWeight: number | null
    finalWeight: number | null
    touch: number | null
    purityValue: number | null
  }

  export type JewelStockSumAggregateOutputType = {
    id: number | null
    weight: number | null
    stoneWeight: number | null
    finalWeight: number | null
    touch: number | null
    purityValue: number | null
  }

  export type JewelStockMinAggregateOutputType = {
    id: number | null
    jewelName: string | null
    weight: number | null
    stoneWeight: number | null
    finalWeight: number | null
    touch: number | null
    purityValue: number | null
    createdAt: Date | null
  }

  export type JewelStockMaxAggregateOutputType = {
    id: number | null
    jewelName: string | null
    weight: number | null
    stoneWeight: number | null
    finalWeight: number | null
    touch: number | null
    purityValue: number | null
    createdAt: Date | null
  }

  export type JewelStockCountAggregateOutputType = {
    id: number
    jewelName: number
    weight: number
    stoneWeight: number
    finalWeight: number
    touch: number
    purityValue: number
    createdAt: number
    _all: number
  }


  export type JewelStockAvgAggregateInputType = {
    id?: true
    weight?: true
    stoneWeight?: true
    finalWeight?: true
    touch?: true
    purityValue?: true
  }

  export type JewelStockSumAggregateInputType = {
    id?: true
    weight?: true
    stoneWeight?: true
    finalWeight?: true
    touch?: true
    purityValue?: true
  }

  export type JewelStockMinAggregateInputType = {
    id?: true
    jewelName?: true
    weight?: true
    stoneWeight?: true
    finalWeight?: true
    touch?: true
    purityValue?: true
    createdAt?: true
  }

  export type JewelStockMaxAggregateInputType = {
    id?: true
    jewelName?: true
    weight?: true
    stoneWeight?: true
    finalWeight?: true
    touch?: true
    purityValue?: true
    createdAt?: true
  }

  export type JewelStockCountAggregateInputType = {
    id?: true
    jewelName?: true
    weight?: true
    stoneWeight?: true
    finalWeight?: true
    touch?: true
    purityValue?: true
    createdAt?: true
    _all?: true
  }

  export type JewelStockAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JewelStock to aggregate.
     */
    where?: JewelStockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JewelStocks to fetch.
     */
    orderBy?: JewelStockOrderByWithRelationInput | JewelStockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JewelStockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JewelStocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JewelStocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JewelStocks
    **/
    _count?: true | JewelStockCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JewelStockAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JewelStockSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JewelStockMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JewelStockMaxAggregateInputType
  }

  export type GetJewelStockAggregateType<T extends JewelStockAggregateArgs> = {
        [P in keyof T & keyof AggregateJewelStock]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJewelStock[P]>
      : GetScalarType<T[P], AggregateJewelStock[P]>
  }




  export type JewelStockGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JewelStockWhereInput
    orderBy?: JewelStockOrderByWithAggregationInput | JewelStockOrderByWithAggregationInput[]
    by: JewelStockScalarFieldEnum[] | JewelStockScalarFieldEnum
    having?: JewelStockScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JewelStockCountAggregateInputType | true
    _avg?: JewelStockAvgAggregateInputType
    _sum?: JewelStockSumAggregateInputType
    _min?: JewelStockMinAggregateInputType
    _max?: JewelStockMaxAggregateInputType
  }

  export type JewelStockGroupByOutputType = {
    id: number
    jewelName: string
    weight: number
    stoneWeight: number
    finalWeight: number
    touch: number
    purityValue: number
    createdAt: Date
    _count: JewelStockCountAggregateOutputType | null
    _avg: JewelStockAvgAggregateOutputType | null
    _sum: JewelStockSumAggregateOutputType | null
    _min: JewelStockMinAggregateOutputType | null
    _max: JewelStockMaxAggregateOutputType | null
  }

  type GetJewelStockGroupByPayload<T extends JewelStockGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JewelStockGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JewelStockGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JewelStockGroupByOutputType[P]>
            : GetScalarType<T[P], JewelStockGroupByOutputType[P]>
        }
      >
    >


  export type JewelStockSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jewelName?: boolean
    weight?: boolean
    stoneWeight?: boolean
    finalWeight?: boolean
    touch?: boolean
    purityValue?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["jewelStock"]>



  export type JewelStockSelectScalar = {
    id?: boolean
    jewelName?: boolean
    weight?: boolean
    stoneWeight?: boolean
    finalWeight?: boolean
    touch?: boolean
    purityValue?: boolean
    createdAt?: boolean
  }

  export type JewelStockOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "jewelName" | "weight" | "stoneWeight" | "finalWeight" | "touch" | "purityValue" | "createdAt", ExtArgs["result"]["jewelStock"]>

  export type $JewelStockPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JewelStock"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      jewelName: string
      weight: number
      stoneWeight: number
      finalWeight: number
      touch: number
      purityValue: number
      createdAt: Date
    }, ExtArgs["result"]["jewelStock"]>
    composites: {}
  }

  type JewelStockGetPayload<S extends boolean | null | undefined | JewelStockDefaultArgs> = $Result.GetResult<Prisma.$JewelStockPayload, S>

  type JewelStockCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<JewelStockFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JewelStockCountAggregateInputType | true
    }

  export interface JewelStockDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JewelStock'], meta: { name: 'JewelStock' } }
    /**
     * Find zero or one JewelStock that matches the filter.
     * @param {JewelStockFindUniqueArgs} args - Arguments to find a JewelStock
     * @example
     * // Get one JewelStock
     * const jewelStock = await prisma.jewelStock.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JewelStockFindUniqueArgs>(args: SelectSubset<T, JewelStockFindUniqueArgs<ExtArgs>>): Prisma__JewelStockClient<$Result.GetResult<Prisma.$JewelStockPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one JewelStock that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {JewelStockFindUniqueOrThrowArgs} args - Arguments to find a JewelStock
     * @example
     * // Get one JewelStock
     * const jewelStock = await prisma.jewelStock.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JewelStockFindUniqueOrThrowArgs>(args: SelectSubset<T, JewelStockFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JewelStockClient<$Result.GetResult<Prisma.$JewelStockPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JewelStock that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JewelStockFindFirstArgs} args - Arguments to find a JewelStock
     * @example
     * // Get one JewelStock
     * const jewelStock = await prisma.jewelStock.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JewelStockFindFirstArgs>(args?: SelectSubset<T, JewelStockFindFirstArgs<ExtArgs>>): Prisma__JewelStockClient<$Result.GetResult<Prisma.$JewelStockPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JewelStock that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JewelStockFindFirstOrThrowArgs} args - Arguments to find a JewelStock
     * @example
     * // Get one JewelStock
     * const jewelStock = await prisma.jewelStock.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JewelStockFindFirstOrThrowArgs>(args?: SelectSubset<T, JewelStockFindFirstOrThrowArgs<ExtArgs>>): Prisma__JewelStockClient<$Result.GetResult<Prisma.$JewelStockPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more JewelStocks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JewelStockFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JewelStocks
     * const jewelStocks = await prisma.jewelStock.findMany()
     * 
     * // Get first 10 JewelStocks
     * const jewelStocks = await prisma.jewelStock.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const jewelStockWithIdOnly = await prisma.jewelStock.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JewelStockFindManyArgs>(args?: SelectSubset<T, JewelStockFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JewelStockPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a JewelStock.
     * @param {JewelStockCreateArgs} args - Arguments to create a JewelStock.
     * @example
     * // Create one JewelStock
     * const JewelStock = await prisma.jewelStock.create({
     *   data: {
     *     // ... data to create a JewelStock
     *   }
     * })
     * 
     */
    create<T extends JewelStockCreateArgs>(args: SelectSubset<T, JewelStockCreateArgs<ExtArgs>>): Prisma__JewelStockClient<$Result.GetResult<Prisma.$JewelStockPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many JewelStocks.
     * @param {JewelStockCreateManyArgs} args - Arguments to create many JewelStocks.
     * @example
     * // Create many JewelStocks
     * const jewelStock = await prisma.jewelStock.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JewelStockCreateManyArgs>(args?: SelectSubset<T, JewelStockCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a JewelStock.
     * @param {JewelStockDeleteArgs} args - Arguments to delete one JewelStock.
     * @example
     * // Delete one JewelStock
     * const JewelStock = await prisma.jewelStock.delete({
     *   where: {
     *     // ... filter to delete one JewelStock
     *   }
     * })
     * 
     */
    delete<T extends JewelStockDeleteArgs>(args: SelectSubset<T, JewelStockDeleteArgs<ExtArgs>>): Prisma__JewelStockClient<$Result.GetResult<Prisma.$JewelStockPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one JewelStock.
     * @param {JewelStockUpdateArgs} args - Arguments to update one JewelStock.
     * @example
     * // Update one JewelStock
     * const jewelStock = await prisma.jewelStock.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JewelStockUpdateArgs>(args: SelectSubset<T, JewelStockUpdateArgs<ExtArgs>>): Prisma__JewelStockClient<$Result.GetResult<Prisma.$JewelStockPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more JewelStocks.
     * @param {JewelStockDeleteManyArgs} args - Arguments to filter JewelStocks to delete.
     * @example
     * // Delete a few JewelStocks
     * const { count } = await prisma.jewelStock.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JewelStockDeleteManyArgs>(args?: SelectSubset<T, JewelStockDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JewelStocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JewelStockUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JewelStocks
     * const jewelStock = await prisma.jewelStock.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JewelStockUpdateManyArgs>(args: SelectSubset<T, JewelStockUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one JewelStock.
     * @param {JewelStockUpsertArgs} args - Arguments to update or create a JewelStock.
     * @example
     * // Update or create a JewelStock
     * const jewelStock = await prisma.jewelStock.upsert({
     *   create: {
     *     // ... data to create a JewelStock
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JewelStock we want to update
     *   }
     * })
     */
    upsert<T extends JewelStockUpsertArgs>(args: SelectSubset<T, JewelStockUpsertArgs<ExtArgs>>): Prisma__JewelStockClient<$Result.GetResult<Prisma.$JewelStockPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of JewelStocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JewelStockCountArgs} args - Arguments to filter JewelStocks to count.
     * @example
     * // Count the number of JewelStocks
     * const count = await prisma.jewelStock.count({
     *   where: {
     *     // ... the filter for the JewelStocks we want to count
     *   }
     * })
    **/
    count<T extends JewelStockCountArgs>(
      args?: Subset<T, JewelStockCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JewelStockCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JewelStock.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JewelStockAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JewelStockAggregateArgs>(args: Subset<T, JewelStockAggregateArgs>): Prisma.PrismaPromise<GetJewelStockAggregateType<T>>

    /**
     * Group by JewelStock.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JewelStockGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JewelStockGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JewelStockGroupByArgs['orderBy'] }
        : { orderBy?: JewelStockGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JewelStockGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJewelStockGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JewelStock model
   */
  readonly fields: JewelStockFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JewelStock.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JewelStockClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the JewelStock model
   */
  interface JewelStockFieldRefs {
    readonly id: FieldRef<"JewelStock", 'Int'>
    readonly jewelName: FieldRef<"JewelStock", 'String'>
    readonly weight: FieldRef<"JewelStock", 'Float'>
    readonly stoneWeight: FieldRef<"JewelStock", 'Float'>
    readonly finalWeight: FieldRef<"JewelStock", 'Float'>
    readonly touch: FieldRef<"JewelStock", 'Float'>
    readonly purityValue: FieldRef<"JewelStock", 'Float'>
    readonly createdAt: FieldRef<"JewelStock", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * JewelStock findUnique
   */
  export type JewelStockFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JewelStock
     */
    select?: JewelStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JewelStock
     */
    omit?: JewelStockOmit<ExtArgs> | null
    /**
     * Filter, which JewelStock to fetch.
     */
    where: JewelStockWhereUniqueInput
  }

  /**
   * JewelStock findUniqueOrThrow
   */
  export type JewelStockFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JewelStock
     */
    select?: JewelStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JewelStock
     */
    omit?: JewelStockOmit<ExtArgs> | null
    /**
     * Filter, which JewelStock to fetch.
     */
    where: JewelStockWhereUniqueInput
  }

  /**
   * JewelStock findFirst
   */
  export type JewelStockFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JewelStock
     */
    select?: JewelStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JewelStock
     */
    omit?: JewelStockOmit<ExtArgs> | null
    /**
     * Filter, which JewelStock to fetch.
     */
    where?: JewelStockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JewelStocks to fetch.
     */
    orderBy?: JewelStockOrderByWithRelationInput | JewelStockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JewelStocks.
     */
    cursor?: JewelStockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JewelStocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JewelStocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JewelStocks.
     */
    distinct?: JewelStockScalarFieldEnum | JewelStockScalarFieldEnum[]
  }

  /**
   * JewelStock findFirstOrThrow
   */
  export type JewelStockFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JewelStock
     */
    select?: JewelStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JewelStock
     */
    omit?: JewelStockOmit<ExtArgs> | null
    /**
     * Filter, which JewelStock to fetch.
     */
    where?: JewelStockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JewelStocks to fetch.
     */
    orderBy?: JewelStockOrderByWithRelationInput | JewelStockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JewelStocks.
     */
    cursor?: JewelStockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JewelStocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JewelStocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JewelStocks.
     */
    distinct?: JewelStockScalarFieldEnum | JewelStockScalarFieldEnum[]
  }

  /**
   * JewelStock findMany
   */
  export type JewelStockFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JewelStock
     */
    select?: JewelStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JewelStock
     */
    omit?: JewelStockOmit<ExtArgs> | null
    /**
     * Filter, which JewelStocks to fetch.
     */
    where?: JewelStockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JewelStocks to fetch.
     */
    orderBy?: JewelStockOrderByWithRelationInput | JewelStockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JewelStocks.
     */
    cursor?: JewelStockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JewelStocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JewelStocks.
     */
    skip?: number
    distinct?: JewelStockScalarFieldEnum | JewelStockScalarFieldEnum[]
  }

  /**
   * JewelStock create
   */
  export type JewelStockCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JewelStock
     */
    select?: JewelStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JewelStock
     */
    omit?: JewelStockOmit<ExtArgs> | null
    /**
     * The data needed to create a JewelStock.
     */
    data: XOR<JewelStockCreateInput, JewelStockUncheckedCreateInput>
  }

  /**
   * JewelStock createMany
   */
  export type JewelStockCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JewelStocks.
     */
    data: JewelStockCreateManyInput | JewelStockCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * JewelStock update
   */
  export type JewelStockUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JewelStock
     */
    select?: JewelStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JewelStock
     */
    omit?: JewelStockOmit<ExtArgs> | null
    /**
     * The data needed to update a JewelStock.
     */
    data: XOR<JewelStockUpdateInput, JewelStockUncheckedUpdateInput>
    /**
     * Choose, which JewelStock to update.
     */
    where: JewelStockWhereUniqueInput
  }

  /**
   * JewelStock updateMany
   */
  export type JewelStockUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JewelStocks.
     */
    data: XOR<JewelStockUpdateManyMutationInput, JewelStockUncheckedUpdateManyInput>
    /**
     * Filter which JewelStocks to update
     */
    where?: JewelStockWhereInput
    /**
     * Limit how many JewelStocks to update.
     */
    limit?: number
  }

  /**
   * JewelStock upsert
   */
  export type JewelStockUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JewelStock
     */
    select?: JewelStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JewelStock
     */
    omit?: JewelStockOmit<ExtArgs> | null
    /**
     * The filter to search for the JewelStock to update in case it exists.
     */
    where: JewelStockWhereUniqueInput
    /**
     * In case the JewelStock found by the `where` argument doesn't exist, create a new JewelStock with this data.
     */
    create: XOR<JewelStockCreateInput, JewelStockUncheckedCreateInput>
    /**
     * In case the JewelStock was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JewelStockUpdateInput, JewelStockUncheckedUpdateInput>
  }

  /**
   * JewelStock delete
   */
  export type JewelStockDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JewelStock
     */
    select?: JewelStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JewelStock
     */
    omit?: JewelStockOmit<ExtArgs> | null
    /**
     * Filter which JewelStock to delete.
     */
    where: JewelStockWhereUniqueInput
  }

  /**
   * JewelStock deleteMany
   */
  export type JewelStockDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JewelStocks to delete
     */
    where?: JewelStockWhereInput
    /**
     * Limit how many JewelStocks to delete.
     */
    limit?: number
  }

  /**
   * JewelStock without action
   */
  export type JewelStockDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JewelStock
     */
    select?: JewelStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JewelStock
     */
    omit?: JewelStockOmit<ExtArgs> | null
  }


  /**
   * Model Transaction
   */

  export type AggregateTransaction = {
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  export type TransactionAvgAggregateOutputType = {
    id: number | null
    value: number | null
    goldRate: number | null
    purity: number | null
    touch: number | null
    customerId: number | null
  }

  export type TransactionSumAggregateOutputType = {
    id: number | null
    value: number | null
    goldRate: number | null
    purity: number | null
    touch: number | null
    customerId: number | null
  }

  export type TransactionMinAggregateOutputType = {
    id: number | null
    date: Date | null
    type: string | null
    value: number | null
    goldRate: number | null
    purity: number | null
    touch: number | null
    customerId: number | null
    createdAt: Date | null
  }

  export type TransactionMaxAggregateOutputType = {
    id: number | null
    date: Date | null
    type: string | null
    value: number | null
    goldRate: number | null
    purity: number | null
    touch: number | null
    customerId: number | null
    createdAt: Date | null
  }

  export type TransactionCountAggregateOutputType = {
    id: number
    date: number
    type: number
    value: number
    goldRate: number
    purity: number
    touch: number
    customerId: number
    createdAt: number
    _all: number
  }


  export type TransactionAvgAggregateInputType = {
    id?: true
    value?: true
    goldRate?: true
    purity?: true
    touch?: true
    customerId?: true
  }

  export type TransactionSumAggregateInputType = {
    id?: true
    value?: true
    goldRate?: true
    purity?: true
    touch?: true
    customerId?: true
  }

  export type TransactionMinAggregateInputType = {
    id?: true
    date?: true
    type?: true
    value?: true
    goldRate?: true
    purity?: true
    touch?: true
    customerId?: true
    createdAt?: true
  }

  export type TransactionMaxAggregateInputType = {
    id?: true
    date?: true
    type?: true
    value?: true
    goldRate?: true
    purity?: true
    touch?: true
    customerId?: true
    createdAt?: true
  }

  export type TransactionCountAggregateInputType = {
    id?: true
    date?: true
    type?: true
    value?: true
    goldRate?: true
    purity?: true
    touch?: true
    customerId?: true
    createdAt?: true
    _all?: true
  }

  export type TransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transaction to aggregate.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Transactions
    **/
    _count?: true | TransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionMaxAggregateInputType
  }

  export type GetTransactionAggregateType<T extends TransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransaction[P]>
      : GetScalarType<T[P], AggregateTransaction[P]>
  }




  export type TransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithAggregationInput | TransactionOrderByWithAggregationInput[]
    by: TransactionScalarFieldEnum[] | TransactionScalarFieldEnum
    having?: TransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionCountAggregateInputType | true
    _avg?: TransactionAvgAggregateInputType
    _sum?: TransactionSumAggregateInputType
    _min?: TransactionMinAggregateInputType
    _max?: TransactionMaxAggregateInputType
  }

  export type TransactionGroupByOutputType = {
    id: number
    date: Date
    type: string
    value: number
    goldRate: number | null
    purity: number
    touch: number | null
    customerId: number
    createdAt: Date
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  type GetTransactionGroupByPayload<T extends TransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionGroupByOutputType[P]>
        }
      >
    >


  export type TransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    type?: boolean
    value?: boolean
    goldRate?: boolean
    purity?: boolean
    touch?: boolean
    customerId?: boolean
    createdAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>



  export type TransactionSelectScalar = {
    id?: boolean
    date?: boolean
    type?: boolean
    value?: boolean
    goldRate?: boolean
    purity?: boolean
    touch?: boolean
    customerId?: boolean
    createdAt?: boolean
  }

  export type TransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "date" | "type" | "value" | "goldRate" | "purity" | "touch" | "customerId" | "createdAt", ExtArgs["result"]["transaction"]>
  export type TransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }

  export type $TransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Transaction"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      date: Date
      type: string
      value: number
      goldRate: number | null
      purity: number
      touch: number | null
      customerId: number
      createdAt: Date
    }, ExtArgs["result"]["transaction"]>
    composites: {}
  }

  type TransactionGetPayload<S extends boolean | null | undefined | TransactionDefaultArgs> = $Result.GetResult<Prisma.$TransactionPayload, S>

  type TransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransactionCountAggregateInputType | true
    }

  export interface TransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Transaction'], meta: { name: 'Transaction' } }
    /**
     * Find zero or one Transaction that matches the filter.
     * @param {TransactionFindUniqueArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransactionFindUniqueArgs>(args: SelectSubset<T, TransactionFindUniqueArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Transaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TransactionFindUniqueOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, TransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransactionFindFirstArgs>(args?: SelectSubset<T, TransactionFindFirstArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, TransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transactions
     * const transactions = await prisma.transaction.findMany()
     * 
     * // Get first 10 Transactions
     * const transactions = await prisma.transaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionWithIdOnly = await prisma.transaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransactionFindManyArgs>(args?: SelectSubset<T, TransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Transaction.
     * @param {TransactionCreateArgs} args - Arguments to create a Transaction.
     * @example
     * // Create one Transaction
     * const Transaction = await prisma.transaction.create({
     *   data: {
     *     // ... data to create a Transaction
     *   }
     * })
     * 
     */
    create<T extends TransactionCreateArgs>(args: SelectSubset<T, TransactionCreateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Transactions.
     * @param {TransactionCreateManyArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransactionCreateManyArgs>(args?: SelectSubset<T, TransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Transaction.
     * @param {TransactionDeleteArgs} args - Arguments to delete one Transaction.
     * @example
     * // Delete one Transaction
     * const Transaction = await prisma.transaction.delete({
     *   where: {
     *     // ... filter to delete one Transaction
     *   }
     * })
     * 
     */
    delete<T extends TransactionDeleteArgs>(args: SelectSubset<T, TransactionDeleteArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Transaction.
     * @param {TransactionUpdateArgs} args - Arguments to update one Transaction.
     * @example
     * // Update one Transaction
     * const transaction = await prisma.transaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransactionUpdateArgs>(args: SelectSubset<T, TransactionUpdateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Transactions.
     * @param {TransactionDeleteManyArgs} args - Arguments to filter Transactions to delete.
     * @example
     * // Delete a few Transactions
     * const { count } = await prisma.transaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransactionDeleteManyArgs>(args?: SelectSubset<T, TransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransactionUpdateManyArgs>(args: SelectSubset<T, TransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Transaction.
     * @param {TransactionUpsertArgs} args - Arguments to update or create a Transaction.
     * @example
     * // Update or create a Transaction
     * const transaction = await prisma.transaction.upsert({
     *   create: {
     *     // ... data to create a Transaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transaction we want to update
     *   }
     * })
     */
    upsert<T extends TransactionUpsertArgs>(args: SelectSubset<T, TransactionUpsertArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionCountArgs} args - Arguments to filter Transactions to count.
     * @example
     * // Count the number of Transactions
     * const count = await prisma.transaction.count({
     *   where: {
     *     // ... the filter for the Transactions we want to count
     *   }
     * })
    **/
    count<T extends TransactionCountArgs>(
      args?: Subset<T, TransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionAggregateArgs>(args: Subset<T, TransactionAggregateArgs>): Prisma.PrismaPromise<GetTransactionAggregateType<T>>

    /**
     * Group by Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionGroupByArgs['orderBy'] }
        : { orderBy?: TransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Transaction model
   */
  readonly fields: TransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Transaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Transaction model
   */
  interface TransactionFieldRefs {
    readonly id: FieldRef<"Transaction", 'Int'>
    readonly date: FieldRef<"Transaction", 'DateTime'>
    readonly type: FieldRef<"Transaction", 'String'>
    readonly value: FieldRef<"Transaction", 'Float'>
    readonly goldRate: FieldRef<"Transaction", 'Float'>
    readonly purity: FieldRef<"Transaction", 'Float'>
    readonly touch: FieldRef<"Transaction", 'Float'>
    readonly customerId: FieldRef<"Transaction", 'Int'>
    readonly createdAt: FieldRef<"Transaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Transaction findUnique
   */
  export type TransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findUniqueOrThrow
   */
  export type TransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findFirst
   */
  export type TransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findFirstOrThrow
   */
  export type TransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findMany
   */
  export type TransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transactions to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction create
   */
  export type TransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a Transaction.
     */
    data: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
  }

  /**
   * Transaction createMany
   */
  export type TransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Transaction update
   */
  export type TransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a Transaction.
     */
    data: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
    /**
     * Choose, which Transaction to update.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction updateMany
   */
  export type TransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to update.
     */
    limit?: number
  }

  /**
   * Transaction upsert
   */
  export type TransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the Transaction to update in case it exists.
     */
    where: TransactionWhereUniqueInput
    /**
     * In case the Transaction found by the `where` argument doesn't exist, create a new Transaction with this data.
     */
    create: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
    /**
     * In case the Transaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
  }

  /**
   * Transaction delete
   */
  export type TransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter which Transaction to delete.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction deleteMany
   */
  export type TransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transactions to delete
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to delete.
     */
    limit?: number
  }

  /**
   * Transaction without action
   */
  export type TransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
  }


  /**
   * Model Entry
   */

  export type AggregateEntry = {
    _count: EntryCountAggregateOutputType | null
    _avg: EntryAvgAggregateOutputType | null
    _sum: EntrySumAggregateOutputType | null
    _min: EntryMinAggregateOutputType | null
    _max: EntryMaxAggregateOutputType | null
  }

  export type EntryAvgAggregateOutputType = {
    id: number | null
    cashAmount: number | null
    goldValue: number | null
    touch: number | null
    purity: number | null
    goldRate: number | null
  }

  export type EntrySumAggregateOutputType = {
    id: number | null
    cashAmount: number | null
    goldValue: number | null
    touch: number | null
    purity: number | null
    goldRate: number | null
  }

  export type EntryMinAggregateOutputType = {
    id: number | null
    date: Date | null
    type: string | null
    cashAmount: number | null
    goldValue: number | null
    touch: number | null
    purity: number | null
    goldRate: number | null
    createdAt: Date | null
  }

  export type EntryMaxAggregateOutputType = {
    id: number | null
    date: Date | null
    type: string | null
    cashAmount: number | null
    goldValue: number | null
    touch: number | null
    purity: number | null
    goldRate: number | null
    createdAt: Date | null
  }

  export type EntryCountAggregateOutputType = {
    id: number
    date: number
    type: number
    cashAmount: number
    goldValue: number
    touch: number
    purity: number
    goldRate: number
    createdAt: number
    _all: number
  }


  export type EntryAvgAggregateInputType = {
    id?: true
    cashAmount?: true
    goldValue?: true
    touch?: true
    purity?: true
    goldRate?: true
  }

  export type EntrySumAggregateInputType = {
    id?: true
    cashAmount?: true
    goldValue?: true
    touch?: true
    purity?: true
    goldRate?: true
  }

  export type EntryMinAggregateInputType = {
    id?: true
    date?: true
    type?: true
    cashAmount?: true
    goldValue?: true
    touch?: true
    purity?: true
    goldRate?: true
    createdAt?: true
  }

  export type EntryMaxAggregateInputType = {
    id?: true
    date?: true
    type?: true
    cashAmount?: true
    goldValue?: true
    touch?: true
    purity?: true
    goldRate?: true
    createdAt?: true
  }

  export type EntryCountAggregateInputType = {
    id?: true
    date?: true
    type?: true
    cashAmount?: true
    goldValue?: true
    touch?: true
    purity?: true
    goldRate?: true
    createdAt?: true
    _all?: true
  }

  export type EntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Entry to aggregate.
     */
    where?: EntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Entries to fetch.
     */
    orderBy?: EntryOrderByWithRelationInput | EntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Entries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Entries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Entries
    **/
    _count?: true | EntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EntryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EntrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EntryMaxAggregateInputType
  }

  export type GetEntryAggregateType<T extends EntryAggregateArgs> = {
        [P in keyof T & keyof AggregateEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEntry[P]>
      : GetScalarType<T[P], AggregateEntry[P]>
  }




  export type EntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EntryWhereInput
    orderBy?: EntryOrderByWithAggregationInput | EntryOrderByWithAggregationInput[]
    by: EntryScalarFieldEnum[] | EntryScalarFieldEnum
    having?: EntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EntryCountAggregateInputType | true
    _avg?: EntryAvgAggregateInputType
    _sum?: EntrySumAggregateInputType
    _min?: EntryMinAggregateInputType
    _max?: EntryMaxAggregateInputType
  }

  export type EntryGroupByOutputType = {
    id: number
    date: Date
    type: string
    cashAmount: number | null
    goldValue: number | null
    touch: number | null
    purity: number | null
    goldRate: number | null
    createdAt: Date
    _count: EntryCountAggregateOutputType | null
    _avg: EntryAvgAggregateOutputType | null
    _sum: EntrySumAggregateOutputType | null
    _min: EntryMinAggregateOutputType | null
    _max: EntryMaxAggregateOutputType | null
  }

  type GetEntryGroupByPayload<T extends EntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EntryGroupByOutputType[P]>
            : GetScalarType<T[P], EntryGroupByOutputType[P]>
        }
      >
    >


  export type EntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    type?: boolean
    cashAmount?: boolean
    goldValue?: boolean
    touch?: boolean
    purity?: boolean
    goldRate?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["entry"]>



  export type EntrySelectScalar = {
    id?: boolean
    date?: boolean
    type?: boolean
    cashAmount?: boolean
    goldValue?: boolean
    touch?: boolean
    purity?: boolean
    goldRate?: boolean
    createdAt?: boolean
  }

  export type EntryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "date" | "type" | "cashAmount" | "goldValue" | "touch" | "purity" | "goldRate" | "createdAt", ExtArgs["result"]["entry"]>

  export type $EntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Entry"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      date: Date
      type: string
      cashAmount: number | null
      goldValue: number | null
      touch: number | null
      purity: number | null
      goldRate: number | null
      createdAt: Date
    }, ExtArgs["result"]["entry"]>
    composites: {}
  }

  type EntryGetPayload<S extends boolean | null | undefined | EntryDefaultArgs> = $Result.GetResult<Prisma.$EntryPayload, S>

  type EntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EntryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EntryCountAggregateInputType | true
    }

  export interface EntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Entry'], meta: { name: 'Entry' } }
    /**
     * Find zero or one Entry that matches the filter.
     * @param {EntryFindUniqueArgs} args - Arguments to find a Entry
     * @example
     * // Get one Entry
     * const entry = await prisma.entry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EntryFindUniqueArgs>(args: SelectSubset<T, EntryFindUniqueArgs<ExtArgs>>): Prisma__EntryClient<$Result.GetResult<Prisma.$EntryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Entry that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EntryFindUniqueOrThrowArgs} args - Arguments to find a Entry
     * @example
     * // Get one Entry
     * const entry = await prisma.entry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EntryFindUniqueOrThrowArgs>(args: SelectSubset<T, EntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EntryClient<$Result.GetResult<Prisma.$EntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Entry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntryFindFirstArgs} args - Arguments to find a Entry
     * @example
     * // Get one Entry
     * const entry = await prisma.entry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EntryFindFirstArgs>(args?: SelectSubset<T, EntryFindFirstArgs<ExtArgs>>): Prisma__EntryClient<$Result.GetResult<Prisma.$EntryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Entry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntryFindFirstOrThrowArgs} args - Arguments to find a Entry
     * @example
     * // Get one Entry
     * const entry = await prisma.entry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EntryFindFirstOrThrowArgs>(args?: SelectSubset<T, EntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__EntryClient<$Result.GetResult<Prisma.$EntryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Entries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Entries
     * const entries = await prisma.entry.findMany()
     * 
     * // Get first 10 Entries
     * const entries = await prisma.entry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const entryWithIdOnly = await prisma.entry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EntryFindManyArgs>(args?: SelectSubset<T, EntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Entry.
     * @param {EntryCreateArgs} args - Arguments to create a Entry.
     * @example
     * // Create one Entry
     * const Entry = await prisma.entry.create({
     *   data: {
     *     // ... data to create a Entry
     *   }
     * })
     * 
     */
    create<T extends EntryCreateArgs>(args: SelectSubset<T, EntryCreateArgs<ExtArgs>>): Prisma__EntryClient<$Result.GetResult<Prisma.$EntryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Entries.
     * @param {EntryCreateManyArgs} args - Arguments to create many Entries.
     * @example
     * // Create many Entries
     * const entry = await prisma.entry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EntryCreateManyArgs>(args?: SelectSubset<T, EntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Entry.
     * @param {EntryDeleteArgs} args - Arguments to delete one Entry.
     * @example
     * // Delete one Entry
     * const Entry = await prisma.entry.delete({
     *   where: {
     *     // ... filter to delete one Entry
     *   }
     * })
     * 
     */
    delete<T extends EntryDeleteArgs>(args: SelectSubset<T, EntryDeleteArgs<ExtArgs>>): Prisma__EntryClient<$Result.GetResult<Prisma.$EntryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Entry.
     * @param {EntryUpdateArgs} args - Arguments to update one Entry.
     * @example
     * // Update one Entry
     * const entry = await prisma.entry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EntryUpdateArgs>(args: SelectSubset<T, EntryUpdateArgs<ExtArgs>>): Prisma__EntryClient<$Result.GetResult<Prisma.$EntryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Entries.
     * @param {EntryDeleteManyArgs} args - Arguments to filter Entries to delete.
     * @example
     * // Delete a few Entries
     * const { count } = await prisma.entry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EntryDeleteManyArgs>(args?: SelectSubset<T, EntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Entries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Entries
     * const entry = await prisma.entry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EntryUpdateManyArgs>(args: SelectSubset<T, EntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Entry.
     * @param {EntryUpsertArgs} args - Arguments to update or create a Entry.
     * @example
     * // Update or create a Entry
     * const entry = await prisma.entry.upsert({
     *   create: {
     *     // ... data to create a Entry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Entry we want to update
     *   }
     * })
     */
    upsert<T extends EntryUpsertArgs>(args: SelectSubset<T, EntryUpsertArgs<ExtArgs>>): Prisma__EntryClient<$Result.GetResult<Prisma.$EntryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Entries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntryCountArgs} args - Arguments to filter Entries to count.
     * @example
     * // Count the number of Entries
     * const count = await prisma.entry.count({
     *   where: {
     *     // ... the filter for the Entries we want to count
     *   }
     * })
    **/
    count<T extends EntryCountArgs>(
      args?: Subset<T, EntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Entry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EntryAggregateArgs>(args: Subset<T, EntryAggregateArgs>): Prisma.PrismaPromise<GetEntryAggregateType<T>>

    /**
     * Group by Entry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EntryGroupByArgs['orderBy'] }
        : { orderBy?: EntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Entry model
   */
  readonly fields: EntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Entry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Entry model
   */
  interface EntryFieldRefs {
    readonly id: FieldRef<"Entry", 'Int'>
    readonly date: FieldRef<"Entry", 'DateTime'>
    readonly type: FieldRef<"Entry", 'String'>
    readonly cashAmount: FieldRef<"Entry", 'Float'>
    readonly goldValue: FieldRef<"Entry", 'Float'>
    readonly touch: FieldRef<"Entry", 'Float'>
    readonly purity: FieldRef<"Entry", 'Float'>
    readonly goldRate: FieldRef<"Entry", 'Float'>
    readonly createdAt: FieldRef<"Entry", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Entry findUnique
   */
  export type EntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entry
     */
    select?: EntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Entry
     */
    omit?: EntryOmit<ExtArgs> | null
    /**
     * Filter, which Entry to fetch.
     */
    where: EntryWhereUniqueInput
  }

  /**
   * Entry findUniqueOrThrow
   */
  export type EntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entry
     */
    select?: EntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Entry
     */
    omit?: EntryOmit<ExtArgs> | null
    /**
     * Filter, which Entry to fetch.
     */
    where: EntryWhereUniqueInput
  }

  /**
   * Entry findFirst
   */
  export type EntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entry
     */
    select?: EntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Entry
     */
    omit?: EntryOmit<ExtArgs> | null
    /**
     * Filter, which Entry to fetch.
     */
    where?: EntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Entries to fetch.
     */
    orderBy?: EntryOrderByWithRelationInput | EntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Entries.
     */
    cursor?: EntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Entries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Entries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Entries.
     */
    distinct?: EntryScalarFieldEnum | EntryScalarFieldEnum[]
  }

  /**
   * Entry findFirstOrThrow
   */
  export type EntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entry
     */
    select?: EntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Entry
     */
    omit?: EntryOmit<ExtArgs> | null
    /**
     * Filter, which Entry to fetch.
     */
    where?: EntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Entries to fetch.
     */
    orderBy?: EntryOrderByWithRelationInput | EntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Entries.
     */
    cursor?: EntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Entries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Entries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Entries.
     */
    distinct?: EntryScalarFieldEnum | EntryScalarFieldEnum[]
  }

  /**
   * Entry findMany
   */
  export type EntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entry
     */
    select?: EntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Entry
     */
    omit?: EntryOmit<ExtArgs> | null
    /**
     * Filter, which Entries to fetch.
     */
    where?: EntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Entries to fetch.
     */
    orderBy?: EntryOrderByWithRelationInput | EntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Entries.
     */
    cursor?: EntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Entries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Entries.
     */
    skip?: number
    distinct?: EntryScalarFieldEnum | EntryScalarFieldEnum[]
  }

  /**
   * Entry create
   */
  export type EntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entry
     */
    select?: EntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Entry
     */
    omit?: EntryOmit<ExtArgs> | null
    /**
     * The data needed to create a Entry.
     */
    data: XOR<EntryCreateInput, EntryUncheckedCreateInput>
  }

  /**
   * Entry createMany
   */
  export type EntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Entries.
     */
    data: EntryCreateManyInput | EntryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Entry update
   */
  export type EntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entry
     */
    select?: EntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Entry
     */
    omit?: EntryOmit<ExtArgs> | null
    /**
     * The data needed to update a Entry.
     */
    data: XOR<EntryUpdateInput, EntryUncheckedUpdateInput>
    /**
     * Choose, which Entry to update.
     */
    where: EntryWhereUniqueInput
  }

  /**
   * Entry updateMany
   */
  export type EntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Entries.
     */
    data: XOR<EntryUpdateManyMutationInput, EntryUncheckedUpdateManyInput>
    /**
     * Filter which Entries to update
     */
    where?: EntryWhereInput
    /**
     * Limit how many Entries to update.
     */
    limit?: number
  }

  /**
   * Entry upsert
   */
  export type EntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entry
     */
    select?: EntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Entry
     */
    omit?: EntryOmit<ExtArgs> | null
    /**
     * The filter to search for the Entry to update in case it exists.
     */
    where: EntryWhereUniqueInput
    /**
     * In case the Entry found by the `where` argument doesn't exist, create a new Entry with this data.
     */
    create: XOR<EntryCreateInput, EntryUncheckedCreateInput>
    /**
     * In case the Entry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EntryUpdateInput, EntryUncheckedUpdateInput>
  }

  /**
   * Entry delete
   */
  export type EntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entry
     */
    select?: EntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Entry
     */
    omit?: EntryOmit<ExtArgs> | null
    /**
     * Filter which Entry to delete.
     */
    where: EntryWhereUniqueInput
  }

  /**
   * Entry deleteMany
   */
  export type EntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Entries to delete
     */
    where?: EntryWhereInput
    /**
     * Limit how many Entries to delete.
     */
    limit?: number
  }

  /**
   * Entry without action
   */
  export type EntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entry
     */
    select?: EntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Entry
     */
    omit?: EntryOmit<ExtArgs> | null
  }


  /**
   * Model customer_order
   */

  export type AggregateCustomer_order = {
    _count: Customer_orderCountAggregateOutputType | null
    _avg: Customer_orderAvgAggregateOutputType | null
    _sum: Customer_orderSumAggregateOutputType | null
    _min: Customer_orderMinAggregateOutputType | null
    _max: Customer_orderMaxAggregateOutputType | null
  }

  export type Customer_orderAvgAggregateOutputType = {
    id: number | null
    customer_id: number | null
    order_group_id: number | null
    weight: number | null
  }

  export type Customer_orderSumAggregateOutputType = {
    id: number | null
    customer_id: number | null
    order_group_id: number | null
    weight: number | null
  }

  export type Customer_orderMinAggregateOutputType = {
    id: number | null
    customer_id: number | null
    order_group_id: number | null
    item_name: string | null
    description: string | null
    weight: number | null
    image: string | null
    due_date: Date | null
    status: string | null
    worker_name: string | null
    created_at: Date | null
    updatedAt: Date | null
  }

  export type Customer_orderMaxAggregateOutputType = {
    id: number | null
    customer_id: number | null
    order_group_id: number | null
    item_name: string | null
    description: string | null
    weight: number | null
    image: string | null
    due_date: Date | null
    status: string | null
    worker_name: string | null
    created_at: Date | null
    updatedAt: Date | null
  }

  export type Customer_orderCountAggregateOutputType = {
    id: number
    customer_id: number
    order_group_id: number
    item_name: number
    description: number
    weight: number
    image: number
    due_date: number
    status: number
    worker_name: number
    created_at: number
    updatedAt: number
    _all: number
  }


  export type Customer_orderAvgAggregateInputType = {
    id?: true
    customer_id?: true
    order_group_id?: true
    weight?: true
  }

  export type Customer_orderSumAggregateInputType = {
    id?: true
    customer_id?: true
    order_group_id?: true
    weight?: true
  }

  export type Customer_orderMinAggregateInputType = {
    id?: true
    customer_id?: true
    order_group_id?: true
    item_name?: true
    description?: true
    weight?: true
    image?: true
    due_date?: true
    status?: true
    worker_name?: true
    created_at?: true
    updatedAt?: true
  }

  export type Customer_orderMaxAggregateInputType = {
    id?: true
    customer_id?: true
    order_group_id?: true
    item_name?: true
    description?: true
    weight?: true
    image?: true
    due_date?: true
    status?: true
    worker_name?: true
    created_at?: true
    updatedAt?: true
  }

  export type Customer_orderCountAggregateInputType = {
    id?: true
    customer_id?: true
    order_group_id?: true
    item_name?: true
    description?: true
    weight?: true
    image?: true
    due_date?: true
    status?: true
    worker_name?: true
    created_at?: true
    updatedAt?: true
    _all?: true
  }

  export type Customer_orderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which customer_order to aggregate.
     */
    where?: customer_orderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customer_orders to fetch.
     */
    orderBy?: customer_orderOrderByWithRelationInput | customer_orderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: customer_orderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customer_orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customer_orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned customer_orders
    **/
    _count?: true | Customer_orderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Customer_orderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Customer_orderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Customer_orderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Customer_orderMaxAggregateInputType
  }

  export type GetCustomer_orderAggregateType<T extends Customer_orderAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomer_order]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomer_order[P]>
      : GetScalarType<T[P], AggregateCustomer_order[P]>
  }




  export type customer_orderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: customer_orderWhereInput
    orderBy?: customer_orderOrderByWithAggregationInput | customer_orderOrderByWithAggregationInput[]
    by: Customer_orderScalarFieldEnum[] | Customer_orderScalarFieldEnum
    having?: customer_orderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Customer_orderCountAggregateInputType | true
    _avg?: Customer_orderAvgAggregateInputType
    _sum?: Customer_orderSumAggregateInputType
    _min?: Customer_orderMinAggregateInputType
    _max?: Customer_orderMaxAggregateInputType
  }

  export type Customer_orderGroupByOutputType = {
    id: number
    customer_id: number
    order_group_id: number
    item_name: string
    description: string
    weight: number
    image: string | null
    due_date: Date | null
    status: string
    worker_name: string | null
    created_at: Date
    updatedAt: Date
    _count: Customer_orderCountAggregateOutputType | null
    _avg: Customer_orderAvgAggregateOutputType | null
    _sum: Customer_orderSumAggregateOutputType | null
    _min: Customer_orderMinAggregateOutputType | null
    _max: Customer_orderMaxAggregateOutputType | null
  }

  type GetCustomer_orderGroupByPayload<T extends customer_orderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Customer_orderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Customer_orderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Customer_orderGroupByOutputType[P]>
            : GetScalarType<T[P], Customer_orderGroupByOutputType[P]>
        }
      >
    >


  export type customer_orderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customer_id?: boolean
    order_group_id?: boolean
    item_name?: boolean
    description?: boolean
    weight?: boolean
    image?: boolean
    due_date?: boolean
    status?: boolean
    worker_name?: boolean
    created_at?: boolean
    updatedAt?: boolean
    customers?: boolean | CustomerDefaultArgs<ExtArgs>
    productImages?: boolean | customer_order$productImagesArgs<ExtArgs>
    _count?: boolean | Customer_orderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer_order"]>



  export type customer_orderSelectScalar = {
    id?: boolean
    customer_id?: boolean
    order_group_id?: boolean
    item_name?: boolean
    description?: boolean
    weight?: boolean
    image?: boolean
    due_date?: boolean
    status?: boolean
    worker_name?: boolean
    created_at?: boolean
    updatedAt?: boolean
  }

  export type customer_orderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "customer_id" | "order_group_id" | "item_name" | "description" | "weight" | "image" | "due_date" | "status" | "worker_name" | "created_at" | "updatedAt", ExtArgs["result"]["customer_order"]>
  export type customer_orderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customers?: boolean | CustomerDefaultArgs<ExtArgs>
    productImages?: boolean | customer_order$productImagesArgs<ExtArgs>
    _count?: boolean | Customer_orderCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $customer_orderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "customer_order"
    objects: {
      customers: Prisma.$CustomerPayload<ExtArgs>
      productImages: Prisma.$product_multiple_imagesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      customer_id: number
      order_group_id: number
      item_name: string
      description: string
      weight: number
      image: string | null
      due_date: Date | null
      status: string
      worker_name: string | null
      created_at: Date
      updatedAt: Date
    }, ExtArgs["result"]["customer_order"]>
    composites: {}
  }

  type customer_orderGetPayload<S extends boolean | null | undefined | customer_orderDefaultArgs> = $Result.GetResult<Prisma.$customer_orderPayload, S>

  type customer_orderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<customer_orderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Customer_orderCountAggregateInputType | true
    }

  export interface customer_orderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['customer_order'], meta: { name: 'customer_order' } }
    /**
     * Find zero or one Customer_order that matches the filter.
     * @param {customer_orderFindUniqueArgs} args - Arguments to find a Customer_order
     * @example
     * // Get one Customer_order
     * const customer_order = await prisma.customer_order.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends customer_orderFindUniqueArgs>(args: SelectSubset<T, customer_orderFindUniqueArgs<ExtArgs>>): Prisma__customer_orderClient<$Result.GetResult<Prisma.$customer_orderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Customer_order that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {customer_orderFindUniqueOrThrowArgs} args - Arguments to find a Customer_order
     * @example
     * // Get one Customer_order
     * const customer_order = await prisma.customer_order.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends customer_orderFindUniqueOrThrowArgs>(args: SelectSubset<T, customer_orderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__customer_orderClient<$Result.GetResult<Prisma.$customer_orderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer_order that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customer_orderFindFirstArgs} args - Arguments to find a Customer_order
     * @example
     * // Get one Customer_order
     * const customer_order = await prisma.customer_order.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends customer_orderFindFirstArgs>(args?: SelectSubset<T, customer_orderFindFirstArgs<ExtArgs>>): Prisma__customer_orderClient<$Result.GetResult<Prisma.$customer_orderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer_order that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customer_orderFindFirstOrThrowArgs} args - Arguments to find a Customer_order
     * @example
     * // Get one Customer_order
     * const customer_order = await prisma.customer_order.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends customer_orderFindFirstOrThrowArgs>(args?: SelectSubset<T, customer_orderFindFirstOrThrowArgs<ExtArgs>>): Prisma__customer_orderClient<$Result.GetResult<Prisma.$customer_orderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Customer_orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customer_orderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customer_orders
     * const customer_orders = await prisma.customer_order.findMany()
     * 
     * // Get first 10 Customer_orders
     * const customer_orders = await prisma.customer_order.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customer_orderWithIdOnly = await prisma.customer_order.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends customer_orderFindManyArgs>(args?: SelectSubset<T, customer_orderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$customer_orderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Customer_order.
     * @param {customer_orderCreateArgs} args - Arguments to create a Customer_order.
     * @example
     * // Create one Customer_order
     * const Customer_order = await prisma.customer_order.create({
     *   data: {
     *     // ... data to create a Customer_order
     *   }
     * })
     * 
     */
    create<T extends customer_orderCreateArgs>(args: SelectSubset<T, customer_orderCreateArgs<ExtArgs>>): Prisma__customer_orderClient<$Result.GetResult<Prisma.$customer_orderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Customer_orders.
     * @param {customer_orderCreateManyArgs} args - Arguments to create many Customer_orders.
     * @example
     * // Create many Customer_orders
     * const customer_order = await prisma.customer_order.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends customer_orderCreateManyArgs>(args?: SelectSubset<T, customer_orderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Customer_order.
     * @param {customer_orderDeleteArgs} args - Arguments to delete one Customer_order.
     * @example
     * // Delete one Customer_order
     * const Customer_order = await prisma.customer_order.delete({
     *   where: {
     *     // ... filter to delete one Customer_order
     *   }
     * })
     * 
     */
    delete<T extends customer_orderDeleteArgs>(args: SelectSubset<T, customer_orderDeleteArgs<ExtArgs>>): Prisma__customer_orderClient<$Result.GetResult<Prisma.$customer_orderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Customer_order.
     * @param {customer_orderUpdateArgs} args - Arguments to update one Customer_order.
     * @example
     * // Update one Customer_order
     * const customer_order = await prisma.customer_order.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends customer_orderUpdateArgs>(args: SelectSubset<T, customer_orderUpdateArgs<ExtArgs>>): Prisma__customer_orderClient<$Result.GetResult<Prisma.$customer_orderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Customer_orders.
     * @param {customer_orderDeleteManyArgs} args - Arguments to filter Customer_orders to delete.
     * @example
     * // Delete a few Customer_orders
     * const { count } = await prisma.customer_order.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends customer_orderDeleteManyArgs>(args?: SelectSubset<T, customer_orderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customer_orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customer_orderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customer_orders
     * const customer_order = await prisma.customer_order.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends customer_orderUpdateManyArgs>(args: SelectSubset<T, customer_orderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Customer_order.
     * @param {customer_orderUpsertArgs} args - Arguments to update or create a Customer_order.
     * @example
     * // Update or create a Customer_order
     * const customer_order = await prisma.customer_order.upsert({
     *   create: {
     *     // ... data to create a Customer_order
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customer_order we want to update
     *   }
     * })
     */
    upsert<T extends customer_orderUpsertArgs>(args: SelectSubset<T, customer_orderUpsertArgs<ExtArgs>>): Prisma__customer_orderClient<$Result.GetResult<Prisma.$customer_orderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Customer_orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customer_orderCountArgs} args - Arguments to filter Customer_orders to count.
     * @example
     * // Count the number of Customer_orders
     * const count = await prisma.customer_order.count({
     *   where: {
     *     // ... the filter for the Customer_orders we want to count
     *   }
     * })
    **/
    count<T extends customer_orderCountArgs>(
      args?: Subset<T, customer_orderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Customer_orderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customer_order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Customer_orderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Customer_orderAggregateArgs>(args: Subset<T, Customer_orderAggregateArgs>): Prisma.PrismaPromise<GetCustomer_orderAggregateType<T>>

    /**
     * Group by Customer_order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customer_orderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends customer_orderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: customer_orderGroupByArgs['orderBy'] }
        : { orderBy?: customer_orderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, customer_orderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomer_orderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the customer_order model
   */
  readonly fields: customer_orderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for customer_order.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__customer_orderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customers<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    productImages<T extends customer_order$productImagesArgs<ExtArgs> = {}>(args?: Subset<T, customer_order$productImagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$product_multiple_imagesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the customer_order model
   */
  interface customer_orderFieldRefs {
    readonly id: FieldRef<"customer_order", 'Int'>
    readonly customer_id: FieldRef<"customer_order", 'Int'>
    readonly order_group_id: FieldRef<"customer_order", 'Int'>
    readonly item_name: FieldRef<"customer_order", 'String'>
    readonly description: FieldRef<"customer_order", 'String'>
    readonly weight: FieldRef<"customer_order", 'Float'>
    readonly image: FieldRef<"customer_order", 'String'>
    readonly due_date: FieldRef<"customer_order", 'DateTime'>
    readonly status: FieldRef<"customer_order", 'String'>
    readonly worker_name: FieldRef<"customer_order", 'String'>
    readonly created_at: FieldRef<"customer_order", 'DateTime'>
    readonly updatedAt: FieldRef<"customer_order", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * customer_order findUnique
   */
  export type customer_orderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer_order
     */
    select?: customer_orderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer_order
     */
    omit?: customer_orderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customer_orderInclude<ExtArgs> | null
    /**
     * Filter, which customer_order to fetch.
     */
    where: customer_orderWhereUniqueInput
  }

  /**
   * customer_order findUniqueOrThrow
   */
  export type customer_orderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer_order
     */
    select?: customer_orderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer_order
     */
    omit?: customer_orderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customer_orderInclude<ExtArgs> | null
    /**
     * Filter, which customer_order to fetch.
     */
    where: customer_orderWhereUniqueInput
  }

  /**
   * customer_order findFirst
   */
  export type customer_orderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer_order
     */
    select?: customer_orderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer_order
     */
    omit?: customer_orderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customer_orderInclude<ExtArgs> | null
    /**
     * Filter, which customer_order to fetch.
     */
    where?: customer_orderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customer_orders to fetch.
     */
    orderBy?: customer_orderOrderByWithRelationInput | customer_orderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for customer_orders.
     */
    cursor?: customer_orderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customer_orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customer_orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of customer_orders.
     */
    distinct?: Customer_orderScalarFieldEnum | Customer_orderScalarFieldEnum[]
  }

  /**
   * customer_order findFirstOrThrow
   */
  export type customer_orderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer_order
     */
    select?: customer_orderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer_order
     */
    omit?: customer_orderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customer_orderInclude<ExtArgs> | null
    /**
     * Filter, which customer_order to fetch.
     */
    where?: customer_orderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customer_orders to fetch.
     */
    orderBy?: customer_orderOrderByWithRelationInput | customer_orderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for customer_orders.
     */
    cursor?: customer_orderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customer_orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customer_orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of customer_orders.
     */
    distinct?: Customer_orderScalarFieldEnum | Customer_orderScalarFieldEnum[]
  }

  /**
   * customer_order findMany
   */
  export type customer_orderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer_order
     */
    select?: customer_orderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer_order
     */
    omit?: customer_orderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customer_orderInclude<ExtArgs> | null
    /**
     * Filter, which customer_orders to fetch.
     */
    where?: customer_orderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customer_orders to fetch.
     */
    orderBy?: customer_orderOrderByWithRelationInput | customer_orderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing customer_orders.
     */
    cursor?: customer_orderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customer_orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customer_orders.
     */
    skip?: number
    distinct?: Customer_orderScalarFieldEnum | Customer_orderScalarFieldEnum[]
  }

  /**
   * customer_order create
   */
  export type customer_orderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer_order
     */
    select?: customer_orderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer_order
     */
    omit?: customer_orderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customer_orderInclude<ExtArgs> | null
    /**
     * The data needed to create a customer_order.
     */
    data: XOR<customer_orderCreateInput, customer_orderUncheckedCreateInput>
  }

  /**
   * customer_order createMany
   */
  export type customer_orderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many customer_orders.
     */
    data: customer_orderCreateManyInput | customer_orderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * customer_order update
   */
  export type customer_orderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer_order
     */
    select?: customer_orderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer_order
     */
    omit?: customer_orderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customer_orderInclude<ExtArgs> | null
    /**
     * The data needed to update a customer_order.
     */
    data: XOR<customer_orderUpdateInput, customer_orderUncheckedUpdateInput>
    /**
     * Choose, which customer_order to update.
     */
    where: customer_orderWhereUniqueInput
  }

  /**
   * customer_order updateMany
   */
  export type customer_orderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update customer_orders.
     */
    data: XOR<customer_orderUpdateManyMutationInput, customer_orderUncheckedUpdateManyInput>
    /**
     * Filter which customer_orders to update
     */
    where?: customer_orderWhereInput
    /**
     * Limit how many customer_orders to update.
     */
    limit?: number
  }

  /**
   * customer_order upsert
   */
  export type customer_orderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer_order
     */
    select?: customer_orderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer_order
     */
    omit?: customer_orderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customer_orderInclude<ExtArgs> | null
    /**
     * The filter to search for the customer_order to update in case it exists.
     */
    where: customer_orderWhereUniqueInput
    /**
     * In case the customer_order found by the `where` argument doesn't exist, create a new customer_order with this data.
     */
    create: XOR<customer_orderCreateInput, customer_orderUncheckedCreateInput>
    /**
     * In case the customer_order was found with the provided `where` argument, update it with this data.
     */
    update: XOR<customer_orderUpdateInput, customer_orderUncheckedUpdateInput>
  }

  /**
   * customer_order delete
   */
  export type customer_orderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer_order
     */
    select?: customer_orderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer_order
     */
    omit?: customer_orderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customer_orderInclude<ExtArgs> | null
    /**
     * Filter which customer_order to delete.
     */
    where: customer_orderWhereUniqueInput
  }

  /**
   * customer_order deleteMany
   */
  export type customer_orderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which customer_orders to delete
     */
    where?: customer_orderWhereInput
    /**
     * Limit how many customer_orders to delete.
     */
    limit?: number
  }

  /**
   * customer_order.productImages
   */
  export type customer_order$productImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_multiple_images
     */
    select?: product_multiple_imagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the product_multiple_images
     */
    omit?: product_multiple_imagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: product_multiple_imagesInclude<ExtArgs> | null
    where?: product_multiple_imagesWhereInput
    orderBy?: product_multiple_imagesOrderByWithRelationInput | product_multiple_imagesOrderByWithRelationInput[]
    cursor?: product_multiple_imagesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Product_multiple_imagesScalarFieldEnum | Product_multiple_imagesScalarFieldEnum[]
  }

  /**
   * customer_order without action
   */
  export type customer_orderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer_order
     */
    select?: customer_orderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer_order
     */
    omit?: customer_orderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customer_orderInclude<ExtArgs> | null
  }


  /**
   * Model product_multiple_images
   */

  export type AggregateProduct_multiple_images = {
    _count: Product_multiple_imagesCountAggregateOutputType | null
    _avg: Product_multiple_imagesAvgAggregateOutputType | null
    _sum: Product_multiple_imagesSumAggregateOutputType | null
    _min: Product_multiple_imagesMinAggregateOutputType | null
    _max: Product_multiple_imagesMaxAggregateOutputType | null
  }

  export type Product_multiple_imagesAvgAggregateOutputType = {
    id: number | null
    customer_order_id: number | null
  }

  export type Product_multiple_imagesSumAggregateOutputType = {
    id: number | null
    customer_order_id: number | null
  }

  export type Product_multiple_imagesMinAggregateOutputType = {
    id: number | null
    customer_order_id: number | null
    filename: string | null
  }

  export type Product_multiple_imagesMaxAggregateOutputType = {
    id: number | null
    customer_order_id: number | null
    filename: string | null
  }

  export type Product_multiple_imagesCountAggregateOutputType = {
    id: number
    customer_order_id: number
    filename: number
    _all: number
  }


  export type Product_multiple_imagesAvgAggregateInputType = {
    id?: true
    customer_order_id?: true
  }

  export type Product_multiple_imagesSumAggregateInputType = {
    id?: true
    customer_order_id?: true
  }

  export type Product_multiple_imagesMinAggregateInputType = {
    id?: true
    customer_order_id?: true
    filename?: true
  }

  export type Product_multiple_imagesMaxAggregateInputType = {
    id?: true
    customer_order_id?: true
    filename?: true
  }

  export type Product_multiple_imagesCountAggregateInputType = {
    id?: true
    customer_order_id?: true
    filename?: true
    _all?: true
  }

  export type Product_multiple_imagesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which product_multiple_images to aggregate.
     */
    where?: product_multiple_imagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of product_multiple_images to fetch.
     */
    orderBy?: product_multiple_imagesOrderByWithRelationInput | product_multiple_imagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: product_multiple_imagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` product_multiple_images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` product_multiple_images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned product_multiple_images
    **/
    _count?: true | Product_multiple_imagesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Product_multiple_imagesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Product_multiple_imagesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Product_multiple_imagesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Product_multiple_imagesMaxAggregateInputType
  }

  export type GetProduct_multiple_imagesAggregateType<T extends Product_multiple_imagesAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct_multiple_images]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct_multiple_images[P]>
      : GetScalarType<T[P], AggregateProduct_multiple_images[P]>
  }




  export type product_multiple_imagesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: product_multiple_imagesWhereInput
    orderBy?: product_multiple_imagesOrderByWithAggregationInput | product_multiple_imagesOrderByWithAggregationInput[]
    by: Product_multiple_imagesScalarFieldEnum[] | Product_multiple_imagesScalarFieldEnum
    having?: product_multiple_imagesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Product_multiple_imagesCountAggregateInputType | true
    _avg?: Product_multiple_imagesAvgAggregateInputType
    _sum?: Product_multiple_imagesSumAggregateInputType
    _min?: Product_multiple_imagesMinAggregateInputType
    _max?: Product_multiple_imagesMaxAggregateInputType
  }

  export type Product_multiple_imagesGroupByOutputType = {
    id: number
    customer_order_id: number
    filename: string
    _count: Product_multiple_imagesCountAggregateOutputType | null
    _avg: Product_multiple_imagesAvgAggregateOutputType | null
    _sum: Product_multiple_imagesSumAggregateOutputType | null
    _min: Product_multiple_imagesMinAggregateOutputType | null
    _max: Product_multiple_imagesMaxAggregateOutputType | null
  }

  type GetProduct_multiple_imagesGroupByPayload<T extends product_multiple_imagesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Product_multiple_imagesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Product_multiple_imagesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Product_multiple_imagesGroupByOutputType[P]>
            : GetScalarType<T[P], Product_multiple_imagesGroupByOutputType[P]>
        }
      >
    >


  export type product_multiple_imagesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customer_order_id?: boolean
    filename?: boolean
    customerOrderDetails?: boolean | customer_orderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product_multiple_images"]>



  export type product_multiple_imagesSelectScalar = {
    id?: boolean
    customer_order_id?: boolean
    filename?: boolean
  }

  export type product_multiple_imagesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "customer_order_id" | "filename", ExtArgs["result"]["product_multiple_images"]>
  export type product_multiple_imagesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customerOrderDetails?: boolean | customer_orderDefaultArgs<ExtArgs>
  }

  export type $product_multiple_imagesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "product_multiple_images"
    objects: {
      customerOrderDetails: Prisma.$customer_orderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      customer_order_id: number
      filename: string
    }, ExtArgs["result"]["product_multiple_images"]>
    composites: {}
  }

  type product_multiple_imagesGetPayload<S extends boolean | null | undefined | product_multiple_imagesDefaultArgs> = $Result.GetResult<Prisma.$product_multiple_imagesPayload, S>

  type product_multiple_imagesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<product_multiple_imagesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Product_multiple_imagesCountAggregateInputType | true
    }

  export interface product_multiple_imagesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['product_multiple_images'], meta: { name: 'product_multiple_images' } }
    /**
     * Find zero or one Product_multiple_images that matches the filter.
     * @param {product_multiple_imagesFindUniqueArgs} args - Arguments to find a Product_multiple_images
     * @example
     * // Get one Product_multiple_images
     * const product_multiple_images = await prisma.product_multiple_images.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends product_multiple_imagesFindUniqueArgs>(args: SelectSubset<T, product_multiple_imagesFindUniqueArgs<ExtArgs>>): Prisma__product_multiple_imagesClient<$Result.GetResult<Prisma.$product_multiple_imagesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Product_multiple_images that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {product_multiple_imagesFindUniqueOrThrowArgs} args - Arguments to find a Product_multiple_images
     * @example
     * // Get one Product_multiple_images
     * const product_multiple_images = await prisma.product_multiple_images.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends product_multiple_imagesFindUniqueOrThrowArgs>(args: SelectSubset<T, product_multiple_imagesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__product_multiple_imagesClient<$Result.GetResult<Prisma.$product_multiple_imagesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product_multiple_images that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {product_multiple_imagesFindFirstArgs} args - Arguments to find a Product_multiple_images
     * @example
     * // Get one Product_multiple_images
     * const product_multiple_images = await prisma.product_multiple_images.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends product_multiple_imagesFindFirstArgs>(args?: SelectSubset<T, product_multiple_imagesFindFirstArgs<ExtArgs>>): Prisma__product_multiple_imagesClient<$Result.GetResult<Prisma.$product_multiple_imagesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product_multiple_images that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {product_multiple_imagesFindFirstOrThrowArgs} args - Arguments to find a Product_multiple_images
     * @example
     * // Get one Product_multiple_images
     * const product_multiple_images = await prisma.product_multiple_images.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends product_multiple_imagesFindFirstOrThrowArgs>(args?: SelectSubset<T, product_multiple_imagesFindFirstOrThrowArgs<ExtArgs>>): Prisma__product_multiple_imagesClient<$Result.GetResult<Prisma.$product_multiple_imagesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Product_multiple_images that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {product_multiple_imagesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Product_multiple_images
     * const product_multiple_images = await prisma.product_multiple_images.findMany()
     * 
     * // Get first 10 Product_multiple_images
     * const product_multiple_images = await prisma.product_multiple_images.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const product_multiple_imagesWithIdOnly = await prisma.product_multiple_images.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends product_multiple_imagesFindManyArgs>(args?: SelectSubset<T, product_multiple_imagesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$product_multiple_imagesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Product_multiple_images.
     * @param {product_multiple_imagesCreateArgs} args - Arguments to create a Product_multiple_images.
     * @example
     * // Create one Product_multiple_images
     * const Product_multiple_images = await prisma.product_multiple_images.create({
     *   data: {
     *     // ... data to create a Product_multiple_images
     *   }
     * })
     * 
     */
    create<T extends product_multiple_imagesCreateArgs>(args: SelectSubset<T, product_multiple_imagesCreateArgs<ExtArgs>>): Prisma__product_multiple_imagesClient<$Result.GetResult<Prisma.$product_multiple_imagesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Product_multiple_images.
     * @param {product_multiple_imagesCreateManyArgs} args - Arguments to create many Product_multiple_images.
     * @example
     * // Create many Product_multiple_images
     * const product_multiple_images = await prisma.product_multiple_images.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends product_multiple_imagesCreateManyArgs>(args?: SelectSubset<T, product_multiple_imagesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Product_multiple_images.
     * @param {product_multiple_imagesDeleteArgs} args - Arguments to delete one Product_multiple_images.
     * @example
     * // Delete one Product_multiple_images
     * const Product_multiple_images = await prisma.product_multiple_images.delete({
     *   where: {
     *     // ... filter to delete one Product_multiple_images
     *   }
     * })
     * 
     */
    delete<T extends product_multiple_imagesDeleteArgs>(args: SelectSubset<T, product_multiple_imagesDeleteArgs<ExtArgs>>): Prisma__product_multiple_imagesClient<$Result.GetResult<Prisma.$product_multiple_imagesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Product_multiple_images.
     * @param {product_multiple_imagesUpdateArgs} args - Arguments to update one Product_multiple_images.
     * @example
     * // Update one Product_multiple_images
     * const product_multiple_images = await prisma.product_multiple_images.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends product_multiple_imagesUpdateArgs>(args: SelectSubset<T, product_multiple_imagesUpdateArgs<ExtArgs>>): Prisma__product_multiple_imagesClient<$Result.GetResult<Prisma.$product_multiple_imagesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Product_multiple_images.
     * @param {product_multiple_imagesDeleteManyArgs} args - Arguments to filter Product_multiple_images to delete.
     * @example
     * // Delete a few Product_multiple_images
     * const { count } = await prisma.product_multiple_images.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends product_multiple_imagesDeleteManyArgs>(args?: SelectSubset<T, product_multiple_imagesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Product_multiple_images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {product_multiple_imagesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Product_multiple_images
     * const product_multiple_images = await prisma.product_multiple_images.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends product_multiple_imagesUpdateManyArgs>(args: SelectSubset<T, product_multiple_imagesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Product_multiple_images.
     * @param {product_multiple_imagesUpsertArgs} args - Arguments to update or create a Product_multiple_images.
     * @example
     * // Update or create a Product_multiple_images
     * const product_multiple_images = await prisma.product_multiple_images.upsert({
     *   create: {
     *     // ... data to create a Product_multiple_images
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product_multiple_images we want to update
     *   }
     * })
     */
    upsert<T extends product_multiple_imagesUpsertArgs>(args: SelectSubset<T, product_multiple_imagesUpsertArgs<ExtArgs>>): Prisma__product_multiple_imagesClient<$Result.GetResult<Prisma.$product_multiple_imagesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Product_multiple_images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {product_multiple_imagesCountArgs} args - Arguments to filter Product_multiple_images to count.
     * @example
     * // Count the number of Product_multiple_images
     * const count = await prisma.product_multiple_images.count({
     *   where: {
     *     // ... the filter for the Product_multiple_images we want to count
     *   }
     * })
    **/
    count<T extends product_multiple_imagesCountArgs>(
      args?: Subset<T, product_multiple_imagesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Product_multiple_imagesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product_multiple_images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Product_multiple_imagesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Product_multiple_imagesAggregateArgs>(args: Subset<T, Product_multiple_imagesAggregateArgs>): Prisma.PrismaPromise<GetProduct_multiple_imagesAggregateType<T>>

    /**
     * Group by Product_multiple_images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {product_multiple_imagesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends product_multiple_imagesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: product_multiple_imagesGroupByArgs['orderBy'] }
        : { orderBy?: product_multiple_imagesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, product_multiple_imagesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProduct_multiple_imagesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the product_multiple_images model
   */
  readonly fields: product_multiple_imagesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for product_multiple_images.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__product_multiple_imagesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customerOrderDetails<T extends customer_orderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, customer_orderDefaultArgs<ExtArgs>>): Prisma__customer_orderClient<$Result.GetResult<Prisma.$customer_orderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the product_multiple_images model
   */
  interface product_multiple_imagesFieldRefs {
    readonly id: FieldRef<"product_multiple_images", 'Int'>
    readonly customer_order_id: FieldRef<"product_multiple_images", 'Int'>
    readonly filename: FieldRef<"product_multiple_images", 'String'>
  }
    

  // Custom InputTypes
  /**
   * product_multiple_images findUnique
   */
  export type product_multiple_imagesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_multiple_images
     */
    select?: product_multiple_imagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the product_multiple_images
     */
    omit?: product_multiple_imagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: product_multiple_imagesInclude<ExtArgs> | null
    /**
     * Filter, which product_multiple_images to fetch.
     */
    where: product_multiple_imagesWhereUniqueInput
  }

  /**
   * product_multiple_images findUniqueOrThrow
   */
  export type product_multiple_imagesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_multiple_images
     */
    select?: product_multiple_imagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the product_multiple_images
     */
    omit?: product_multiple_imagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: product_multiple_imagesInclude<ExtArgs> | null
    /**
     * Filter, which product_multiple_images to fetch.
     */
    where: product_multiple_imagesWhereUniqueInput
  }

  /**
   * product_multiple_images findFirst
   */
  export type product_multiple_imagesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_multiple_images
     */
    select?: product_multiple_imagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the product_multiple_images
     */
    omit?: product_multiple_imagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: product_multiple_imagesInclude<ExtArgs> | null
    /**
     * Filter, which product_multiple_images to fetch.
     */
    where?: product_multiple_imagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of product_multiple_images to fetch.
     */
    orderBy?: product_multiple_imagesOrderByWithRelationInput | product_multiple_imagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for product_multiple_images.
     */
    cursor?: product_multiple_imagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` product_multiple_images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` product_multiple_images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of product_multiple_images.
     */
    distinct?: Product_multiple_imagesScalarFieldEnum | Product_multiple_imagesScalarFieldEnum[]
  }

  /**
   * product_multiple_images findFirstOrThrow
   */
  export type product_multiple_imagesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_multiple_images
     */
    select?: product_multiple_imagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the product_multiple_images
     */
    omit?: product_multiple_imagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: product_multiple_imagesInclude<ExtArgs> | null
    /**
     * Filter, which product_multiple_images to fetch.
     */
    where?: product_multiple_imagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of product_multiple_images to fetch.
     */
    orderBy?: product_multiple_imagesOrderByWithRelationInput | product_multiple_imagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for product_multiple_images.
     */
    cursor?: product_multiple_imagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` product_multiple_images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` product_multiple_images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of product_multiple_images.
     */
    distinct?: Product_multiple_imagesScalarFieldEnum | Product_multiple_imagesScalarFieldEnum[]
  }

  /**
   * product_multiple_images findMany
   */
  export type product_multiple_imagesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_multiple_images
     */
    select?: product_multiple_imagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the product_multiple_images
     */
    omit?: product_multiple_imagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: product_multiple_imagesInclude<ExtArgs> | null
    /**
     * Filter, which product_multiple_images to fetch.
     */
    where?: product_multiple_imagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of product_multiple_images to fetch.
     */
    orderBy?: product_multiple_imagesOrderByWithRelationInput | product_multiple_imagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing product_multiple_images.
     */
    cursor?: product_multiple_imagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` product_multiple_images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` product_multiple_images.
     */
    skip?: number
    distinct?: Product_multiple_imagesScalarFieldEnum | Product_multiple_imagesScalarFieldEnum[]
  }

  /**
   * product_multiple_images create
   */
  export type product_multiple_imagesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_multiple_images
     */
    select?: product_multiple_imagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the product_multiple_images
     */
    omit?: product_multiple_imagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: product_multiple_imagesInclude<ExtArgs> | null
    /**
     * The data needed to create a product_multiple_images.
     */
    data: XOR<product_multiple_imagesCreateInput, product_multiple_imagesUncheckedCreateInput>
  }

  /**
   * product_multiple_images createMany
   */
  export type product_multiple_imagesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many product_multiple_images.
     */
    data: product_multiple_imagesCreateManyInput | product_multiple_imagesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * product_multiple_images update
   */
  export type product_multiple_imagesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_multiple_images
     */
    select?: product_multiple_imagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the product_multiple_images
     */
    omit?: product_multiple_imagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: product_multiple_imagesInclude<ExtArgs> | null
    /**
     * The data needed to update a product_multiple_images.
     */
    data: XOR<product_multiple_imagesUpdateInput, product_multiple_imagesUncheckedUpdateInput>
    /**
     * Choose, which product_multiple_images to update.
     */
    where: product_multiple_imagesWhereUniqueInput
  }

  /**
   * product_multiple_images updateMany
   */
  export type product_multiple_imagesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update product_multiple_images.
     */
    data: XOR<product_multiple_imagesUpdateManyMutationInput, product_multiple_imagesUncheckedUpdateManyInput>
    /**
     * Filter which product_multiple_images to update
     */
    where?: product_multiple_imagesWhereInput
    /**
     * Limit how many product_multiple_images to update.
     */
    limit?: number
  }

  /**
   * product_multiple_images upsert
   */
  export type product_multiple_imagesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_multiple_images
     */
    select?: product_multiple_imagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the product_multiple_images
     */
    omit?: product_multiple_imagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: product_multiple_imagesInclude<ExtArgs> | null
    /**
     * The filter to search for the product_multiple_images to update in case it exists.
     */
    where: product_multiple_imagesWhereUniqueInput
    /**
     * In case the product_multiple_images found by the `where` argument doesn't exist, create a new product_multiple_images with this data.
     */
    create: XOR<product_multiple_imagesCreateInput, product_multiple_imagesUncheckedCreateInput>
    /**
     * In case the product_multiple_images was found with the provided `where` argument, update it with this data.
     */
    update: XOR<product_multiple_imagesUpdateInput, product_multiple_imagesUncheckedUpdateInput>
  }

  /**
   * product_multiple_images delete
   */
  export type product_multiple_imagesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_multiple_images
     */
    select?: product_multiple_imagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the product_multiple_images
     */
    omit?: product_multiple_imagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: product_multiple_imagesInclude<ExtArgs> | null
    /**
     * Filter which product_multiple_images to delete.
     */
    where: product_multiple_imagesWhereUniqueInput
  }

  /**
   * product_multiple_images deleteMany
   */
  export type product_multiple_imagesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which product_multiple_images to delete
     */
    where?: product_multiple_imagesWhereInput
    /**
     * Limit how many product_multiple_images to delete.
     */
    limit?: number
  }

  /**
   * product_multiple_images without action
   */
  export type product_multiple_imagesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product_multiple_images
     */
    select?: product_multiple_imagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the product_multiple_images
     */
    omit?: product_multiple_imagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: product_multiple_imagesInclude<ExtArgs> | null
  }


  /**
   * Model MasterBullion
   */

  export type AggregateMasterBullion = {
    _count: MasterBullionCountAggregateOutputType | null
    _avg: MasterBullionAvgAggregateOutputType | null
    _sum: MasterBullionSumAggregateOutputType | null
    _min: MasterBullionMinAggregateOutputType | null
    _max: MasterBullionMaxAggregateOutputType | null
  }

  export type MasterBullionAvgAggregateOutputType = {
    id: number | null
  }

  export type MasterBullionSumAggregateOutputType = {
    id: number | null
  }

  export type MasterBullionMinAggregateOutputType = {
    id: number | null
    name: string | null
    phone: string | null
    address: string | null
  }

  export type MasterBullionMaxAggregateOutputType = {
    id: number | null
    name: string | null
    phone: string | null
    address: string | null
  }

  export type MasterBullionCountAggregateOutputType = {
    id: number
    name: number
    phone: number
    address: number
    _all: number
  }


  export type MasterBullionAvgAggregateInputType = {
    id?: true
  }

  export type MasterBullionSumAggregateInputType = {
    id?: true
  }

  export type MasterBullionMinAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    address?: true
  }

  export type MasterBullionMaxAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    address?: true
  }

  export type MasterBullionCountAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    address?: true
    _all?: true
  }

  export type MasterBullionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MasterBullion to aggregate.
     */
    where?: MasterBullionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MasterBullions to fetch.
     */
    orderBy?: MasterBullionOrderByWithRelationInput | MasterBullionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MasterBullionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MasterBullions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MasterBullions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MasterBullions
    **/
    _count?: true | MasterBullionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MasterBullionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MasterBullionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MasterBullionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MasterBullionMaxAggregateInputType
  }

  export type GetMasterBullionAggregateType<T extends MasterBullionAggregateArgs> = {
        [P in keyof T & keyof AggregateMasterBullion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMasterBullion[P]>
      : GetScalarType<T[P], AggregateMasterBullion[P]>
  }




  export type MasterBullionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MasterBullionWhereInput
    orderBy?: MasterBullionOrderByWithAggregationInput | MasterBullionOrderByWithAggregationInput[]
    by: MasterBullionScalarFieldEnum[] | MasterBullionScalarFieldEnum
    having?: MasterBullionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MasterBullionCountAggregateInputType | true
    _avg?: MasterBullionAvgAggregateInputType
    _sum?: MasterBullionSumAggregateInputType
    _min?: MasterBullionMinAggregateInputType
    _max?: MasterBullionMaxAggregateInputType
  }

  export type MasterBullionGroupByOutputType = {
    id: number
    name: string
    phone: string | null
    address: string | null
    _count: MasterBullionCountAggregateOutputType | null
    _avg: MasterBullionAvgAggregateOutputType | null
    _sum: MasterBullionSumAggregateOutputType | null
    _min: MasterBullionMinAggregateOutputType | null
    _max: MasterBullionMaxAggregateOutputType | null
  }

  type GetMasterBullionGroupByPayload<T extends MasterBullionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MasterBullionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MasterBullionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MasterBullionGroupByOutputType[P]>
            : GetScalarType<T[P], MasterBullionGroupByOutputType[P]>
        }
      >
    >


  export type MasterBullionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    phone?: boolean
    address?: boolean
    purchases?: boolean | MasterBullion$purchasesArgs<ExtArgs>
    _count?: boolean | MasterBullionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["masterBullion"]>



  export type MasterBullionSelectScalar = {
    id?: boolean
    name?: boolean
    phone?: boolean
    address?: boolean
  }

  export type MasterBullionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "phone" | "address", ExtArgs["result"]["masterBullion"]>
  export type MasterBullionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchases?: boolean | MasterBullion$purchasesArgs<ExtArgs>
    _count?: boolean | MasterBullionCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $MasterBullionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MasterBullion"
    objects: {
      purchases: Prisma.$BullionPurchasePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      phone: string | null
      address: string | null
    }, ExtArgs["result"]["masterBullion"]>
    composites: {}
  }

  type MasterBullionGetPayload<S extends boolean | null | undefined | MasterBullionDefaultArgs> = $Result.GetResult<Prisma.$MasterBullionPayload, S>

  type MasterBullionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MasterBullionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MasterBullionCountAggregateInputType | true
    }

  export interface MasterBullionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MasterBullion'], meta: { name: 'MasterBullion' } }
    /**
     * Find zero or one MasterBullion that matches the filter.
     * @param {MasterBullionFindUniqueArgs} args - Arguments to find a MasterBullion
     * @example
     * // Get one MasterBullion
     * const masterBullion = await prisma.masterBullion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MasterBullionFindUniqueArgs>(args: SelectSubset<T, MasterBullionFindUniqueArgs<ExtArgs>>): Prisma__MasterBullionClient<$Result.GetResult<Prisma.$MasterBullionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MasterBullion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MasterBullionFindUniqueOrThrowArgs} args - Arguments to find a MasterBullion
     * @example
     * // Get one MasterBullion
     * const masterBullion = await prisma.masterBullion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MasterBullionFindUniqueOrThrowArgs>(args: SelectSubset<T, MasterBullionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MasterBullionClient<$Result.GetResult<Prisma.$MasterBullionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MasterBullion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterBullionFindFirstArgs} args - Arguments to find a MasterBullion
     * @example
     * // Get one MasterBullion
     * const masterBullion = await prisma.masterBullion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MasterBullionFindFirstArgs>(args?: SelectSubset<T, MasterBullionFindFirstArgs<ExtArgs>>): Prisma__MasterBullionClient<$Result.GetResult<Prisma.$MasterBullionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MasterBullion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterBullionFindFirstOrThrowArgs} args - Arguments to find a MasterBullion
     * @example
     * // Get one MasterBullion
     * const masterBullion = await prisma.masterBullion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MasterBullionFindFirstOrThrowArgs>(args?: SelectSubset<T, MasterBullionFindFirstOrThrowArgs<ExtArgs>>): Prisma__MasterBullionClient<$Result.GetResult<Prisma.$MasterBullionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MasterBullions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterBullionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MasterBullions
     * const masterBullions = await prisma.masterBullion.findMany()
     * 
     * // Get first 10 MasterBullions
     * const masterBullions = await prisma.masterBullion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const masterBullionWithIdOnly = await prisma.masterBullion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MasterBullionFindManyArgs>(args?: SelectSubset<T, MasterBullionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MasterBullionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MasterBullion.
     * @param {MasterBullionCreateArgs} args - Arguments to create a MasterBullion.
     * @example
     * // Create one MasterBullion
     * const MasterBullion = await prisma.masterBullion.create({
     *   data: {
     *     // ... data to create a MasterBullion
     *   }
     * })
     * 
     */
    create<T extends MasterBullionCreateArgs>(args: SelectSubset<T, MasterBullionCreateArgs<ExtArgs>>): Prisma__MasterBullionClient<$Result.GetResult<Prisma.$MasterBullionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MasterBullions.
     * @param {MasterBullionCreateManyArgs} args - Arguments to create many MasterBullions.
     * @example
     * // Create many MasterBullions
     * const masterBullion = await prisma.masterBullion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MasterBullionCreateManyArgs>(args?: SelectSubset<T, MasterBullionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MasterBullion.
     * @param {MasterBullionDeleteArgs} args - Arguments to delete one MasterBullion.
     * @example
     * // Delete one MasterBullion
     * const MasterBullion = await prisma.masterBullion.delete({
     *   where: {
     *     // ... filter to delete one MasterBullion
     *   }
     * })
     * 
     */
    delete<T extends MasterBullionDeleteArgs>(args: SelectSubset<T, MasterBullionDeleteArgs<ExtArgs>>): Prisma__MasterBullionClient<$Result.GetResult<Prisma.$MasterBullionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MasterBullion.
     * @param {MasterBullionUpdateArgs} args - Arguments to update one MasterBullion.
     * @example
     * // Update one MasterBullion
     * const masterBullion = await prisma.masterBullion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MasterBullionUpdateArgs>(args: SelectSubset<T, MasterBullionUpdateArgs<ExtArgs>>): Prisma__MasterBullionClient<$Result.GetResult<Prisma.$MasterBullionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MasterBullions.
     * @param {MasterBullionDeleteManyArgs} args - Arguments to filter MasterBullions to delete.
     * @example
     * // Delete a few MasterBullions
     * const { count } = await prisma.masterBullion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MasterBullionDeleteManyArgs>(args?: SelectSubset<T, MasterBullionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MasterBullions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterBullionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MasterBullions
     * const masterBullion = await prisma.masterBullion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MasterBullionUpdateManyArgs>(args: SelectSubset<T, MasterBullionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MasterBullion.
     * @param {MasterBullionUpsertArgs} args - Arguments to update or create a MasterBullion.
     * @example
     * // Update or create a MasterBullion
     * const masterBullion = await prisma.masterBullion.upsert({
     *   create: {
     *     // ... data to create a MasterBullion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MasterBullion we want to update
     *   }
     * })
     */
    upsert<T extends MasterBullionUpsertArgs>(args: SelectSubset<T, MasterBullionUpsertArgs<ExtArgs>>): Prisma__MasterBullionClient<$Result.GetResult<Prisma.$MasterBullionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MasterBullions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterBullionCountArgs} args - Arguments to filter MasterBullions to count.
     * @example
     * // Count the number of MasterBullions
     * const count = await prisma.masterBullion.count({
     *   where: {
     *     // ... the filter for the MasterBullions we want to count
     *   }
     * })
    **/
    count<T extends MasterBullionCountArgs>(
      args?: Subset<T, MasterBullionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MasterBullionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MasterBullion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterBullionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MasterBullionAggregateArgs>(args: Subset<T, MasterBullionAggregateArgs>): Prisma.PrismaPromise<GetMasterBullionAggregateType<T>>

    /**
     * Group by MasterBullion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MasterBullionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MasterBullionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MasterBullionGroupByArgs['orderBy'] }
        : { orderBy?: MasterBullionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MasterBullionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMasterBullionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MasterBullion model
   */
  readonly fields: MasterBullionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MasterBullion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MasterBullionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    purchases<T extends MasterBullion$purchasesArgs<ExtArgs> = {}>(args?: Subset<T, MasterBullion$purchasesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BullionPurchasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MasterBullion model
   */
  interface MasterBullionFieldRefs {
    readonly id: FieldRef<"MasterBullion", 'Int'>
    readonly name: FieldRef<"MasterBullion", 'String'>
    readonly phone: FieldRef<"MasterBullion", 'String'>
    readonly address: FieldRef<"MasterBullion", 'String'>
  }
    

  // Custom InputTypes
  /**
   * MasterBullion findUnique
   */
  export type MasterBullionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterBullion
     */
    select?: MasterBullionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MasterBullion
     */
    omit?: MasterBullionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MasterBullionInclude<ExtArgs> | null
    /**
     * Filter, which MasterBullion to fetch.
     */
    where: MasterBullionWhereUniqueInput
  }

  /**
   * MasterBullion findUniqueOrThrow
   */
  export type MasterBullionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterBullion
     */
    select?: MasterBullionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MasterBullion
     */
    omit?: MasterBullionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MasterBullionInclude<ExtArgs> | null
    /**
     * Filter, which MasterBullion to fetch.
     */
    where: MasterBullionWhereUniqueInput
  }

  /**
   * MasterBullion findFirst
   */
  export type MasterBullionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterBullion
     */
    select?: MasterBullionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MasterBullion
     */
    omit?: MasterBullionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MasterBullionInclude<ExtArgs> | null
    /**
     * Filter, which MasterBullion to fetch.
     */
    where?: MasterBullionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MasterBullions to fetch.
     */
    orderBy?: MasterBullionOrderByWithRelationInput | MasterBullionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MasterBullions.
     */
    cursor?: MasterBullionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MasterBullions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MasterBullions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MasterBullions.
     */
    distinct?: MasterBullionScalarFieldEnum | MasterBullionScalarFieldEnum[]
  }

  /**
   * MasterBullion findFirstOrThrow
   */
  export type MasterBullionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterBullion
     */
    select?: MasterBullionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MasterBullion
     */
    omit?: MasterBullionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MasterBullionInclude<ExtArgs> | null
    /**
     * Filter, which MasterBullion to fetch.
     */
    where?: MasterBullionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MasterBullions to fetch.
     */
    orderBy?: MasterBullionOrderByWithRelationInput | MasterBullionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MasterBullions.
     */
    cursor?: MasterBullionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MasterBullions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MasterBullions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MasterBullions.
     */
    distinct?: MasterBullionScalarFieldEnum | MasterBullionScalarFieldEnum[]
  }

  /**
   * MasterBullion findMany
   */
  export type MasterBullionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterBullion
     */
    select?: MasterBullionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MasterBullion
     */
    omit?: MasterBullionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MasterBullionInclude<ExtArgs> | null
    /**
     * Filter, which MasterBullions to fetch.
     */
    where?: MasterBullionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MasterBullions to fetch.
     */
    orderBy?: MasterBullionOrderByWithRelationInput | MasterBullionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MasterBullions.
     */
    cursor?: MasterBullionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MasterBullions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MasterBullions.
     */
    skip?: number
    distinct?: MasterBullionScalarFieldEnum | MasterBullionScalarFieldEnum[]
  }

  /**
   * MasterBullion create
   */
  export type MasterBullionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterBullion
     */
    select?: MasterBullionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MasterBullion
     */
    omit?: MasterBullionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MasterBullionInclude<ExtArgs> | null
    /**
     * The data needed to create a MasterBullion.
     */
    data: XOR<MasterBullionCreateInput, MasterBullionUncheckedCreateInput>
  }

  /**
   * MasterBullion createMany
   */
  export type MasterBullionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MasterBullions.
     */
    data: MasterBullionCreateManyInput | MasterBullionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MasterBullion update
   */
  export type MasterBullionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterBullion
     */
    select?: MasterBullionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MasterBullion
     */
    omit?: MasterBullionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MasterBullionInclude<ExtArgs> | null
    /**
     * The data needed to update a MasterBullion.
     */
    data: XOR<MasterBullionUpdateInput, MasterBullionUncheckedUpdateInput>
    /**
     * Choose, which MasterBullion to update.
     */
    where: MasterBullionWhereUniqueInput
  }

  /**
   * MasterBullion updateMany
   */
  export type MasterBullionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MasterBullions.
     */
    data: XOR<MasterBullionUpdateManyMutationInput, MasterBullionUncheckedUpdateManyInput>
    /**
     * Filter which MasterBullions to update
     */
    where?: MasterBullionWhereInput
    /**
     * Limit how many MasterBullions to update.
     */
    limit?: number
  }

  /**
   * MasterBullion upsert
   */
  export type MasterBullionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterBullion
     */
    select?: MasterBullionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MasterBullion
     */
    omit?: MasterBullionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MasterBullionInclude<ExtArgs> | null
    /**
     * The filter to search for the MasterBullion to update in case it exists.
     */
    where: MasterBullionWhereUniqueInput
    /**
     * In case the MasterBullion found by the `where` argument doesn't exist, create a new MasterBullion with this data.
     */
    create: XOR<MasterBullionCreateInput, MasterBullionUncheckedCreateInput>
    /**
     * In case the MasterBullion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MasterBullionUpdateInput, MasterBullionUncheckedUpdateInput>
  }

  /**
   * MasterBullion delete
   */
  export type MasterBullionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterBullion
     */
    select?: MasterBullionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MasterBullion
     */
    omit?: MasterBullionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MasterBullionInclude<ExtArgs> | null
    /**
     * Filter which MasterBullion to delete.
     */
    where: MasterBullionWhereUniqueInput
  }

  /**
   * MasterBullion deleteMany
   */
  export type MasterBullionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MasterBullions to delete
     */
    where?: MasterBullionWhereInput
    /**
     * Limit how many MasterBullions to delete.
     */
    limit?: number
  }

  /**
   * MasterBullion.purchases
   */
  export type MasterBullion$purchasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BullionPurchase
     */
    select?: BullionPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BullionPurchase
     */
    omit?: BullionPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BullionPurchaseInclude<ExtArgs> | null
    where?: BullionPurchaseWhereInput
    orderBy?: BullionPurchaseOrderByWithRelationInput | BullionPurchaseOrderByWithRelationInput[]
    cursor?: BullionPurchaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BullionPurchaseScalarFieldEnum | BullionPurchaseScalarFieldEnum[]
  }

  /**
   * MasterBullion without action
   */
  export type MasterBullionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MasterBullion
     */
    select?: MasterBullionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MasterBullion
     */
    omit?: MasterBullionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MasterBullionInclude<ExtArgs> | null
  }


  /**
   * Model BullionPurchase
   */

  export type AggregateBullionPurchase = {
    _count: BullionPurchaseCountAggregateOutputType | null
    _avg: BullionPurchaseAvgAggregateOutputType | null
    _sum: BullionPurchaseSumAggregateOutputType | null
    _min: BullionPurchaseMinAggregateOutputType | null
    _max: BullionPurchaseMaxAggregateOutputType | null
  }

  export type BullionPurchaseAvgAggregateOutputType = {
    id: number | null
    bullionId: number | null
    grams: number | null
    touch: number | null
    purity: number | null
    rate: number | null
    amount: number | null
    balance: number | null
  }

  export type BullionPurchaseSumAggregateOutputType = {
    id: number | null
    bullionId: number | null
    grams: number | null
    touch: number | null
    purity: number | null
    rate: number | null
    amount: number | null
    balance: number | null
  }

  export type BullionPurchaseMinAggregateOutputType = {
    id: number | null
    bullionId: number | null
    grams: number | null
    touch: number | null
    purity: number | null
    rate: number | null
    amount: number | null
    balance: number | null
    createdAt: Date | null
  }

  export type BullionPurchaseMaxAggregateOutputType = {
    id: number | null
    bullionId: number | null
    grams: number | null
    touch: number | null
    purity: number | null
    rate: number | null
    amount: number | null
    balance: number | null
    createdAt: Date | null
  }

  export type BullionPurchaseCountAggregateOutputType = {
    id: number
    bullionId: number
    grams: number
    touch: number
    purity: number
    rate: number
    amount: number
    balance: number
    createdAt: number
    _all: number
  }


  export type BullionPurchaseAvgAggregateInputType = {
    id?: true
    bullionId?: true
    grams?: true
    touch?: true
    purity?: true
    rate?: true
    amount?: true
    balance?: true
  }

  export type BullionPurchaseSumAggregateInputType = {
    id?: true
    bullionId?: true
    grams?: true
    touch?: true
    purity?: true
    rate?: true
    amount?: true
    balance?: true
  }

  export type BullionPurchaseMinAggregateInputType = {
    id?: true
    bullionId?: true
    grams?: true
    touch?: true
    purity?: true
    rate?: true
    amount?: true
    balance?: true
    createdAt?: true
  }

  export type BullionPurchaseMaxAggregateInputType = {
    id?: true
    bullionId?: true
    grams?: true
    touch?: true
    purity?: true
    rate?: true
    amount?: true
    balance?: true
    createdAt?: true
  }

  export type BullionPurchaseCountAggregateInputType = {
    id?: true
    bullionId?: true
    grams?: true
    touch?: true
    purity?: true
    rate?: true
    amount?: true
    balance?: true
    createdAt?: true
    _all?: true
  }

  export type BullionPurchaseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BullionPurchase to aggregate.
     */
    where?: BullionPurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BullionPurchases to fetch.
     */
    orderBy?: BullionPurchaseOrderByWithRelationInput | BullionPurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BullionPurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BullionPurchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BullionPurchases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BullionPurchases
    **/
    _count?: true | BullionPurchaseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BullionPurchaseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BullionPurchaseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BullionPurchaseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BullionPurchaseMaxAggregateInputType
  }

  export type GetBullionPurchaseAggregateType<T extends BullionPurchaseAggregateArgs> = {
        [P in keyof T & keyof AggregateBullionPurchase]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBullionPurchase[P]>
      : GetScalarType<T[P], AggregateBullionPurchase[P]>
  }




  export type BullionPurchaseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BullionPurchaseWhereInput
    orderBy?: BullionPurchaseOrderByWithAggregationInput | BullionPurchaseOrderByWithAggregationInput[]
    by: BullionPurchaseScalarFieldEnum[] | BullionPurchaseScalarFieldEnum
    having?: BullionPurchaseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BullionPurchaseCountAggregateInputType | true
    _avg?: BullionPurchaseAvgAggregateInputType
    _sum?: BullionPurchaseSumAggregateInputType
    _min?: BullionPurchaseMinAggregateInputType
    _max?: BullionPurchaseMaxAggregateInputType
  }

  export type BullionPurchaseGroupByOutputType = {
    id: number
    bullionId: number
    grams: number
    touch: number | null
    purity: number | null
    rate: number
    amount: number
    balance: number
    createdAt: Date
    _count: BullionPurchaseCountAggregateOutputType | null
    _avg: BullionPurchaseAvgAggregateOutputType | null
    _sum: BullionPurchaseSumAggregateOutputType | null
    _min: BullionPurchaseMinAggregateOutputType | null
    _max: BullionPurchaseMaxAggregateOutputType | null
  }

  type GetBullionPurchaseGroupByPayload<T extends BullionPurchaseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BullionPurchaseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BullionPurchaseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BullionPurchaseGroupByOutputType[P]>
            : GetScalarType<T[P], BullionPurchaseGroupByOutputType[P]>
        }
      >
    >


  export type BullionPurchaseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bullionId?: boolean
    grams?: boolean
    touch?: boolean
    purity?: boolean
    rate?: boolean
    amount?: boolean
    balance?: boolean
    createdAt?: boolean
    bullion?: boolean | MasterBullionDefaultArgs<ExtArgs>
    givenDetails?: boolean | BullionPurchase$givenDetailsArgs<ExtArgs>
    _count?: boolean | BullionPurchaseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bullionPurchase"]>



  export type BullionPurchaseSelectScalar = {
    id?: boolean
    bullionId?: boolean
    grams?: boolean
    touch?: boolean
    purity?: boolean
    rate?: boolean
    amount?: boolean
    balance?: boolean
    createdAt?: boolean
  }

  export type BullionPurchaseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bullionId" | "grams" | "touch" | "purity" | "rate" | "amount" | "balance" | "createdAt", ExtArgs["result"]["bullionPurchase"]>
  export type BullionPurchaseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bullion?: boolean | MasterBullionDefaultArgs<ExtArgs>
    givenDetails?: boolean | BullionPurchase$givenDetailsArgs<ExtArgs>
    _count?: boolean | BullionPurchaseCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $BullionPurchasePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BullionPurchase"
    objects: {
      bullion: Prisma.$MasterBullionPayload<ExtArgs>
      givenDetails: Prisma.$GivenDetailPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      bullionId: number
      grams: number
      touch: number | null
      purity: number | null
      rate: number
      amount: number
      balance: number
      createdAt: Date
    }, ExtArgs["result"]["bullionPurchase"]>
    composites: {}
  }

  type BullionPurchaseGetPayload<S extends boolean | null | undefined | BullionPurchaseDefaultArgs> = $Result.GetResult<Prisma.$BullionPurchasePayload, S>

  type BullionPurchaseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BullionPurchaseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BullionPurchaseCountAggregateInputType | true
    }

  export interface BullionPurchaseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BullionPurchase'], meta: { name: 'BullionPurchase' } }
    /**
     * Find zero or one BullionPurchase that matches the filter.
     * @param {BullionPurchaseFindUniqueArgs} args - Arguments to find a BullionPurchase
     * @example
     * // Get one BullionPurchase
     * const bullionPurchase = await prisma.bullionPurchase.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BullionPurchaseFindUniqueArgs>(args: SelectSubset<T, BullionPurchaseFindUniqueArgs<ExtArgs>>): Prisma__BullionPurchaseClient<$Result.GetResult<Prisma.$BullionPurchasePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BullionPurchase that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BullionPurchaseFindUniqueOrThrowArgs} args - Arguments to find a BullionPurchase
     * @example
     * // Get one BullionPurchase
     * const bullionPurchase = await prisma.bullionPurchase.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BullionPurchaseFindUniqueOrThrowArgs>(args: SelectSubset<T, BullionPurchaseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BullionPurchaseClient<$Result.GetResult<Prisma.$BullionPurchasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BullionPurchase that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BullionPurchaseFindFirstArgs} args - Arguments to find a BullionPurchase
     * @example
     * // Get one BullionPurchase
     * const bullionPurchase = await prisma.bullionPurchase.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BullionPurchaseFindFirstArgs>(args?: SelectSubset<T, BullionPurchaseFindFirstArgs<ExtArgs>>): Prisma__BullionPurchaseClient<$Result.GetResult<Prisma.$BullionPurchasePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BullionPurchase that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BullionPurchaseFindFirstOrThrowArgs} args - Arguments to find a BullionPurchase
     * @example
     * // Get one BullionPurchase
     * const bullionPurchase = await prisma.bullionPurchase.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BullionPurchaseFindFirstOrThrowArgs>(args?: SelectSubset<T, BullionPurchaseFindFirstOrThrowArgs<ExtArgs>>): Prisma__BullionPurchaseClient<$Result.GetResult<Prisma.$BullionPurchasePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BullionPurchases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BullionPurchaseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BullionPurchases
     * const bullionPurchases = await prisma.bullionPurchase.findMany()
     * 
     * // Get first 10 BullionPurchases
     * const bullionPurchases = await prisma.bullionPurchase.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bullionPurchaseWithIdOnly = await prisma.bullionPurchase.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BullionPurchaseFindManyArgs>(args?: SelectSubset<T, BullionPurchaseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BullionPurchasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BullionPurchase.
     * @param {BullionPurchaseCreateArgs} args - Arguments to create a BullionPurchase.
     * @example
     * // Create one BullionPurchase
     * const BullionPurchase = await prisma.bullionPurchase.create({
     *   data: {
     *     // ... data to create a BullionPurchase
     *   }
     * })
     * 
     */
    create<T extends BullionPurchaseCreateArgs>(args: SelectSubset<T, BullionPurchaseCreateArgs<ExtArgs>>): Prisma__BullionPurchaseClient<$Result.GetResult<Prisma.$BullionPurchasePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BullionPurchases.
     * @param {BullionPurchaseCreateManyArgs} args - Arguments to create many BullionPurchases.
     * @example
     * // Create many BullionPurchases
     * const bullionPurchase = await prisma.bullionPurchase.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BullionPurchaseCreateManyArgs>(args?: SelectSubset<T, BullionPurchaseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BullionPurchase.
     * @param {BullionPurchaseDeleteArgs} args - Arguments to delete one BullionPurchase.
     * @example
     * // Delete one BullionPurchase
     * const BullionPurchase = await prisma.bullionPurchase.delete({
     *   where: {
     *     // ... filter to delete one BullionPurchase
     *   }
     * })
     * 
     */
    delete<T extends BullionPurchaseDeleteArgs>(args: SelectSubset<T, BullionPurchaseDeleteArgs<ExtArgs>>): Prisma__BullionPurchaseClient<$Result.GetResult<Prisma.$BullionPurchasePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BullionPurchase.
     * @param {BullionPurchaseUpdateArgs} args - Arguments to update one BullionPurchase.
     * @example
     * // Update one BullionPurchase
     * const bullionPurchase = await prisma.bullionPurchase.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BullionPurchaseUpdateArgs>(args: SelectSubset<T, BullionPurchaseUpdateArgs<ExtArgs>>): Prisma__BullionPurchaseClient<$Result.GetResult<Prisma.$BullionPurchasePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BullionPurchases.
     * @param {BullionPurchaseDeleteManyArgs} args - Arguments to filter BullionPurchases to delete.
     * @example
     * // Delete a few BullionPurchases
     * const { count } = await prisma.bullionPurchase.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BullionPurchaseDeleteManyArgs>(args?: SelectSubset<T, BullionPurchaseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BullionPurchases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BullionPurchaseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BullionPurchases
     * const bullionPurchase = await prisma.bullionPurchase.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BullionPurchaseUpdateManyArgs>(args: SelectSubset<T, BullionPurchaseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BullionPurchase.
     * @param {BullionPurchaseUpsertArgs} args - Arguments to update or create a BullionPurchase.
     * @example
     * // Update or create a BullionPurchase
     * const bullionPurchase = await prisma.bullionPurchase.upsert({
     *   create: {
     *     // ... data to create a BullionPurchase
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BullionPurchase we want to update
     *   }
     * })
     */
    upsert<T extends BullionPurchaseUpsertArgs>(args: SelectSubset<T, BullionPurchaseUpsertArgs<ExtArgs>>): Prisma__BullionPurchaseClient<$Result.GetResult<Prisma.$BullionPurchasePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BullionPurchases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BullionPurchaseCountArgs} args - Arguments to filter BullionPurchases to count.
     * @example
     * // Count the number of BullionPurchases
     * const count = await prisma.bullionPurchase.count({
     *   where: {
     *     // ... the filter for the BullionPurchases we want to count
     *   }
     * })
    **/
    count<T extends BullionPurchaseCountArgs>(
      args?: Subset<T, BullionPurchaseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BullionPurchaseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BullionPurchase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BullionPurchaseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BullionPurchaseAggregateArgs>(args: Subset<T, BullionPurchaseAggregateArgs>): Prisma.PrismaPromise<GetBullionPurchaseAggregateType<T>>

    /**
     * Group by BullionPurchase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BullionPurchaseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BullionPurchaseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BullionPurchaseGroupByArgs['orderBy'] }
        : { orderBy?: BullionPurchaseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BullionPurchaseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBullionPurchaseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BullionPurchase model
   */
  readonly fields: BullionPurchaseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BullionPurchase.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BullionPurchaseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bullion<T extends MasterBullionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MasterBullionDefaultArgs<ExtArgs>>): Prisma__MasterBullionClient<$Result.GetResult<Prisma.$MasterBullionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    givenDetails<T extends BullionPurchase$givenDetailsArgs<ExtArgs> = {}>(args?: Subset<T, BullionPurchase$givenDetailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GivenDetailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BullionPurchase model
   */
  interface BullionPurchaseFieldRefs {
    readonly id: FieldRef<"BullionPurchase", 'Int'>
    readonly bullionId: FieldRef<"BullionPurchase", 'Int'>
    readonly grams: FieldRef<"BullionPurchase", 'Float'>
    readonly touch: FieldRef<"BullionPurchase", 'Float'>
    readonly purity: FieldRef<"BullionPurchase", 'Float'>
    readonly rate: FieldRef<"BullionPurchase", 'Float'>
    readonly amount: FieldRef<"BullionPurchase", 'Float'>
    readonly balance: FieldRef<"BullionPurchase", 'Float'>
    readonly createdAt: FieldRef<"BullionPurchase", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BullionPurchase findUnique
   */
  export type BullionPurchaseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BullionPurchase
     */
    select?: BullionPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BullionPurchase
     */
    omit?: BullionPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BullionPurchaseInclude<ExtArgs> | null
    /**
     * Filter, which BullionPurchase to fetch.
     */
    where: BullionPurchaseWhereUniqueInput
  }

  /**
   * BullionPurchase findUniqueOrThrow
   */
  export type BullionPurchaseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BullionPurchase
     */
    select?: BullionPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BullionPurchase
     */
    omit?: BullionPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BullionPurchaseInclude<ExtArgs> | null
    /**
     * Filter, which BullionPurchase to fetch.
     */
    where: BullionPurchaseWhereUniqueInput
  }

  /**
   * BullionPurchase findFirst
   */
  export type BullionPurchaseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BullionPurchase
     */
    select?: BullionPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BullionPurchase
     */
    omit?: BullionPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BullionPurchaseInclude<ExtArgs> | null
    /**
     * Filter, which BullionPurchase to fetch.
     */
    where?: BullionPurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BullionPurchases to fetch.
     */
    orderBy?: BullionPurchaseOrderByWithRelationInput | BullionPurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BullionPurchases.
     */
    cursor?: BullionPurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BullionPurchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BullionPurchases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BullionPurchases.
     */
    distinct?: BullionPurchaseScalarFieldEnum | BullionPurchaseScalarFieldEnum[]
  }

  /**
   * BullionPurchase findFirstOrThrow
   */
  export type BullionPurchaseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BullionPurchase
     */
    select?: BullionPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BullionPurchase
     */
    omit?: BullionPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BullionPurchaseInclude<ExtArgs> | null
    /**
     * Filter, which BullionPurchase to fetch.
     */
    where?: BullionPurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BullionPurchases to fetch.
     */
    orderBy?: BullionPurchaseOrderByWithRelationInput | BullionPurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BullionPurchases.
     */
    cursor?: BullionPurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BullionPurchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BullionPurchases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BullionPurchases.
     */
    distinct?: BullionPurchaseScalarFieldEnum | BullionPurchaseScalarFieldEnum[]
  }

  /**
   * BullionPurchase findMany
   */
  export type BullionPurchaseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BullionPurchase
     */
    select?: BullionPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BullionPurchase
     */
    omit?: BullionPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BullionPurchaseInclude<ExtArgs> | null
    /**
     * Filter, which BullionPurchases to fetch.
     */
    where?: BullionPurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BullionPurchases to fetch.
     */
    orderBy?: BullionPurchaseOrderByWithRelationInput | BullionPurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BullionPurchases.
     */
    cursor?: BullionPurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BullionPurchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BullionPurchases.
     */
    skip?: number
    distinct?: BullionPurchaseScalarFieldEnum | BullionPurchaseScalarFieldEnum[]
  }

  /**
   * BullionPurchase create
   */
  export type BullionPurchaseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BullionPurchase
     */
    select?: BullionPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BullionPurchase
     */
    omit?: BullionPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BullionPurchaseInclude<ExtArgs> | null
    /**
     * The data needed to create a BullionPurchase.
     */
    data: XOR<BullionPurchaseCreateInput, BullionPurchaseUncheckedCreateInput>
  }

  /**
   * BullionPurchase createMany
   */
  export type BullionPurchaseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BullionPurchases.
     */
    data: BullionPurchaseCreateManyInput | BullionPurchaseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BullionPurchase update
   */
  export type BullionPurchaseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BullionPurchase
     */
    select?: BullionPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BullionPurchase
     */
    omit?: BullionPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BullionPurchaseInclude<ExtArgs> | null
    /**
     * The data needed to update a BullionPurchase.
     */
    data: XOR<BullionPurchaseUpdateInput, BullionPurchaseUncheckedUpdateInput>
    /**
     * Choose, which BullionPurchase to update.
     */
    where: BullionPurchaseWhereUniqueInput
  }

  /**
   * BullionPurchase updateMany
   */
  export type BullionPurchaseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BullionPurchases.
     */
    data: XOR<BullionPurchaseUpdateManyMutationInput, BullionPurchaseUncheckedUpdateManyInput>
    /**
     * Filter which BullionPurchases to update
     */
    where?: BullionPurchaseWhereInput
    /**
     * Limit how many BullionPurchases to update.
     */
    limit?: number
  }

  /**
   * BullionPurchase upsert
   */
  export type BullionPurchaseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BullionPurchase
     */
    select?: BullionPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BullionPurchase
     */
    omit?: BullionPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BullionPurchaseInclude<ExtArgs> | null
    /**
     * The filter to search for the BullionPurchase to update in case it exists.
     */
    where: BullionPurchaseWhereUniqueInput
    /**
     * In case the BullionPurchase found by the `where` argument doesn't exist, create a new BullionPurchase with this data.
     */
    create: XOR<BullionPurchaseCreateInput, BullionPurchaseUncheckedCreateInput>
    /**
     * In case the BullionPurchase was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BullionPurchaseUpdateInput, BullionPurchaseUncheckedUpdateInput>
  }

  /**
   * BullionPurchase delete
   */
  export type BullionPurchaseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BullionPurchase
     */
    select?: BullionPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BullionPurchase
     */
    omit?: BullionPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BullionPurchaseInclude<ExtArgs> | null
    /**
     * Filter which BullionPurchase to delete.
     */
    where: BullionPurchaseWhereUniqueInput
  }

  /**
   * BullionPurchase deleteMany
   */
  export type BullionPurchaseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BullionPurchases to delete
     */
    where?: BullionPurchaseWhereInput
    /**
     * Limit how many BullionPurchases to delete.
     */
    limit?: number
  }

  /**
   * BullionPurchase.givenDetails
   */
  export type BullionPurchase$givenDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GivenDetail
     */
    select?: GivenDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GivenDetail
     */
    omit?: GivenDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GivenDetailInclude<ExtArgs> | null
    where?: GivenDetailWhereInput
    orderBy?: GivenDetailOrderByWithRelationInput | GivenDetailOrderByWithRelationInput[]
    cursor?: GivenDetailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GivenDetailScalarFieldEnum | GivenDetailScalarFieldEnum[]
  }

  /**
   * BullionPurchase without action
   */
  export type BullionPurchaseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BullionPurchase
     */
    select?: BullionPurchaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BullionPurchase
     */
    omit?: BullionPurchaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BullionPurchaseInclude<ExtArgs> | null
  }


  /**
   * Model GivenDetail
   */

  export type AggregateGivenDetail = {
    _count: GivenDetailCountAggregateOutputType | null
    _avg: GivenDetailAvgAggregateOutputType | null
    _sum: GivenDetailSumAggregateOutputType | null
    _min: GivenDetailMinAggregateOutputType | null
    _max: GivenDetailMaxAggregateOutputType | null
  }

  export type GivenDetailAvgAggregateOutputType = {
    id: number | null
    amount: number | null
    grams: number | null
    touch: number | null
    purity: number | null
    purchaseId: number | null
  }

  export type GivenDetailSumAggregateOutputType = {
    id: number | null
    amount: number | null
    grams: number | null
    touch: number | null
    purity: number | null
    purchaseId: number | null
  }

  export type GivenDetailMinAggregateOutputType = {
    id: number | null
    amount: number | null
    grams: number | null
    touch: number | null
    purity: number | null
    purchaseId: number | null
  }

  export type GivenDetailMaxAggregateOutputType = {
    id: number | null
    amount: number | null
    grams: number | null
    touch: number | null
    purity: number | null
    purchaseId: number | null
  }

  export type GivenDetailCountAggregateOutputType = {
    id: number
    amount: number
    grams: number
    touch: number
    purity: number
    purchaseId: number
    _all: number
  }


  export type GivenDetailAvgAggregateInputType = {
    id?: true
    amount?: true
    grams?: true
    touch?: true
    purity?: true
    purchaseId?: true
  }

  export type GivenDetailSumAggregateInputType = {
    id?: true
    amount?: true
    grams?: true
    touch?: true
    purity?: true
    purchaseId?: true
  }

  export type GivenDetailMinAggregateInputType = {
    id?: true
    amount?: true
    grams?: true
    touch?: true
    purity?: true
    purchaseId?: true
  }

  export type GivenDetailMaxAggregateInputType = {
    id?: true
    amount?: true
    grams?: true
    touch?: true
    purity?: true
    purchaseId?: true
  }

  export type GivenDetailCountAggregateInputType = {
    id?: true
    amount?: true
    grams?: true
    touch?: true
    purity?: true
    purchaseId?: true
    _all?: true
  }

  export type GivenDetailAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GivenDetail to aggregate.
     */
    where?: GivenDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GivenDetails to fetch.
     */
    orderBy?: GivenDetailOrderByWithRelationInput | GivenDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GivenDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GivenDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GivenDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GivenDetails
    **/
    _count?: true | GivenDetailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GivenDetailAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GivenDetailSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GivenDetailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GivenDetailMaxAggregateInputType
  }

  export type GetGivenDetailAggregateType<T extends GivenDetailAggregateArgs> = {
        [P in keyof T & keyof AggregateGivenDetail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGivenDetail[P]>
      : GetScalarType<T[P], AggregateGivenDetail[P]>
  }




  export type GivenDetailGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GivenDetailWhereInput
    orderBy?: GivenDetailOrderByWithAggregationInput | GivenDetailOrderByWithAggregationInput[]
    by: GivenDetailScalarFieldEnum[] | GivenDetailScalarFieldEnum
    having?: GivenDetailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GivenDetailCountAggregateInputType | true
    _avg?: GivenDetailAvgAggregateInputType
    _sum?: GivenDetailSumAggregateInputType
    _min?: GivenDetailMinAggregateInputType
    _max?: GivenDetailMaxAggregateInputType
  }

  export type GivenDetailGroupByOutputType = {
    id: number
    amount: number
    grams: number
    touch: number | null
    purity: number | null
    purchaseId: number
    _count: GivenDetailCountAggregateOutputType | null
    _avg: GivenDetailAvgAggregateOutputType | null
    _sum: GivenDetailSumAggregateOutputType | null
    _min: GivenDetailMinAggregateOutputType | null
    _max: GivenDetailMaxAggregateOutputType | null
  }

  type GetGivenDetailGroupByPayload<T extends GivenDetailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GivenDetailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GivenDetailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GivenDetailGroupByOutputType[P]>
            : GetScalarType<T[P], GivenDetailGroupByOutputType[P]>
        }
      >
    >


  export type GivenDetailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    grams?: boolean
    touch?: boolean
    purity?: boolean
    purchaseId?: boolean
    bullionPurchase?: boolean | BullionPurchaseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["givenDetail"]>



  export type GivenDetailSelectScalar = {
    id?: boolean
    amount?: boolean
    grams?: boolean
    touch?: boolean
    purity?: boolean
    purchaseId?: boolean
  }

  export type GivenDetailOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "amount" | "grams" | "touch" | "purity" | "purchaseId", ExtArgs["result"]["givenDetail"]>
  export type GivenDetailInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bullionPurchase?: boolean | BullionPurchaseDefaultArgs<ExtArgs>
  }

  export type $GivenDetailPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GivenDetail"
    objects: {
      bullionPurchase: Prisma.$BullionPurchasePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      amount: number
      grams: number
      touch: number | null
      purity: number | null
      purchaseId: number
    }, ExtArgs["result"]["givenDetail"]>
    composites: {}
  }

  type GivenDetailGetPayload<S extends boolean | null | undefined | GivenDetailDefaultArgs> = $Result.GetResult<Prisma.$GivenDetailPayload, S>

  type GivenDetailCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GivenDetailFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GivenDetailCountAggregateInputType | true
    }

  export interface GivenDetailDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GivenDetail'], meta: { name: 'GivenDetail' } }
    /**
     * Find zero or one GivenDetail that matches the filter.
     * @param {GivenDetailFindUniqueArgs} args - Arguments to find a GivenDetail
     * @example
     * // Get one GivenDetail
     * const givenDetail = await prisma.givenDetail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GivenDetailFindUniqueArgs>(args: SelectSubset<T, GivenDetailFindUniqueArgs<ExtArgs>>): Prisma__GivenDetailClient<$Result.GetResult<Prisma.$GivenDetailPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GivenDetail that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GivenDetailFindUniqueOrThrowArgs} args - Arguments to find a GivenDetail
     * @example
     * // Get one GivenDetail
     * const givenDetail = await prisma.givenDetail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GivenDetailFindUniqueOrThrowArgs>(args: SelectSubset<T, GivenDetailFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GivenDetailClient<$Result.GetResult<Prisma.$GivenDetailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GivenDetail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GivenDetailFindFirstArgs} args - Arguments to find a GivenDetail
     * @example
     * // Get one GivenDetail
     * const givenDetail = await prisma.givenDetail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GivenDetailFindFirstArgs>(args?: SelectSubset<T, GivenDetailFindFirstArgs<ExtArgs>>): Prisma__GivenDetailClient<$Result.GetResult<Prisma.$GivenDetailPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GivenDetail that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GivenDetailFindFirstOrThrowArgs} args - Arguments to find a GivenDetail
     * @example
     * // Get one GivenDetail
     * const givenDetail = await prisma.givenDetail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GivenDetailFindFirstOrThrowArgs>(args?: SelectSubset<T, GivenDetailFindFirstOrThrowArgs<ExtArgs>>): Prisma__GivenDetailClient<$Result.GetResult<Prisma.$GivenDetailPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GivenDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GivenDetailFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GivenDetails
     * const givenDetails = await prisma.givenDetail.findMany()
     * 
     * // Get first 10 GivenDetails
     * const givenDetails = await prisma.givenDetail.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const givenDetailWithIdOnly = await prisma.givenDetail.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GivenDetailFindManyArgs>(args?: SelectSubset<T, GivenDetailFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GivenDetailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GivenDetail.
     * @param {GivenDetailCreateArgs} args - Arguments to create a GivenDetail.
     * @example
     * // Create one GivenDetail
     * const GivenDetail = await prisma.givenDetail.create({
     *   data: {
     *     // ... data to create a GivenDetail
     *   }
     * })
     * 
     */
    create<T extends GivenDetailCreateArgs>(args: SelectSubset<T, GivenDetailCreateArgs<ExtArgs>>): Prisma__GivenDetailClient<$Result.GetResult<Prisma.$GivenDetailPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GivenDetails.
     * @param {GivenDetailCreateManyArgs} args - Arguments to create many GivenDetails.
     * @example
     * // Create many GivenDetails
     * const givenDetail = await prisma.givenDetail.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GivenDetailCreateManyArgs>(args?: SelectSubset<T, GivenDetailCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a GivenDetail.
     * @param {GivenDetailDeleteArgs} args - Arguments to delete one GivenDetail.
     * @example
     * // Delete one GivenDetail
     * const GivenDetail = await prisma.givenDetail.delete({
     *   where: {
     *     // ... filter to delete one GivenDetail
     *   }
     * })
     * 
     */
    delete<T extends GivenDetailDeleteArgs>(args: SelectSubset<T, GivenDetailDeleteArgs<ExtArgs>>): Prisma__GivenDetailClient<$Result.GetResult<Prisma.$GivenDetailPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GivenDetail.
     * @param {GivenDetailUpdateArgs} args - Arguments to update one GivenDetail.
     * @example
     * // Update one GivenDetail
     * const givenDetail = await prisma.givenDetail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GivenDetailUpdateArgs>(args: SelectSubset<T, GivenDetailUpdateArgs<ExtArgs>>): Prisma__GivenDetailClient<$Result.GetResult<Prisma.$GivenDetailPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GivenDetails.
     * @param {GivenDetailDeleteManyArgs} args - Arguments to filter GivenDetails to delete.
     * @example
     * // Delete a few GivenDetails
     * const { count } = await prisma.givenDetail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GivenDetailDeleteManyArgs>(args?: SelectSubset<T, GivenDetailDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GivenDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GivenDetailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GivenDetails
     * const givenDetail = await prisma.givenDetail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GivenDetailUpdateManyArgs>(args: SelectSubset<T, GivenDetailUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one GivenDetail.
     * @param {GivenDetailUpsertArgs} args - Arguments to update or create a GivenDetail.
     * @example
     * // Update or create a GivenDetail
     * const givenDetail = await prisma.givenDetail.upsert({
     *   create: {
     *     // ... data to create a GivenDetail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GivenDetail we want to update
     *   }
     * })
     */
    upsert<T extends GivenDetailUpsertArgs>(args: SelectSubset<T, GivenDetailUpsertArgs<ExtArgs>>): Prisma__GivenDetailClient<$Result.GetResult<Prisma.$GivenDetailPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GivenDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GivenDetailCountArgs} args - Arguments to filter GivenDetails to count.
     * @example
     * // Count the number of GivenDetails
     * const count = await prisma.givenDetail.count({
     *   where: {
     *     // ... the filter for the GivenDetails we want to count
     *   }
     * })
    **/
    count<T extends GivenDetailCountArgs>(
      args?: Subset<T, GivenDetailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GivenDetailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GivenDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GivenDetailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GivenDetailAggregateArgs>(args: Subset<T, GivenDetailAggregateArgs>): Prisma.PrismaPromise<GetGivenDetailAggregateType<T>>

    /**
     * Group by GivenDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GivenDetailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GivenDetailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GivenDetailGroupByArgs['orderBy'] }
        : { orderBy?: GivenDetailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GivenDetailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGivenDetailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GivenDetail model
   */
  readonly fields: GivenDetailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GivenDetail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GivenDetailClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bullionPurchase<T extends BullionPurchaseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BullionPurchaseDefaultArgs<ExtArgs>>): Prisma__BullionPurchaseClient<$Result.GetResult<Prisma.$BullionPurchasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GivenDetail model
   */
  interface GivenDetailFieldRefs {
    readonly id: FieldRef<"GivenDetail", 'Int'>
    readonly amount: FieldRef<"GivenDetail", 'Float'>
    readonly grams: FieldRef<"GivenDetail", 'Float'>
    readonly touch: FieldRef<"GivenDetail", 'Float'>
    readonly purity: FieldRef<"GivenDetail", 'Float'>
    readonly purchaseId: FieldRef<"GivenDetail", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * GivenDetail findUnique
   */
  export type GivenDetailFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GivenDetail
     */
    select?: GivenDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GivenDetail
     */
    omit?: GivenDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GivenDetailInclude<ExtArgs> | null
    /**
     * Filter, which GivenDetail to fetch.
     */
    where: GivenDetailWhereUniqueInput
  }

  /**
   * GivenDetail findUniqueOrThrow
   */
  export type GivenDetailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GivenDetail
     */
    select?: GivenDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GivenDetail
     */
    omit?: GivenDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GivenDetailInclude<ExtArgs> | null
    /**
     * Filter, which GivenDetail to fetch.
     */
    where: GivenDetailWhereUniqueInput
  }

  /**
   * GivenDetail findFirst
   */
  export type GivenDetailFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GivenDetail
     */
    select?: GivenDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GivenDetail
     */
    omit?: GivenDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GivenDetailInclude<ExtArgs> | null
    /**
     * Filter, which GivenDetail to fetch.
     */
    where?: GivenDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GivenDetails to fetch.
     */
    orderBy?: GivenDetailOrderByWithRelationInput | GivenDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GivenDetails.
     */
    cursor?: GivenDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GivenDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GivenDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GivenDetails.
     */
    distinct?: GivenDetailScalarFieldEnum | GivenDetailScalarFieldEnum[]
  }

  /**
   * GivenDetail findFirstOrThrow
   */
  export type GivenDetailFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GivenDetail
     */
    select?: GivenDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GivenDetail
     */
    omit?: GivenDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GivenDetailInclude<ExtArgs> | null
    /**
     * Filter, which GivenDetail to fetch.
     */
    where?: GivenDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GivenDetails to fetch.
     */
    orderBy?: GivenDetailOrderByWithRelationInput | GivenDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GivenDetails.
     */
    cursor?: GivenDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GivenDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GivenDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GivenDetails.
     */
    distinct?: GivenDetailScalarFieldEnum | GivenDetailScalarFieldEnum[]
  }

  /**
   * GivenDetail findMany
   */
  export type GivenDetailFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GivenDetail
     */
    select?: GivenDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GivenDetail
     */
    omit?: GivenDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GivenDetailInclude<ExtArgs> | null
    /**
     * Filter, which GivenDetails to fetch.
     */
    where?: GivenDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GivenDetails to fetch.
     */
    orderBy?: GivenDetailOrderByWithRelationInput | GivenDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GivenDetails.
     */
    cursor?: GivenDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GivenDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GivenDetails.
     */
    skip?: number
    distinct?: GivenDetailScalarFieldEnum | GivenDetailScalarFieldEnum[]
  }

  /**
   * GivenDetail create
   */
  export type GivenDetailCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GivenDetail
     */
    select?: GivenDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GivenDetail
     */
    omit?: GivenDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GivenDetailInclude<ExtArgs> | null
    /**
     * The data needed to create a GivenDetail.
     */
    data: XOR<GivenDetailCreateInput, GivenDetailUncheckedCreateInput>
  }

  /**
   * GivenDetail createMany
   */
  export type GivenDetailCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GivenDetails.
     */
    data: GivenDetailCreateManyInput | GivenDetailCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GivenDetail update
   */
  export type GivenDetailUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GivenDetail
     */
    select?: GivenDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GivenDetail
     */
    omit?: GivenDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GivenDetailInclude<ExtArgs> | null
    /**
     * The data needed to update a GivenDetail.
     */
    data: XOR<GivenDetailUpdateInput, GivenDetailUncheckedUpdateInput>
    /**
     * Choose, which GivenDetail to update.
     */
    where: GivenDetailWhereUniqueInput
  }

  /**
   * GivenDetail updateMany
   */
  export type GivenDetailUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GivenDetails.
     */
    data: XOR<GivenDetailUpdateManyMutationInput, GivenDetailUncheckedUpdateManyInput>
    /**
     * Filter which GivenDetails to update
     */
    where?: GivenDetailWhereInput
    /**
     * Limit how many GivenDetails to update.
     */
    limit?: number
  }

  /**
   * GivenDetail upsert
   */
  export type GivenDetailUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GivenDetail
     */
    select?: GivenDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GivenDetail
     */
    omit?: GivenDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GivenDetailInclude<ExtArgs> | null
    /**
     * The filter to search for the GivenDetail to update in case it exists.
     */
    where: GivenDetailWhereUniqueInput
    /**
     * In case the GivenDetail found by the `where` argument doesn't exist, create a new GivenDetail with this data.
     */
    create: XOR<GivenDetailCreateInput, GivenDetailUncheckedCreateInput>
    /**
     * In case the GivenDetail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GivenDetailUpdateInput, GivenDetailUncheckedUpdateInput>
  }

  /**
   * GivenDetail delete
   */
  export type GivenDetailDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GivenDetail
     */
    select?: GivenDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GivenDetail
     */
    omit?: GivenDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GivenDetailInclude<ExtArgs> | null
    /**
     * Filter which GivenDetail to delete.
     */
    where: GivenDetailWhereUniqueInput
  }

  /**
   * GivenDetail deleteMany
   */
  export type GivenDetailDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GivenDetails to delete
     */
    where?: GivenDetailWhereInput
    /**
     * Limit how many GivenDetails to delete.
     */
    limit?: number
  }

  /**
   * GivenDetail without action
   */
  export type GivenDetailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GivenDetail
     */
    select?: GivenDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GivenDetail
     */
    omit?: GivenDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GivenDetailInclude<ExtArgs> | null
  }


  /**
   * Model Goldsmith
   */

  export type AggregateGoldsmith = {
    _count: GoldsmithCountAggregateOutputType | null
    _avg: GoldsmithAvgAggregateOutputType | null
    _sum: GoldsmithSumAggregateOutputType | null
    _min: GoldsmithMinAggregateOutputType | null
    _max: GoldsmithMaxAggregateOutputType | null
  }

  export type GoldsmithAvgAggregateOutputType = {
    id: number | null
  }

  export type GoldsmithSumAggregateOutputType = {
    id: number | null
  }

  export type GoldsmithMinAggregateOutputType = {
    id: number | null
    name: string | null
    phone: string | null
    address: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GoldsmithMaxAggregateOutputType = {
    id: number | null
    name: string | null
    phone: string | null
    address: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GoldsmithCountAggregateOutputType = {
    id: number
    name: number
    phone: number
    address: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GoldsmithAvgAggregateInputType = {
    id?: true
  }

  export type GoldsmithSumAggregateInputType = {
    id?: true
  }

  export type GoldsmithMinAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    address?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GoldsmithMaxAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    address?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GoldsmithCountAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    address?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GoldsmithAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Goldsmith to aggregate.
     */
    where?: GoldsmithWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Goldsmiths to fetch.
     */
    orderBy?: GoldsmithOrderByWithRelationInput | GoldsmithOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GoldsmithWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Goldsmiths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Goldsmiths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Goldsmiths
    **/
    _count?: true | GoldsmithCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GoldsmithAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GoldsmithSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GoldsmithMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GoldsmithMaxAggregateInputType
  }

  export type GetGoldsmithAggregateType<T extends GoldsmithAggregateArgs> = {
        [P in keyof T & keyof AggregateGoldsmith]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGoldsmith[P]>
      : GetScalarType<T[P], AggregateGoldsmith[P]>
  }




  export type GoldsmithGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GoldsmithWhereInput
    orderBy?: GoldsmithOrderByWithAggregationInput | GoldsmithOrderByWithAggregationInput[]
    by: GoldsmithScalarFieldEnum[] | GoldsmithScalarFieldEnum
    having?: GoldsmithScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GoldsmithCountAggregateInputType | true
    _avg?: GoldsmithAvgAggregateInputType
    _sum?: GoldsmithSumAggregateInputType
    _min?: GoldsmithMinAggregateInputType
    _max?: GoldsmithMaxAggregateInputType
  }

  export type GoldsmithGroupByOutputType = {
    id: number
    name: string
    phone: string | null
    address: string | null
    createdAt: Date
    updatedAt: Date
    _count: GoldsmithCountAggregateOutputType | null
    _avg: GoldsmithAvgAggregateOutputType | null
    _sum: GoldsmithSumAggregateOutputType | null
    _min: GoldsmithMinAggregateOutputType | null
    _max: GoldsmithMaxAggregateOutputType | null
  }

  type GetGoldsmithGroupByPayload<T extends GoldsmithGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GoldsmithGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GoldsmithGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GoldsmithGroupByOutputType[P]>
            : GetScalarType<T[P], GoldsmithGroupByOutputType[P]>
        }
      >
    >


  export type GoldsmithSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    phone?: boolean
    address?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    jobcards?: boolean | Goldsmith$jobcardsArgs<ExtArgs>
    totals?: boolean | Goldsmith$totalsArgs<ExtArgs>
    givenGold?: boolean | Goldsmith$givenGoldArgs<ExtArgs>
    deliveries?: boolean | Goldsmith$deliveriesArgs<ExtArgs>
    received?: boolean | Goldsmith$receivedArgs<ExtArgs>
    repairs?: boolean | Goldsmith$repairsArgs<ExtArgs>
    summaries?: boolean | Goldsmith$summariesArgs<ExtArgs>
    _count?: boolean | GoldsmithCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["goldsmith"]>



  export type GoldsmithSelectScalar = {
    id?: boolean
    name?: boolean
    phone?: boolean
    address?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GoldsmithOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "phone" | "address" | "createdAt" | "updatedAt", ExtArgs["result"]["goldsmith"]>
  export type GoldsmithInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jobcards?: boolean | Goldsmith$jobcardsArgs<ExtArgs>
    totals?: boolean | Goldsmith$totalsArgs<ExtArgs>
    givenGold?: boolean | Goldsmith$givenGoldArgs<ExtArgs>
    deliveries?: boolean | Goldsmith$deliveriesArgs<ExtArgs>
    received?: boolean | Goldsmith$receivedArgs<ExtArgs>
    repairs?: boolean | Goldsmith$repairsArgs<ExtArgs>
    summaries?: boolean | Goldsmith$summariesArgs<ExtArgs>
    _count?: boolean | GoldsmithCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $GoldsmithPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Goldsmith"
    objects: {
      jobcards: Prisma.$JobcardPayload<ExtArgs>[]
      totals: Prisma.$TotalPayload<ExtArgs>[]
      givenGold: Prisma.$givenGoldPayload<ExtArgs>[]
      deliveries: Prisma.$itemDeliveryPayload<ExtArgs>[]
      received: Prisma.$ReceivedsectionPayload<ExtArgs>[]
      repairs: Prisma.$RepairPayload<ExtArgs>[]
      summaries: Prisma.$BalancesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      phone: string | null
      address: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["goldsmith"]>
    composites: {}
  }

  type GoldsmithGetPayload<S extends boolean | null | undefined | GoldsmithDefaultArgs> = $Result.GetResult<Prisma.$GoldsmithPayload, S>

  type GoldsmithCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GoldsmithFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GoldsmithCountAggregateInputType | true
    }

  export interface GoldsmithDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Goldsmith'], meta: { name: 'Goldsmith' } }
    /**
     * Find zero or one Goldsmith that matches the filter.
     * @param {GoldsmithFindUniqueArgs} args - Arguments to find a Goldsmith
     * @example
     * // Get one Goldsmith
     * const goldsmith = await prisma.goldsmith.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GoldsmithFindUniqueArgs>(args: SelectSubset<T, GoldsmithFindUniqueArgs<ExtArgs>>): Prisma__GoldsmithClient<$Result.GetResult<Prisma.$GoldsmithPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Goldsmith that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GoldsmithFindUniqueOrThrowArgs} args - Arguments to find a Goldsmith
     * @example
     * // Get one Goldsmith
     * const goldsmith = await prisma.goldsmith.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GoldsmithFindUniqueOrThrowArgs>(args: SelectSubset<T, GoldsmithFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GoldsmithClient<$Result.GetResult<Prisma.$GoldsmithPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Goldsmith that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoldsmithFindFirstArgs} args - Arguments to find a Goldsmith
     * @example
     * // Get one Goldsmith
     * const goldsmith = await prisma.goldsmith.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GoldsmithFindFirstArgs>(args?: SelectSubset<T, GoldsmithFindFirstArgs<ExtArgs>>): Prisma__GoldsmithClient<$Result.GetResult<Prisma.$GoldsmithPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Goldsmith that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoldsmithFindFirstOrThrowArgs} args - Arguments to find a Goldsmith
     * @example
     * // Get one Goldsmith
     * const goldsmith = await prisma.goldsmith.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GoldsmithFindFirstOrThrowArgs>(args?: SelectSubset<T, GoldsmithFindFirstOrThrowArgs<ExtArgs>>): Prisma__GoldsmithClient<$Result.GetResult<Prisma.$GoldsmithPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Goldsmiths that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoldsmithFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Goldsmiths
     * const goldsmiths = await prisma.goldsmith.findMany()
     * 
     * // Get first 10 Goldsmiths
     * const goldsmiths = await prisma.goldsmith.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const goldsmithWithIdOnly = await prisma.goldsmith.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GoldsmithFindManyArgs>(args?: SelectSubset<T, GoldsmithFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GoldsmithPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Goldsmith.
     * @param {GoldsmithCreateArgs} args - Arguments to create a Goldsmith.
     * @example
     * // Create one Goldsmith
     * const Goldsmith = await prisma.goldsmith.create({
     *   data: {
     *     // ... data to create a Goldsmith
     *   }
     * })
     * 
     */
    create<T extends GoldsmithCreateArgs>(args: SelectSubset<T, GoldsmithCreateArgs<ExtArgs>>): Prisma__GoldsmithClient<$Result.GetResult<Prisma.$GoldsmithPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Goldsmiths.
     * @param {GoldsmithCreateManyArgs} args - Arguments to create many Goldsmiths.
     * @example
     * // Create many Goldsmiths
     * const goldsmith = await prisma.goldsmith.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GoldsmithCreateManyArgs>(args?: SelectSubset<T, GoldsmithCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Goldsmith.
     * @param {GoldsmithDeleteArgs} args - Arguments to delete one Goldsmith.
     * @example
     * // Delete one Goldsmith
     * const Goldsmith = await prisma.goldsmith.delete({
     *   where: {
     *     // ... filter to delete one Goldsmith
     *   }
     * })
     * 
     */
    delete<T extends GoldsmithDeleteArgs>(args: SelectSubset<T, GoldsmithDeleteArgs<ExtArgs>>): Prisma__GoldsmithClient<$Result.GetResult<Prisma.$GoldsmithPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Goldsmith.
     * @param {GoldsmithUpdateArgs} args - Arguments to update one Goldsmith.
     * @example
     * // Update one Goldsmith
     * const goldsmith = await prisma.goldsmith.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GoldsmithUpdateArgs>(args: SelectSubset<T, GoldsmithUpdateArgs<ExtArgs>>): Prisma__GoldsmithClient<$Result.GetResult<Prisma.$GoldsmithPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Goldsmiths.
     * @param {GoldsmithDeleteManyArgs} args - Arguments to filter Goldsmiths to delete.
     * @example
     * // Delete a few Goldsmiths
     * const { count } = await prisma.goldsmith.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GoldsmithDeleteManyArgs>(args?: SelectSubset<T, GoldsmithDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Goldsmiths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoldsmithUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Goldsmiths
     * const goldsmith = await prisma.goldsmith.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GoldsmithUpdateManyArgs>(args: SelectSubset<T, GoldsmithUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Goldsmith.
     * @param {GoldsmithUpsertArgs} args - Arguments to update or create a Goldsmith.
     * @example
     * // Update or create a Goldsmith
     * const goldsmith = await prisma.goldsmith.upsert({
     *   create: {
     *     // ... data to create a Goldsmith
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Goldsmith we want to update
     *   }
     * })
     */
    upsert<T extends GoldsmithUpsertArgs>(args: SelectSubset<T, GoldsmithUpsertArgs<ExtArgs>>): Prisma__GoldsmithClient<$Result.GetResult<Prisma.$GoldsmithPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Goldsmiths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoldsmithCountArgs} args - Arguments to filter Goldsmiths to count.
     * @example
     * // Count the number of Goldsmiths
     * const count = await prisma.goldsmith.count({
     *   where: {
     *     // ... the filter for the Goldsmiths we want to count
     *   }
     * })
    **/
    count<T extends GoldsmithCountArgs>(
      args?: Subset<T, GoldsmithCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GoldsmithCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Goldsmith.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoldsmithAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GoldsmithAggregateArgs>(args: Subset<T, GoldsmithAggregateArgs>): Prisma.PrismaPromise<GetGoldsmithAggregateType<T>>

    /**
     * Group by Goldsmith.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoldsmithGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GoldsmithGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GoldsmithGroupByArgs['orderBy'] }
        : { orderBy?: GoldsmithGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GoldsmithGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGoldsmithGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Goldsmith model
   */
  readonly fields: GoldsmithFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Goldsmith.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GoldsmithClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    jobcards<T extends Goldsmith$jobcardsArgs<ExtArgs> = {}>(args?: Subset<T, Goldsmith$jobcardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobcardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    totals<T extends Goldsmith$totalsArgs<ExtArgs> = {}>(args?: Subset<T, Goldsmith$totalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TotalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    givenGold<T extends Goldsmith$givenGoldArgs<ExtArgs> = {}>(args?: Subset<T, Goldsmith$givenGoldArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$givenGoldPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    deliveries<T extends Goldsmith$deliveriesArgs<ExtArgs> = {}>(args?: Subset<T, Goldsmith$deliveriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$itemDeliveryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    received<T extends Goldsmith$receivedArgs<ExtArgs> = {}>(args?: Subset<T, Goldsmith$receivedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReceivedsectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    repairs<T extends Goldsmith$repairsArgs<ExtArgs> = {}>(args?: Subset<T, Goldsmith$repairsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RepairPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    summaries<T extends Goldsmith$summariesArgs<ExtArgs> = {}>(args?: Subset<T, Goldsmith$summariesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BalancesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Goldsmith model
   */
  interface GoldsmithFieldRefs {
    readonly id: FieldRef<"Goldsmith", 'Int'>
    readonly name: FieldRef<"Goldsmith", 'String'>
    readonly phone: FieldRef<"Goldsmith", 'String'>
    readonly address: FieldRef<"Goldsmith", 'String'>
    readonly createdAt: FieldRef<"Goldsmith", 'DateTime'>
    readonly updatedAt: FieldRef<"Goldsmith", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Goldsmith findUnique
   */
  export type GoldsmithFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goldsmith
     */
    select?: GoldsmithSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Goldsmith
     */
    omit?: GoldsmithOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoldsmithInclude<ExtArgs> | null
    /**
     * Filter, which Goldsmith to fetch.
     */
    where: GoldsmithWhereUniqueInput
  }

  /**
   * Goldsmith findUniqueOrThrow
   */
  export type GoldsmithFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goldsmith
     */
    select?: GoldsmithSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Goldsmith
     */
    omit?: GoldsmithOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoldsmithInclude<ExtArgs> | null
    /**
     * Filter, which Goldsmith to fetch.
     */
    where: GoldsmithWhereUniqueInput
  }

  /**
   * Goldsmith findFirst
   */
  export type GoldsmithFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goldsmith
     */
    select?: GoldsmithSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Goldsmith
     */
    omit?: GoldsmithOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoldsmithInclude<ExtArgs> | null
    /**
     * Filter, which Goldsmith to fetch.
     */
    where?: GoldsmithWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Goldsmiths to fetch.
     */
    orderBy?: GoldsmithOrderByWithRelationInput | GoldsmithOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Goldsmiths.
     */
    cursor?: GoldsmithWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Goldsmiths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Goldsmiths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Goldsmiths.
     */
    distinct?: GoldsmithScalarFieldEnum | GoldsmithScalarFieldEnum[]
  }

  /**
   * Goldsmith findFirstOrThrow
   */
  export type GoldsmithFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goldsmith
     */
    select?: GoldsmithSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Goldsmith
     */
    omit?: GoldsmithOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoldsmithInclude<ExtArgs> | null
    /**
     * Filter, which Goldsmith to fetch.
     */
    where?: GoldsmithWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Goldsmiths to fetch.
     */
    orderBy?: GoldsmithOrderByWithRelationInput | GoldsmithOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Goldsmiths.
     */
    cursor?: GoldsmithWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Goldsmiths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Goldsmiths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Goldsmiths.
     */
    distinct?: GoldsmithScalarFieldEnum | GoldsmithScalarFieldEnum[]
  }

  /**
   * Goldsmith findMany
   */
  export type GoldsmithFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goldsmith
     */
    select?: GoldsmithSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Goldsmith
     */
    omit?: GoldsmithOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoldsmithInclude<ExtArgs> | null
    /**
     * Filter, which Goldsmiths to fetch.
     */
    where?: GoldsmithWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Goldsmiths to fetch.
     */
    orderBy?: GoldsmithOrderByWithRelationInput | GoldsmithOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Goldsmiths.
     */
    cursor?: GoldsmithWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Goldsmiths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Goldsmiths.
     */
    skip?: number
    distinct?: GoldsmithScalarFieldEnum | GoldsmithScalarFieldEnum[]
  }

  /**
   * Goldsmith create
   */
  export type GoldsmithCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goldsmith
     */
    select?: GoldsmithSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Goldsmith
     */
    omit?: GoldsmithOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoldsmithInclude<ExtArgs> | null
    /**
     * The data needed to create a Goldsmith.
     */
    data: XOR<GoldsmithCreateInput, GoldsmithUncheckedCreateInput>
  }

  /**
   * Goldsmith createMany
   */
  export type GoldsmithCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Goldsmiths.
     */
    data: GoldsmithCreateManyInput | GoldsmithCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Goldsmith update
   */
  export type GoldsmithUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goldsmith
     */
    select?: GoldsmithSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Goldsmith
     */
    omit?: GoldsmithOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoldsmithInclude<ExtArgs> | null
    /**
     * The data needed to update a Goldsmith.
     */
    data: XOR<GoldsmithUpdateInput, GoldsmithUncheckedUpdateInput>
    /**
     * Choose, which Goldsmith to update.
     */
    where: GoldsmithWhereUniqueInput
  }

  /**
   * Goldsmith updateMany
   */
  export type GoldsmithUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Goldsmiths.
     */
    data: XOR<GoldsmithUpdateManyMutationInput, GoldsmithUncheckedUpdateManyInput>
    /**
     * Filter which Goldsmiths to update
     */
    where?: GoldsmithWhereInput
    /**
     * Limit how many Goldsmiths to update.
     */
    limit?: number
  }

  /**
   * Goldsmith upsert
   */
  export type GoldsmithUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goldsmith
     */
    select?: GoldsmithSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Goldsmith
     */
    omit?: GoldsmithOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoldsmithInclude<ExtArgs> | null
    /**
     * The filter to search for the Goldsmith to update in case it exists.
     */
    where: GoldsmithWhereUniqueInput
    /**
     * In case the Goldsmith found by the `where` argument doesn't exist, create a new Goldsmith with this data.
     */
    create: XOR<GoldsmithCreateInput, GoldsmithUncheckedCreateInput>
    /**
     * In case the Goldsmith was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GoldsmithUpdateInput, GoldsmithUncheckedUpdateInput>
  }

  /**
   * Goldsmith delete
   */
  export type GoldsmithDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goldsmith
     */
    select?: GoldsmithSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Goldsmith
     */
    omit?: GoldsmithOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoldsmithInclude<ExtArgs> | null
    /**
     * Filter which Goldsmith to delete.
     */
    where: GoldsmithWhereUniqueInput
  }

  /**
   * Goldsmith deleteMany
   */
  export type GoldsmithDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Goldsmiths to delete
     */
    where?: GoldsmithWhereInput
    /**
     * Limit how many Goldsmiths to delete.
     */
    limit?: number
  }

  /**
   * Goldsmith.jobcards
   */
  export type Goldsmith$jobcardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobcard
     */
    select?: JobcardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Jobcard
     */
    omit?: JobcardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobcardInclude<ExtArgs> | null
    where?: JobcardWhereInput
    orderBy?: JobcardOrderByWithRelationInput | JobcardOrderByWithRelationInput[]
    cursor?: JobcardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobcardScalarFieldEnum | JobcardScalarFieldEnum[]
  }

  /**
   * Goldsmith.totals
   */
  export type Goldsmith$totalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Total
     */
    select?: TotalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Total
     */
    omit?: TotalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TotalInclude<ExtArgs> | null
    where?: TotalWhereInput
    orderBy?: TotalOrderByWithRelationInput | TotalOrderByWithRelationInput[]
    cursor?: TotalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TotalScalarFieldEnum | TotalScalarFieldEnum[]
  }

  /**
   * Goldsmith.givenGold
   */
  export type Goldsmith$givenGoldArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the givenGold
     */
    select?: givenGoldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the givenGold
     */
    omit?: givenGoldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: givenGoldInclude<ExtArgs> | null
    where?: givenGoldWhereInput
    orderBy?: givenGoldOrderByWithRelationInput | givenGoldOrderByWithRelationInput[]
    cursor?: givenGoldWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GivenGoldScalarFieldEnum | GivenGoldScalarFieldEnum[]
  }

  /**
   * Goldsmith.deliveries
   */
  export type Goldsmith$deliveriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the itemDelivery
     */
    select?: itemDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the itemDelivery
     */
    omit?: itemDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemDeliveryInclude<ExtArgs> | null
    where?: itemDeliveryWhereInput
    orderBy?: itemDeliveryOrderByWithRelationInput | itemDeliveryOrderByWithRelationInput[]
    cursor?: itemDeliveryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemDeliveryScalarFieldEnum | ItemDeliveryScalarFieldEnum[]
  }

  /**
   * Goldsmith.received
   */
  export type Goldsmith$receivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receivedsection
     */
    select?: ReceivedsectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Receivedsection
     */
    omit?: ReceivedsectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceivedsectionInclude<ExtArgs> | null
    where?: ReceivedsectionWhereInput
    orderBy?: ReceivedsectionOrderByWithRelationInput | ReceivedsectionOrderByWithRelationInput[]
    cursor?: ReceivedsectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReceivedsectionScalarFieldEnum | ReceivedsectionScalarFieldEnum[]
  }

  /**
   * Goldsmith.repairs
   */
  export type Goldsmith$repairsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Repair
     */
    select?: RepairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Repair
     */
    omit?: RepairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepairInclude<ExtArgs> | null
    where?: RepairWhereInput
    orderBy?: RepairOrderByWithRelationInput | RepairOrderByWithRelationInput[]
    cursor?: RepairWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RepairScalarFieldEnum | RepairScalarFieldEnum[]
  }

  /**
   * Goldsmith.summaries
   */
  export type Goldsmith$summariesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Balances
     */
    select?: BalancesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Balances
     */
    omit?: BalancesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalancesInclude<ExtArgs> | null
    where?: BalancesWhereInput
    orderBy?: BalancesOrderByWithRelationInput | BalancesOrderByWithRelationInput[]
    cursor?: BalancesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BalancesScalarFieldEnum | BalancesScalarFieldEnum[]
  }

  /**
   * Goldsmith without action
   */
  export type GoldsmithDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goldsmith
     */
    select?: GoldsmithSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Goldsmith
     */
    omit?: GoldsmithOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoldsmithInclude<ExtArgs> | null
  }


  /**
   * Model Jobcard
   */

  export type AggregateJobcard = {
    _count: JobcardCountAggregateOutputType | null
    _avg: JobcardAvgAggregateOutputType | null
    _sum: JobcardSumAggregateOutputType | null
    _min: JobcardMinAggregateOutputType | null
    _max: JobcardMaxAggregateOutputType | null
  }

  export type JobcardAvgAggregateOutputType = {
    id: number | null
    goldsmithId: number | null
  }

  export type JobcardSumAggregateOutputType = {
    id: number | null
    goldsmithId: number | null
  }

  export type JobcardMinAggregateOutputType = {
    id: number | null
    goldsmithId: number | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type JobcardMaxAggregateOutputType = {
    id: number | null
    goldsmithId: number | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type JobcardCountAggregateOutputType = {
    id: number
    goldsmithId: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type JobcardAvgAggregateInputType = {
    id?: true
    goldsmithId?: true
  }

  export type JobcardSumAggregateInputType = {
    id?: true
    goldsmithId?: true
  }

  export type JobcardMinAggregateInputType = {
    id?: true
    goldsmithId?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type JobcardMaxAggregateInputType = {
    id?: true
    goldsmithId?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type JobcardCountAggregateInputType = {
    id?: true
    goldsmithId?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type JobcardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Jobcard to aggregate.
     */
    where?: JobcardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Jobcards to fetch.
     */
    orderBy?: JobcardOrderByWithRelationInput | JobcardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JobcardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Jobcards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Jobcards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Jobcards
    **/
    _count?: true | JobcardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JobcardAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JobcardSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JobcardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JobcardMaxAggregateInputType
  }

  export type GetJobcardAggregateType<T extends JobcardAggregateArgs> = {
        [P in keyof T & keyof AggregateJobcard]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJobcard[P]>
      : GetScalarType<T[P], AggregateJobcard[P]>
  }




  export type JobcardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobcardWhereInput
    orderBy?: JobcardOrderByWithAggregationInput | JobcardOrderByWithAggregationInput[]
    by: JobcardScalarFieldEnum[] | JobcardScalarFieldEnum
    having?: JobcardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JobcardCountAggregateInputType | true
    _avg?: JobcardAvgAggregateInputType
    _sum?: JobcardSumAggregateInputType
    _min?: JobcardMinAggregateInputType
    _max?: JobcardMaxAggregateInputType
  }

  export type JobcardGroupByOutputType = {
    id: number
    goldsmithId: number
    description: string
    createdAt: Date
    updatedAt: Date
    _count: JobcardCountAggregateOutputType | null
    _avg: JobcardAvgAggregateOutputType | null
    _sum: JobcardSumAggregateOutputType | null
    _min: JobcardMinAggregateOutputType | null
    _max: JobcardMaxAggregateOutputType | null
  }

  type GetJobcardGroupByPayload<T extends JobcardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JobcardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JobcardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JobcardGroupByOutputType[P]>
            : GetScalarType<T[P], JobcardGroupByOutputType[P]>
        }
      >
    >


  export type JobcardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    goldsmithId?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    goldsmith?: boolean | GoldsmithDefaultArgs<ExtArgs>
    givenGold?: boolean | Jobcard$givenGoldArgs<ExtArgs>
    deliveries?: boolean | Jobcard$deliveriesArgs<ExtArgs>
    received?: boolean | Jobcard$receivedArgs<ExtArgs>
    _count?: boolean | JobcardCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobcard"]>



  export type JobcardSelectScalar = {
    id?: boolean
    goldsmithId?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type JobcardOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "goldsmithId" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["jobcard"]>
  export type JobcardInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    goldsmith?: boolean | GoldsmithDefaultArgs<ExtArgs>
    givenGold?: boolean | Jobcard$givenGoldArgs<ExtArgs>
    deliveries?: boolean | Jobcard$deliveriesArgs<ExtArgs>
    received?: boolean | Jobcard$receivedArgs<ExtArgs>
    _count?: boolean | JobcardCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $JobcardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Jobcard"
    objects: {
      goldsmith: Prisma.$GoldsmithPayload<ExtArgs>
      givenGold: Prisma.$givenGoldPayload<ExtArgs>[]
      deliveries: Prisma.$itemDeliveryPayload<ExtArgs>[]
      received: Prisma.$ReceivedsectionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      goldsmithId: number
      description: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["jobcard"]>
    composites: {}
  }

  type JobcardGetPayload<S extends boolean | null | undefined | JobcardDefaultArgs> = $Result.GetResult<Prisma.$JobcardPayload, S>

  type JobcardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<JobcardFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JobcardCountAggregateInputType | true
    }

  export interface JobcardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Jobcard'], meta: { name: 'Jobcard' } }
    /**
     * Find zero or one Jobcard that matches the filter.
     * @param {JobcardFindUniqueArgs} args - Arguments to find a Jobcard
     * @example
     * // Get one Jobcard
     * const jobcard = await prisma.jobcard.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JobcardFindUniqueArgs>(args: SelectSubset<T, JobcardFindUniqueArgs<ExtArgs>>): Prisma__JobcardClient<$Result.GetResult<Prisma.$JobcardPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Jobcard that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {JobcardFindUniqueOrThrowArgs} args - Arguments to find a Jobcard
     * @example
     * // Get one Jobcard
     * const jobcard = await prisma.jobcard.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JobcardFindUniqueOrThrowArgs>(args: SelectSubset<T, JobcardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JobcardClient<$Result.GetResult<Prisma.$JobcardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Jobcard that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobcardFindFirstArgs} args - Arguments to find a Jobcard
     * @example
     * // Get one Jobcard
     * const jobcard = await prisma.jobcard.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JobcardFindFirstArgs>(args?: SelectSubset<T, JobcardFindFirstArgs<ExtArgs>>): Prisma__JobcardClient<$Result.GetResult<Prisma.$JobcardPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Jobcard that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobcardFindFirstOrThrowArgs} args - Arguments to find a Jobcard
     * @example
     * // Get one Jobcard
     * const jobcard = await prisma.jobcard.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JobcardFindFirstOrThrowArgs>(args?: SelectSubset<T, JobcardFindFirstOrThrowArgs<ExtArgs>>): Prisma__JobcardClient<$Result.GetResult<Prisma.$JobcardPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Jobcards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobcardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Jobcards
     * const jobcards = await prisma.jobcard.findMany()
     * 
     * // Get first 10 Jobcards
     * const jobcards = await prisma.jobcard.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const jobcardWithIdOnly = await prisma.jobcard.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JobcardFindManyArgs>(args?: SelectSubset<T, JobcardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobcardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Jobcard.
     * @param {JobcardCreateArgs} args - Arguments to create a Jobcard.
     * @example
     * // Create one Jobcard
     * const Jobcard = await prisma.jobcard.create({
     *   data: {
     *     // ... data to create a Jobcard
     *   }
     * })
     * 
     */
    create<T extends JobcardCreateArgs>(args: SelectSubset<T, JobcardCreateArgs<ExtArgs>>): Prisma__JobcardClient<$Result.GetResult<Prisma.$JobcardPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Jobcards.
     * @param {JobcardCreateManyArgs} args - Arguments to create many Jobcards.
     * @example
     * // Create many Jobcards
     * const jobcard = await prisma.jobcard.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JobcardCreateManyArgs>(args?: SelectSubset<T, JobcardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Jobcard.
     * @param {JobcardDeleteArgs} args - Arguments to delete one Jobcard.
     * @example
     * // Delete one Jobcard
     * const Jobcard = await prisma.jobcard.delete({
     *   where: {
     *     // ... filter to delete one Jobcard
     *   }
     * })
     * 
     */
    delete<T extends JobcardDeleteArgs>(args: SelectSubset<T, JobcardDeleteArgs<ExtArgs>>): Prisma__JobcardClient<$Result.GetResult<Prisma.$JobcardPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Jobcard.
     * @param {JobcardUpdateArgs} args - Arguments to update one Jobcard.
     * @example
     * // Update one Jobcard
     * const jobcard = await prisma.jobcard.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JobcardUpdateArgs>(args: SelectSubset<T, JobcardUpdateArgs<ExtArgs>>): Prisma__JobcardClient<$Result.GetResult<Prisma.$JobcardPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Jobcards.
     * @param {JobcardDeleteManyArgs} args - Arguments to filter Jobcards to delete.
     * @example
     * // Delete a few Jobcards
     * const { count } = await prisma.jobcard.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JobcardDeleteManyArgs>(args?: SelectSubset<T, JobcardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Jobcards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobcardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Jobcards
     * const jobcard = await prisma.jobcard.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JobcardUpdateManyArgs>(args: SelectSubset<T, JobcardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Jobcard.
     * @param {JobcardUpsertArgs} args - Arguments to update or create a Jobcard.
     * @example
     * // Update or create a Jobcard
     * const jobcard = await prisma.jobcard.upsert({
     *   create: {
     *     // ... data to create a Jobcard
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Jobcard we want to update
     *   }
     * })
     */
    upsert<T extends JobcardUpsertArgs>(args: SelectSubset<T, JobcardUpsertArgs<ExtArgs>>): Prisma__JobcardClient<$Result.GetResult<Prisma.$JobcardPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Jobcards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobcardCountArgs} args - Arguments to filter Jobcards to count.
     * @example
     * // Count the number of Jobcards
     * const count = await prisma.jobcard.count({
     *   where: {
     *     // ... the filter for the Jobcards we want to count
     *   }
     * })
    **/
    count<T extends JobcardCountArgs>(
      args?: Subset<T, JobcardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JobcardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Jobcard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobcardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JobcardAggregateArgs>(args: Subset<T, JobcardAggregateArgs>): Prisma.PrismaPromise<GetJobcardAggregateType<T>>

    /**
     * Group by Jobcard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobcardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JobcardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JobcardGroupByArgs['orderBy'] }
        : { orderBy?: JobcardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JobcardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJobcardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Jobcard model
   */
  readonly fields: JobcardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Jobcard.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JobcardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    goldsmith<T extends GoldsmithDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GoldsmithDefaultArgs<ExtArgs>>): Prisma__GoldsmithClient<$Result.GetResult<Prisma.$GoldsmithPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    givenGold<T extends Jobcard$givenGoldArgs<ExtArgs> = {}>(args?: Subset<T, Jobcard$givenGoldArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$givenGoldPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    deliveries<T extends Jobcard$deliveriesArgs<ExtArgs> = {}>(args?: Subset<T, Jobcard$deliveriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$itemDeliveryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    received<T extends Jobcard$receivedArgs<ExtArgs> = {}>(args?: Subset<T, Jobcard$receivedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReceivedsectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Jobcard model
   */
  interface JobcardFieldRefs {
    readonly id: FieldRef<"Jobcard", 'Int'>
    readonly goldsmithId: FieldRef<"Jobcard", 'Int'>
    readonly description: FieldRef<"Jobcard", 'String'>
    readonly createdAt: FieldRef<"Jobcard", 'DateTime'>
    readonly updatedAt: FieldRef<"Jobcard", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Jobcard findUnique
   */
  export type JobcardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobcard
     */
    select?: JobcardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Jobcard
     */
    omit?: JobcardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobcardInclude<ExtArgs> | null
    /**
     * Filter, which Jobcard to fetch.
     */
    where: JobcardWhereUniqueInput
  }

  /**
   * Jobcard findUniqueOrThrow
   */
  export type JobcardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobcard
     */
    select?: JobcardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Jobcard
     */
    omit?: JobcardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobcardInclude<ExtArgs> | null
    /**
     * Filter, which Jobcard to fetch.
     */
    where: JobcardWhereUniqueInput
  }

  /**
   * Jobcard findFirst
   */
  export type JobcardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobcard
     */
    select?: JobcardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Jobcard
     */
    omit?: JobcardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobcardInclude<ExtArgs> | null
    /**
     * Filter, which Jobcard to fetch.
     */
    where?: JobcardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Jobcards to fetch.
     */
    orderBy?: JobcardOrderByWithRelationInput | JobcardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Jobcards.
     */
    cursor?: JobcardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Jobcards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Jobcards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Jobcards.
     */
    distinct?: JobcardScalarFieldEnum | JobcardScalarFieldEnum[]
  }

  /**
   * Jobcard findFirstOrThrow
   */
  export type JobcardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobcard
     */
    select?: JobcardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Jobcard
     */
    omit?: JobcardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobcardInclude<ExtArgs> | null
    /**
     * Filter, which Jobcard to fetch.
     */
    where?: JobcardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Jobcards to fetch.
     */
    orderBy?: JobcardOrderByWithRelationInput | JobcardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Jobcards.
     */
    cursor?: JobcardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Jobcards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Jobcards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Jobcards.
     */
    distinct?: JobcardScalarFieldEnum | JobcardScalarFieldEnum[]
  }

  /**
   * Jobcard findMany
   */
  export type JobcardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobcard
     */
    select?: JobcardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Jobcard
     */
    omit?: JobcardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobcardInclude<ExtArgs> | null
    /**
     * Filter, which Jobcards to fetch.
     */
    where?: JobcardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Jobcards to fetch.
     */
    orderBy?: JobcardOrderByWithRelationInput | JobcardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Jobcards.
     */
    cursor?: JobcardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Jobcards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Jobcards.
     */
    skip?: number
    distinct?: JobcardScalarFieldEnum | JobcardScalarFieldEnum[]
  }

  /**
   * Jobcard create
   */
  export type JobcardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobcard
     */
    select?: JobcardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Jobcard
     */
    omit?: JobcardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobcardInclude<ExtArgs> | null
    /**
     * The data needed to create a Jobcard.
     */
    data: XOR<JobcardCreateInput, JobcardUncheckedCreateInput>
  }

  /**
   * Jobcard createMany
   */
  export type JobcardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Jobcards.
     */
    data: JobcardCreateManyInput | JobcardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Jobcard update
   */
  export type JobcardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobcard
     */
    select?: JobcardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Jobcard
     */
    omit?: JobcardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobcardInclude<ExtArgs> | null
    /**
     * The data needed to update a Jobcard.
     */
    data: XOR<JobcardUpdateInput, JobcardUncheckedUpdateInput>
    /**
     * Choose, which Jobcard to update.
     */
    where: JobcardWhereUniqueInput
  }

  /**
   * Jobcard updateMany
   */
  export type JobcardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Jobcards.
     */
    data: XOR<JobcardUpdateManyMutationInput, JobcardUncheckedUpdateManyInput>
    /**
     * Filter which Jobcards to update
     */
    where?: JobcardWhereInput
    /**
     * Limit how many Jobcards to update.
     */
    limit?: number
  }

  /**
   * Jobcard upsert
   */
  export type JobcardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobcard
     */
    select?: JobcardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Jobcard
     */
    omit?: JobcardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobcardInclude<ExtArgs> | null
    /**
     * The filter to search for the Jobcard to update in case it exists.
     */
    where: JobcardWhereUniqueInput
    /**
     * In case the Jobcard found by the `where` argument doesn't exist, create a new Jobcard with this data.
     */
    create: XOR<JobcardCreateInput, JobcardUncheckedCreateInput>
    /**
     * In case the Jobcard was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JobcardUpdateInput, JobcardUncheckedUpdateInput>
  }

  /**
   * Jobcard delete
   */
  export type JobcardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobcard
     */
    select?: JobcardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Jobcard
     */
    omit?: JobcardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobcardInclude<ExtArgs> | null
    /**
     * Filter which Jobcard to delete.
     */
    where: JobcardWhereUniqueInput
  }

  /**
   * Jobcard deleteMany
   */
  export type JobcardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Jobcards to delete
     */
    where?: JobcardWhereInput
    /**
     * Limit how many Jobcards to delete.
     */
    limit?: number
  }

  /**
   * Jobcard.givenGold
   */
  export type Jobcard$givenGoldArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the givenGold
     */
    select?: givenGoldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the givenGold
     */
    omit?: givenGoldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: givenGoldInclude<ExtArgs> | null
    where?: givenGoldWhereInput
    orderBy?: givenGoldOrderByWithRelationInput | givenGoldOrderByWithRelationInput[]
    cursor?: givenGoldWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GivenGoldScalarFieldEnum | GivenGoldScalarFieldEnum[]
  }

  /**
   * Jobcard.deliveries
   */
  export type Jobcard$deliveriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the itemDelivery
     */
    select?: itemDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the itemDelivery
     */
    omit?: itemDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemDeliveryInclude<ExtArgs> | null
    where?: itemDeliveryWhereInput
    orderBy?: itemDeliveryOrderByWithRelationInput | itemDeliveryOrderByWithRelationInput[]
    cursor?: itemDeliveryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemDeliveryScalarFieldEnum | ItemDeliveryScalarFieldEnum[]
  }

  /**
   * Jobcard.received
   */
  export type Jobcard$receivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receivedsection
     */
    select?: ReceivedsectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Receivedsection
     */
    omit?: ReceivedsectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceivedsectionInclude<ExtArgs> | null
    where?: ReceivedsectionWhereInput
    orderBy?: ReceivedsectionOrderByWithRelationInput | ReceivedsectionOrderByWithRelationInput[]
    cursor?: ReceivedsectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReceivedsectionScalarFieldEnum | ReceivedsectionScalarFieldEnum[]
  }

  /**
   * Jobcard without action
   */
  export type JobcardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobcard
     */
    select?: JobcardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Jobcard
     */
    omit?: JobcardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobcardInclude<ExtArgs> | null
  }


  /**
   * Model givenGold
   */

  export type AggregateGivenGold = {
    _count: GivenGoldCountAggregateOutputType | null
    _avg: GivenGoldAvgAggregateOutputType | null
    _sum: GivenGoldSumAggregateOutputType | null
    _min: GivenGoldMinAggregateOutputType | null
    _max: GivenGoldMaxAggregateOutputType | null
  }

  export type GivenGoldAvgAggregateOutputType = {
    id: number | null
    goldsmithId: number | null
    jobcardId: number | null
    weight: number | null
    touch: number | null
    purity: number | null
  }

  export type GivenGoldSumAggregateOutputType = {
    id: number | null
    goldsmithId: number | null
    jobcardId: number | null
    weight: number | null
    touch: number | null
    purity: number | null
  }

  export type GivenGoldMinAggregateOutputType = {
    id: number | null
    goldsmithId: number | null
    jobcardId: number | null
    weight: number | null
    touch: number | null
    purity: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GivenGoldMaxAggregateOutputType = {
    id: number | null
    goldsmithId: number | null
    jobcardId: number | null
    weight: number | null
    touch: number | null
    purity: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GivenGoldCountAggregateOutputType = {
    id: number
    goldsmithId: number
    jobcardId: number
    weight: number
    touch: number
    purity: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GivenGoldAvgAggregateInputType = {
    id?: true
    goldsmithId?: true
    jobcardId?: true
    weight?: true
    touch?: true
    purity?: true
  }

  export type GivenGoldSumAggregateInputType = {
    id?: true
    goldsmithId?: true
    jobcardId?: true
    weight?: true
    touch?: true
    purity?: true
  }

  export type GivenGoldMinAggregateInputType = {
    id?: true
    goldsmithId?: true
    jobcardId?: true
    weight?: true
    touch?: true
    purity?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GivenGoldMaxAggregateInputType = {
    id?: true
    goldsmithId?: true
    jobcardId?: true
    weight?: true
    touch?: true
    purity?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GivenGoldCountAggregateInputType = {
    id?: true
    goldsmithId?: true
    jobcardId?: true
    weight?: true
    touch?: true
    purity?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GivenGoldAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which givenGold to aggregate.
     */
    where?: givenGoldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of givenGolds to fetch.
     */
    orderBy?: givenGoldOrderByWithRelationInput | givenGoldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: givenGoldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` givenGolds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` givenGolds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned givenGolds
    **/
    _count?: true | GivenGoldCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GivenGoldAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GivenGoldSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GivenGoldMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GivenGoldMaxAggregateInputType
  }

  export type GetGivenGoldAggregateType<T extends GivenGoldAggregateArgs> = {
        [P in keyof T & keyof AggregateGivenGold]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGivenGold[P]>
      : GetScalarType<T[P], AggregateGivenGold[P]>
  }




  export type givenGoldGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: givenGoldWhereInput
    orderBy?: givenGoldOrderByWithAggregationInput | givenGoldOrderByWithAggregationInput[]
    by: GivenGoldScalarFieldEnum[] | GivenGoldScalarFieldEnum
    having?: givenGoldScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GivenGoldCountAggregateInputType | true
    _avg?: GivenGoldAvgAggregateInputType
    _sum?: GivenGoldSumAggregateInputType
    _min?: GivenGoldMinAggregateInputType
    _max?: GivenGoldMaxAggregateInputType
  }

  export type GivenGoldGroupByOutputType = {
    id: number
    goldsmithId: number | null
    jobcardId: number | null
    weight: number
    touch: number
    purity: number
    createdAt: Date
    updatedAt: Date
    _count: GivenGoldCountAggregateOutputType | null
    _avg: GivenGoldAvgAggregateOutputType | null
    _sum: GivenGoldSumAggregateOutputType | null
    _min: GivenGoldMinAggregateOutputType | null
    _max: GivenGoldMaxAggregateOutputType | null
  }

  type GetGivenGoldGroupByPayload<T extends givenGoldGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GivenGoldGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GivenGoldGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GivenGoldGroupByOutputType[P]>
            : GetScalarType<T[P], GivenGoldGroupByOutputType[P]>
        }
      >
    >


  export type givenGoldSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    goldsmithId?: boolean
    jobcardId?: boolean
    weight?: boolean
    touch?: boolean
    purity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    goldsmith?: boolean | givenGold$goldsmithArgs<ExtArgs>
    jobcard?: boolean | givenGold$jobcardArgs<ExtArgs>
  }, ExtArgs["result"]["givenGold"]>



  export type givenGoldSelectScalar = {
    id?: boolean
    goldsmithId?: boolean
    jobcardId?: boolean
    weight?: boolean
    touch?: boolean
    purity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type givenGoldOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "goldsmithId" | "jobcardId" | "weight" | "touch" | "purity" | "createdAt" | "updatedAt", ExtArgs["result"]["givenGold"]>
  export type givenGoldInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    goldsmith?: boolean | givenGold$goldsmithArgs<ExtArgs>
    jobcard?: boolean | givenGold$jobcardArgs<ExtArgs>
  }

  export type $givenGoldPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "givenGold"
    objects: {
      goldsmith: Prisma.$GoldsmithPayload<ExtArgs> | null
      jobcard: Prisma.$JobcardPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      goldsmithId: number | null
      jobcardId: number | null
      weight: number
      touch: number
      purity: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["givenGold"]>
    composites: {}
  }

  type givenGoldGetPayload<S extends boolean | null | undefined | givenGoldDefaultArgs> = $Result.GetResult<Prisma.$givenGoldPayload, S>

  type givenGoldCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<givenGoldFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GivenGoldCountAggregateInputType | true
    }

  export interface givenGoldDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['givenGold'], meta: { name: 'givenGold' } }
    /**
     * Find zero or one GivenGold that matches the filter.
     * @param {givenGoldFindUniqueArgs} args - Arguments to find a GivenGold
     * @example
     * // Get one GivenGold
     * const givenGold = await prisma.givenGold.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends givenGoldFindUniqueArgs>(args: SelectSubset<T, givenGoldFindUniqueArgs<ExtArgs>>): Prisma__givenGoldClient<$Result.GetResult<Prisma.$givenGoldPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GivenGold that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {givenGoldFindUniqueOrThrowArgs} args - Arguments to find a GivenGold
     * @example
     * // Get one GivenGold
     * const givenGold = await prisma.givenGold.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends givenGoldFindUniqueOrThrowArgs>(args: SelectSubset<T, givenGoldFindUniqueOrThrowArgs<ExtArgs>>): Prisma__givenGoldClient<$Result.GetResult<Prisma.$givenGoldPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GivenGold that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {givenGoldFindFirstArgs} args - Arguments to find a GivenGold
     * @example
     * // Get one GivenGold
     * const givenGold = await prisma.givenGold.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends givenGoldFindFirstArgs>(args?: SelectSubset<T, givenGoldFindFirstArgs<ExtArgs>>): Prisma__givenGoldClient<$Result.GetResult<Prisma.$givenGoldPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GivenGold that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {givenGoldFindFirstOrThrowArgs} args - Arguments to find a GivenGold
     * @example
     * // Get one GivenGold
     * const givenGold = await prisma.givenGold.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends givenGoldFindFirstOrThrowArgs>(args?: SelectSubset<T, givenGoldFindFirstOrThrowArgs<ExtArgs>>): Prisma__givenGoldClient<$Result.GetResult<Prisma.$givenGoldPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GivenGolds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {givenGoldFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GivenGolds
     * const givenGolds = await prisma.givenGold.findMany()
     * 
     * // Get first 10 GivenGolds
     * const givenGolds = await prisma.givenGold.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const givenGoldWithIdOnly = await prisma.givenGold.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends givenGoldFindManyArgs>(args?: SelectSubset<T, givenGoldFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$givenGoldPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GivenGold.
     * @param {givenGoldCreateArgs} args - Arguments to create a GivenGold.
     * @example
     * // Create one GivenGold
     * const GivenGold = await prisma.givenGold.create({
     *   data: {
     *     // ... data to create a GivenGold
     *   }
     * })
     * 
     */
    create<T extends givenGoldCreateArgs>(args: SelectSubset<T, givenGoldCreateArgs<ExtArgs>>): Prisma__givenGoldClient<$Result.GetResult<Prisma.$givenGoldPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GivenGolds.
     * @param {givenGoldCreateManyArgs} args - Arguments to create many GivenGolds.
     * @example
     * // Create many GivenGolds
     * const givenGold = await prisma.givenGold.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends givenGoldCreateManyArgs>(args?: SelectSubset<T, givenGoldCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a GivenGold.
     * @param {givenGoldDeleteArgs} args - Arguments to delete one GivenGold.
     * @example
     * // Delete one GivenGold
     * const GivenGold = await prisma.givenGold.delete({
     *   where: {
     *     // ... filter to delete one GivenGold
     *   }
     * })
     * 
     */
    delete<T extends givenGoldDeleteArgs>(args: SelectSubset<T, givenGoldDeleteArgs<ExtArgs>>): Prisma__givenGoldClient<$Result.GetResult<Prisma.$givenGoldPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GivenGold.
     * @param {givenGoldUpdateArgs} args - Arguments to update one GivenGold.
     * @example
     * // Update one GivenGold
     * const givenGold = await prisma.givenGold.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends givenGoldUpdateArgs>(args: SelectSubset<T, givenGoldUpdateArgs<ExtArgs>>): Prisma__givenGoldClient<$Result.GetResult<Prisma.$givenGoldPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GivenGolds.
     * @param {givenGoldDeleteManyArgs} args - Arguments to filter GivenGolds to delete.
     * @example
     * // Delete a few GivenGolds
     * const { count } = await prisma.givenGold.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends givenGoldDeleteManyArgs>(args?: SelectSubset<T, givenGoldDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GivenGolds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {givenGoldUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GivenGolds
     * const givenGold = await prisma.givenGold.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends givenGoldUpdateManyArgs>(args: SelectSubset<T, givenGoldUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one GivenGold.
     * @param {givenGoldUpsertArgs} args - Arguments to update or create a GivenGold.
     * @example
     * // Update or create a GivenGold
     * const givenGold = await prisma.givenGold.upsert({
     *   create: {
     *     // ... data to create a GivenGold
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GivenGold we want to update
     *   }
     * })
     */
    upsert<T extends givenGoldUpsertArgs>(args: SelectSubset<T, givenGoldUpsertArgs<ExtArgs>>): Prisma__givenGoldClient<$Result.GetResult<Prisma.$givenGoldPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GivenGolds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {givenGoldCountArgs} args - Arguments to filter GivenGolds to count.
     * @example
     * // Count the number of GivenGolds
     * const count = await prisma.givenGold.count({
     *   where: {
     *     // ... the filter for the GivenGolds we want to count
     *   }
     * })
    **/
    count<T extends givenGoldCountArgs>(
      args?: Subset<T, givenGoldCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GivenGoldCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GivenGold.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GivenGoldAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GivenGoldAggregateArgs>(args: Subset<T, GivenGoldAggregateArgs>): Prisma.PrismaPromise<GetGivenGoldAggregateType<T>>

    /**
     * Group by GivenGold.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {givenGoldGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends givenGoldGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: givenGoldGroupByArgs['orderBy'] }
        : { orderBy?: givenGoldGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, givenGoldGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGivenGoldGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the givenGold model
   */
  readonly fields: givenGoldFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for givenGold.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__givenGoldClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    goldsmith<T extends givenGold$goldsmithArgs<ExtArgs> = {}>(args?: Subset<T, givenGold$goldsmithArgs<ExtArgs>>): Prisma__GoldsmithClient<$Result.GetResult<Prisma.$GoldsmithPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    jobcard<T extends givenGold$jobcardArgs<ExtArgs> = {}>(args?: Subset<T, givenGold$jobcardArgs<ExtArgs>>): Prisma__JobcardClient<$Result.GetResult<Prisma.$JobcardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the givenGold model
   */
  interface givenGoldFieldRefs {
    readonly id: FieldRef<"givenGold", 'Int'>
    readonly goldsmithId: FieldRef<"givenGold", 'Int'>
    readonly jobcardId: FieldRef<"givenGold", 'Int'>
    readonly weight: FieldRef<"givenGold", 'Float'>
    readonly touch: FieldRef<"givenGold", 'Float'>
    readonly purity: FieldRef<"givenGold", 'Float'>
    readonly createdAt: FieldRef<"givenGold", 'DateTime'>
    readonly updatedAt: FieldRef<"givenGold", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * givenGold findUnique
   */
  export type givenGoldFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the givenGold
     */
    select?: givenGoldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the givenGold
     */
    omit?: givenGoldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: givenGoldInclude<ExtArgs> | null
    /**
     * Filter, which givenGold to fetch.
     */
    where: givenGoldWhereUniqueInput
  }

  /**
   * givenGold findUniqueOrThrow
   */
  export type givenGoldFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the givenGold
     */
    select?: givenGoldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the givenGold
     */
    omit?: givenGoldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: givenGoldInclude<ExtArgs> | null
    /**
     * Filter, which givenGold to fetch.
     */
    where: givenGoldWhereUniqueInput
  }

  /**
   * givenGold findFirst
   */
  export type givenGoldFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the givenGold
     */
    select?: givenGoldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the givenGold
     */
    omit?: givenGoldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: givenGoldInclude<ExtArgs> | null
    /**
     * Filter, which givenGold to fetch.
     */
    where?: givenGoldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of givenGolds to fetch.
     */
    orderBy?: givenGoldOrderByWithRelationInput | givenGoldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for givenGolds.
     */
    cursor?: givenGoldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` givenGolds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` givenGolds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of givenGolds.
     */
    distinct?: GivenGoldScalarFieldEnum | GivenGoldScalarFieldEnum[]
  }

  /**
   * givenGold findFirstOrThrow
   */
  export type givenGoldFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the givenGold
     */
    select?: givenGoldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the givenGold
     */
    omit?: givenGoldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: givenGoldInclude<ExtArgs> | null
    /**
     * Filter, which givenGold to fetch.
     */
    where?: givenGoldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of givenGolds to fetch.
     */
    orderBy?: givenGoldOrderByWithRelationInput | givenGoldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for givenGolds.
     */
    cursor?: givenGoldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` givenGolds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` givenGolds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of givenGolds.
     */
    distinct?: GivenGoldScalarFieldEnum | GivenGoldScalarFieldEnum[]
  }

  /**
   * givenGold findMany
   */
  export type givenGoldFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the givenGold
     */
    select?: givenGoldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the givenGold
     */
    omit?: givenGoldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: givenGoldInclude<ExtArgs> | null
    /**
     * Filter, which givenGolds to fetch.
     */
    where?: givenGoldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of givenGolds to fetch.
     */
    orderBy?: givenGoldOrderByWithRelationInput | givenGoldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing givenGolds.
     */
    cursor?: givenGoldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` givenGolds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` givenGolds.
     */
    skip?: number
    distinct?: GivenGoldScalarFieldEnum | GivenGoldScalarFieldEnum[]
  }

  /**
   * givenGold create
   */
  export type givenGoldCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the givenGold
     */
    select?: givenGoldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the givenGold
     */
    omit?: givenGoldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: givenGoldInclude<ExtArgs> | null
    /**
     * The data needed to create a givenGold.
     */
    data: XOR<givenGoldCreateInput, givenGoldUncheckedCreateInput>
  }

  /**
   * givenGold createMany
   */
  export type givenGoldCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many givenGolds.
     */
    data: givenGoldCreateManyInput | givenGoldCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * givenGold update
   */
  export type givenGoldUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the givenGold
     */
    select?: givenGoldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the givenGold
     */
    omit?: givenGoldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: givenGoldInclude<ExtArgs> | null
    /**
     * The data needed to update a givenGold.
     */
    data: XOR<givenGoldUpdateInput, givenGoldUncheckedUpdateInput>
    /**
     * Choose, which givenGold to update.
     */
    where: givenGoldWhereUniqueInput
  }

  /**
   * givenGold updateMany
   */
  export type givenGoldUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update givenGolds.
     */
    data: XOR<givenGoldUpdateManyMutationInput, givenGoldUncheckedUpdateManyInput>
    /**
     * Filter which givenGolds to update
     */
    where?: givenGoldWhereInput
    /**
     * Limit how many givenGolds to update.
     */
    limit?: number
  }

  /**
   * givenGold upsert
   */
  export type givenGoldUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the givenGold
     */
    select?: givenGoldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the givenGold
     */
    omit?: givenGoldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: givenGoldInclude<ExtArgs> | null
    /**
     * The filter to search for the givenGold to update in case it exists.
     */
    where: givenGoldWhereUniqueInput
    /**
     * In case the givenGold found by the `where` argument doesn't exist, create a new givenGold with this data.
     */
    create: XOR<givenGoldCreateInput, givenGoldUncheckedCreateInput>
    /**
     * In case the givenGold was found with the provided `where` argument, update it with this data.
     */
    update: XOR<givenGoldUpdateInput, givenGoldUncheckedUpdateInput>
  }

  /**
   * givenGold delete
   */
  export type givenGoldDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the givenGold
     */
    select?: givenGoldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the givenGold
     */
    omit?: givenGoldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: givenGoldInclude<ExtArgs> | null
    /**
     * Filter which givenGold to delete.
     */
    where: givenGoldWhereUniqueInput
  }

  /**
   * givenGold deleteMany
   */
  export type givenGoldDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which givenGolds to delete
     */
    where?: givenGoldWhereInput
    /**
     * Limit how many givenGolds to delete.
     */
    limit?: number
  }

  /**
   * givenGold.goldsmith
   */
  export type givenGold$goldsmithArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goldsmith
     */
    select?: GoldsmithSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Goldsmith
     */
    omit?: GoldsmithOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoldsmithInclude<ExtArgs> | null
    where?: GoldsmithWhereInput
  }

  /**
   * givenGold.jobcard
   */
  export type givenGold$jobcardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobcard
     */
    select?: JobcardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Jobcard
     */
    omit?: JobcardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobcardInclude<ExtArgs> | null
    where?: JobcardWhereInput
  }

  /**
   * givenGold without action
   */
  export type givenGoldDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the givenGold
     */
    select?: givenGoldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the givenGold
     */
    omit?: givenGoldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: givenGoldInclude<ExtArgs> | null
  }


  /**
   * Model Total
   */

  export type AggregateTotal = {
    _count: TotalCountAggregateOutputType | null
    _avg: TotalAvgAggregateOutputType | null
    _sum: TotalSumAggregateOutputType | null
    _min: TotalMinAggregateOutputType | null
    _max: TotalMaxAggregateOutputType | null
  }

  export type TotalAvgAggregateOutputType = {
    id: number | null
    goldsmithId: number | null
    totalPurity: number | null
    openingBalance: number | null
    totalBalance: number | null
  }

  export type TotalSumAggregateOutputType = {
    id: number | null
    goldsmithId: number | null
    totalPurity: number | null
    openingBalance: number | null
    totalBalance: number | null
  }

  export type TotalMinAggregateOutputType = {
    id: number | null
    goldsmithId: number | null
    totalPurity: number | null
    openingBalance: number | null
    totalBalance: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TotalMaxAggregateOutputType = {
    id: number | null
    goldsmithId: number | null
    totalPurity: number | null
    openingBalance: number | null
    totalBalance: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TotalCountAggregateOutputType = {
    id: number
    goldsmithId: number
    totalPurity: number
    openingBalance: number
    totalBalance: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TotalAvgAggregateInputType = {
    id?: true
    goldsmithId?: true
    totalPurity?: true
    openingBalance?: true
    totalBalance?: true
  }

  export type TotalSumAggregateInputType = {
    id?: true
    goldsmithId?: true
    totalPurity?: true
    openingBalance?: true
    totalBalance?: true
  }

  export type TotalMinAggregateInputType = {
    id?: true
    goldsmithId?: true
    totalPurity?: true
    openingBalance?: true
    totalBalance?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TotalMaxAggregateInputType = {
    id?: true
    goldsmithId?: true
    totalPurity?: true
    openingBalance?: true
    totalBalance?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TotalCountAggregateInputType = {
    id?: true
    goldsmithId?: true
    totalPurity?: true
    openingBalance?: true
    totalBalance?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TotalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Total to aggregate.
     */
    where?: TotalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Totals to fetch.
     */
    orderBy?: TotalOrderByWithRelationInput | TotalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TotalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Totals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Totals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Totals
    **/
    _count?: true | TotalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TotalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TotalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TotalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TotalMaxAggregateInputType
  }

  export type GetTotalAggregateType<T extends TotalAggregateArgs> = {
        [P in keyof T & keyof AggregateTotal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTotal[P]>
      : GetScalarType<T[P], AggregateTotal[P]>
  }




  export type TotalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TotalWhereInput
    orderBy?: TotalOrderByWithAggregationInput | TotalOrderByWithAggregationInput[]
    by: TotalScalarFieldEnum[] | TotalScalarFieldEnum
    having?: TotalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TotalCountAggregateInputType | true
    _avg?: TotalAvgAggregateInputType
    _sum?: TotalSumAggregateInputType
    _min?: TotalMinAggregateInputType
    _max?: TotalMaxAggregateInputType
  }

  export type TotalGroupByOutputType = {
    id: number
    goldsmithId: number
    totalPurity: number
    openingBalance: number
    totalBalance: number
    createdAt: Date
    updatedAt: Date
    _count: TotalCountAggregateOutputType | null
    _avg: TotalAvgAggregateOutputType | null
    _sum: TotalSumAggregateOutputType | null
    _min: TotalMinAggregateOutputType | null
    _max: TotalMaxAggregateOutputType | null
  }

  type GetTotalGroupByPayload<T extends TotalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TotalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TotalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TotalGroupByOutputType[P]>
            : GetScalarType<T[P], TotalGroupByOutputType[P]>
        }
      >
    >


  export type TotalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    goldsmithId?: boolean
    totalPurity?: boolean
    openingBalance?: boolean
    totalBalance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    goldsmith?: boolean | GoldsmithDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["total"]>



  export type TotalSelectScalar = {
    id?: boolean
    goldsmithId?: boolean
    totalPurity?: boolean
    openingBalance?: boolean
    totalBalance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TotalOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "goldsmithId" | "totalPurity" | "openingBalance" | "totalBalance" | "createdAt" | "updatedAt", ExtArgs["result"]["total"]>
  export type TotalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    goldsmith?: boolean | GoldsmithDefaultArgs<ExtArgs>
  }

  export type $TotalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Total"
    objects: {
      goldsmith: Prisma.$GoldsmithPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      goldsmithId: number
      totalPurity: number
      openingBalance: number
      totalBalance: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["total"]>
    composites: {}
  }

  type TotalGetPayload<S extends boolean | null | undefined | TotalDefaultArgs> = $Result.GetResult<Prisma.$TotalPayload, S>

  type TotalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TotalFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TotalCountAggregateInputType | true
    }

  export interface TotalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Total'], meta: { name: 'Total' } }
    /**
     * Find zero or one Total that matches the filter.
     * @param {TotalFindUniqueArgs} args - Arguments to find a Total
     * @example
     * // Get one Total
     * const total = await prisma.total.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TotalFindUniqueArgs>(args: SelectSubset<T, TotalFindUniqueArgs<ExtArgs>>): Prisma__TotalClient<$Result.GetResult<Prisma.$TotalPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Total that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TotalFindUniqueOrThrowArgs} args - Arguments to find a Total
     * @example
     * // Get one Total
     * const total = await prisma.total.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TotalFindUniqueOrThrowArgs>(args: SelectSubset<T, TotalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TotalClient<$Result.GetResult<Prisma.$TotalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Total that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TotalFindFirstArgs} args - Arguments to find a Total
     * @example
     * // Get one Total
     * const total = await prisma.total.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TotalFindFirstArgs>(args?: SelectSubset<T, TotalFindFirstArgs<ExtArgs>>): Prisma__TotalClient<$Result.GetResult<Prisma.$TotalPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Total that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TotalFindFirstOrThrowArgs} args - Arguments to find a Total
     * @example
     * // Get one Total
     * const total = await prisma.total.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TotalFindFirstOrThrowArgs>(args?: SelectSubset<T, TotalFindFirstOrThrowArgs<ExtArgs>>): Prisma__TotalClient<$Result.GetResult<Prisma.$TotalPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Totals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TotalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Totals
     * const totals = await prisma.total.findMany()
     * 
     * // Get first 10 Totals
     * const totals = await prisma.total.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const totalWithIdOnly = await prisma.total.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TotalFindManyArgs>(args?: SelectSubset<T, TotalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TotalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Total.
     * @param {TotalCreateArgs} args - Arguments to create a Total.
     * @example
     * // Create one Total
     * const Total = await prisma.total.create({
     *   data: {
     *     // ... data to create a Total
     *   }
     * })
     * 
     */
    create<T extends TotalCreateArgs>(args: SelectSubset<T, TotalCreateArgs<ExtArgs>>): Prisma__TotalClient<$Result.GetResult<Prisma.$TotalPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Totals.
     * @param {TotalCreateManyArgs} args - Arguments to create many Totals.
     * @example
     * // Create many Totals
     * const total = await prisma.total.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TotalCreateManyArgs>(args?: SelectSubset<T, TotalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Total.
     * @param {TotalDeleteArgs} args - Arguments to delete one Total.
     * @example
     * // Delete one Total
     * const Total = await prisma.total.delete({
     *   where: {
     *     // ... filter to delete one Total
     *   }
     * })
     * 
     */
    delete<T extends TotalDeleteArgs>(args: SelectSubset<T, TotalDeleteArgs<ExtArgs>>): Prisma__TotalClient<$Result.GetResult<Prisma.$TotalPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Total.
     * @param {TotalUpdateArgs} args - Arguments to update one Total.
     * @example
     * // Update one Total
     * const total = await prisma.total.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TotalUpdateArgs>(args: SelectSubset<T, TotalUpdateArgs<ExtArgs>>): Prisma__TotalClient<$Result.GetResult<Prisma.$TotalPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Totals.
     * @param {TotalDeleteManyArgs} args - Arguments to filter Totals to delete.
     * @example
     * // Delete a few Totals
     * const { count } = await prisma.total.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TotalDeleteManyArgs>(args?: SelectSubset<T, TotalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Totals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TotalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Totals
     * const total = await prisma.total.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TotalUpdateManyArgs>(args: SelectSubset<T, TotalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Total.
     * @param {TotalUpsertArgs} args - Arguments to update or create a Total.
     * @example
     * // Update or create a Total
     * const total = await prisma.total.upsert({
     *   create: {
     *     // ... data to create a Total
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Total we want to update
     *   }
     * })
     */
    upsert<T extends TotalUpsertArgs>(args: SelectSubset<T, TotalUpsertArgs<ExtArgs>>): Prisma__TotalClient<$Result.GetResult<Prisma.$TotalPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Totals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TotalCountArgs} args - Arguments to filter Totals to count.
     * @example
     * // Count the number of Totals
     * const count = await prisma.total.count({
     *   where: {
     *     // ... the filter for the Totals we want to count
     *   }
     * })
    **/
    count<T extends TotalCountArgs>(
      args?: Subset<T, TotalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TotalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Total.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TotalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TotalAggregateArgs>(args: Subset<T, TotalAggregateArgs>): Prisma.PrismaPromise<GetTotalAggregateType<T>>

    /**
     * Group by Total.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TotalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TotalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TotalGroupByArgs['orderBy'] }
        : { orderBy?: TotalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TotalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTotalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Total model
   */
  readonly fields: TotalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Total.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TotalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    goldsmith<T extends GoldsmithDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GoldsmithDefaultArgs<ExtArgs>>): Prisma__GoldsmithClient<$Result.GetResult<Prisma.$GoldsmithPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Total model
   */
  interface TotalFieldRefs {
    readonly id: FieldRef<"Total", 'Int'>
    readonly goldsmithId: FieldRef<"Total", 'Int'>
    readonly totalPurity: FieldRef<"Total", 'Float'>
    readonly openingBalance: FieldRef<"Total", 'Float'>
    readonly totalBalance: FieldRef<"Total", 'Float'>
    readonly createdAt: FieldRef<"Total", 'DateTime'>
    readonly updatedAt: FieldRef<"Total", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Total findUnique
   */
  export type TotalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Total
     */
    select?: TotalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Total
     */
    omit?: TotalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TotalInclude<ExtArgs> | null
    /**
     * Filter, which Total to fetch.
     */
    where: TotalWhereUniqueInput
  }

  /**
   * Total findUniqueOrThrow
   */
  export type TotalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Total
     */
    select?: TotalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Total
     */
    omit?: TotalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TotalInclude<ExtArgs> | null
    /**
     * Filter, which Total to fetch.
     */
    where: TotalWhereUniqueInput
  }

  /**
   * Total findFirst
   */
  export type TotalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Total
     */
    select?: TotalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Total
     */
    omit?: TotalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TotalInclude<ExtArgs> | null
    /**
     * Filter, which Total to fetch.
     */
    where?: TotalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Totals to fetch.
     */
    orderBy?: TotalOrderByWithRelationInput | TotalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Totals.
     */
    cursor?: TotalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Totals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Totals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Totals.
     */
    distinct?: TotalScalarFieldEnum | TotalScalarFieldEnum[]
  }

  /**
   * Total findFirstOrThrow
   */
  export type TotalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Total
     */
    select?: TotalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Total
     */
    omit?: TotalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TotalInclude<ExtArgs> | null
    /**
     * Filter, which Total to fetch.
     */
    where?: TotalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Totals to fetch.
     */
    orderBy?: TotalOrderByWithRelationInput | TotalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Totals.
     */
    cursor?: TotalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Totals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Totals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Totals.
     */
    distinct?: TotalScalarFieldEnum | TotalScalarFieldEnum[]
  }

  /**
   * Total findMany
   */
  export type TotalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Total
     */
    select?: TotalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Total
     */
    omit?: TotalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TotalInclude<ExtArgs> | null
    /**
     * Filter, which Totals to fetch.
     */
    where?: TotalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Totals to fetch.
     */
    orderBy?: TotalOrderByWithRelationInput | TotalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Totals.
     */
    cursor?: TotalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Totals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Totals.
     */
    skip?: number
    distinct?: TotalScalarFieldEnum | TotalScalarFieldEnum[]
  }

  /**
   * Total create
   */
  export type TotalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Total
     */
    select?: TotalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Total
     */
    omit?: TotalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TotalInclude<ExtArgs> | null
    /**
     * The data needed to create a Total.
     */
    data: XOR<TotalCreateInput, TotalUncheckedCreateInput>
  }

  /**
   * Total createMany
   */
  export type TotalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Totals.
     */
    data: TotalCreateManyInput | TotalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Total update
   */
  export type TotalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Total
     */
    select?: TotalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Total
     */
    omit?: TotalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TotalInclude<ExtArgs> | null
    /**
     * The data needed to update a Total.
     */
    data: XOR<TotalUpdateInput, TotalUncheckedUpdateInput>
    /**
     * Choose, which Total to update.
     */
    where: TotalWhereUniqueInput
  }

  /**
   * Total updateMany
   */
  export type TotalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Totals.
     */
    data: XOR<TotalUpdateManyMutationInput, TotalUncheckedUpdateManyInput>
    /**
     * Filter which Totals to update
     */
    where?: TotalWhereInput
    /**
     * Limit how many Totals to update.
     */
    limit?: number
  }

  /**
   * Total upsert
   */
  export type TotalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Total
     */
    select?: TotalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Total
     */
    omit?: TotalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TotalInclude<ExtArgs> | null
    /**
     * The filter to search for the Total to update in case it exists.
     */
    where: TotalWhereUniqueInput
    /**
     * In case the Total found by the `where` argument doesn't exist, create a new Total with this data.
     */
    create: XOR<TotalCreateInput, TotalUncheckedCreateInput>
    /**
     * In case the Total was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TotalUpdateInput, TotalUncheckedUpdateInput>
  }

  /**
   * Total delete
   */
  export type TotalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Total
     */
    select?: TotalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Total
     */
    omit?: TotalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TotalInclude<ExtArgs> | null
    /**
     * Filter which Total to delete.
     */
    where: TotalWhereUniqueInput
  }

  /**
   * Total deleteMany
   */
  export type TotalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Totals to delete
     */
    where?: TotalWhereInput
    /**
     * Limit how many Totals to delete.
     */
    limit?: number
  }

  /**
   * Total without action
   */
  export type TotalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Total
     */
    select?: TotalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Total
     */
    omit?: TotalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TotalInclude<ExtArgs> | null
  }


  /**
   * Model itemDelivery
   */

  export type AggregateItemDelivery = {
    _count: ItemDeliveryCountAggregateOutputType | null
    _avg: ItemDeliveryAvgAggregateOutputType | null
    _sum: ItemDeliverySumAggregateOutputType | null
    _min: ItemDeliveryMinAggregateOutputType | null
    _max: ItemDeliveryMaxAggregateOutputType | null
  }

  export type ItemDeliveryAvgAggregateOutputType = {
    id: number | null
    itemWeight: number | null
    stoneWeight: number | null
    netWeight: number | null
    wastageValue: number | null
    finalPurity: number | null
    goldsmithId: number | null
    jobcardId: number | null
  }

  export type ItemDeliverySumAggregateOutputType = {
    id: number | null
    itemWeight: number | null
    stoneWeight: number | null
    netWeight: number | null
    wastageValue: number | null
    finalPurity: number | null
    goldsmithId: number | null
    jobcardId: number | null
  }

  export type ItemDeliveryMinAggregateOutputType = {
    id: number | null
    itemName: string | null
    itemWeight: number | null
    type: string | null
    stoneWeight: number | null
    netWeight: number | null
    wastageType: $Enums.WastageType | null
    wastageValue: number | null
    finalPurity: number | null
    goldsmithId: number | null
    jobcardId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ItemDeliveryMaxAggregateOutputType = {
    id: number | null
    itemName: string | null
    itemWeight: number | null
    type: string | null
    stoneWeight: number | null
    netWeight: number | null
    wastageType: $Enums.WastageType | null
    wastageValue: number | null
    finalPurity: number | null
    goldsmithId: number | null
    jobcardId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ItemDeliveryCountAggregateOutputType = {
    id: number
    itemName: number
    itemWeight: number
    type: number
    stoneWeight: number
    netWeight: number
    wastageType: number
    wastageValue: number
    finalPurity: number
    goldsmithId: number
    jobcardId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ItemDeliveryAvgAggregateInputType = {
    id?: true
    itemWeight?: true
    stoneWeight?: true
    netWeight?: true
    wastageValue?: true
    finalPurity?: true
    goldsmithId?: true
    jobcardId?: true
  }

  export type ItemDeliverySumAggregateInputType = {
    id?: true
    itemWeight?: true
    stoneWeight?: true
    netWeight?: true
    wastageValue?: true
    finalPurity?: true
    goldsmithId?: true
    jobcardId?: true
  }

  export type ItemDeliveryMinAggregateInputType = {
    id?: true
    itemName?: true
    itemWeight?: true
    type?: true
    stoneWeight?: true
    netWeight?: true
    wastageType?: true
    wastageValue?: true
    finalPurity?: true
    goldsmithId?: true
    jobcardId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ItemDeliveryMaxAggregateInputType = {
    id?: true
    itemName?: true
    itemWeight?: true
    type?: true
    stoneWeight?: true
    netWeight?: true
    wastageType?: true
    wastageValue?: true
    finalPurity?: true
    goldsmithId?: true
    jobcardId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ItemDeliveryCountAggregateInputType = {
    id?: true
    itemName?: true
    itemWeight?: true
    type?: true
    stoneWeight?: true
    netWeight?: true
    wastageType?: true
    wastageValue?: true
    finalPurity?: true
    goldsmithId?: true
    jobcardId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ItemDeliveryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which itemDelivery to aggregate.
     */
    where?: itemDeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of itemDeliveries to fetch.
     */
    orderBy?: itemDeliveryOrderByWithRelationInput | itemDeliveryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: itemDeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` itemDeliveries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` itemDeliveries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned itemDeliveries
    **/
    _count?: true | ItemDeliveryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ItemDeliveryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ItemDeliverySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItemDeliveryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItemDeliveryMaxAggregateInputType
  }

  export type GetItemDeliveryAggregateType<T extends ItemDeliveryAggregateArgs> = {
        [P in keyof T & keyof AggregateItemDelivery]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItemDelivery[P]>
      : GetScalarType<T[P], AggregateItemDelivery[P]>
  }




  export type itemDeliveryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: itemDeliveryWhereInput
    orderBy?: itemDeliveryOrderByWithAggregationInput | itemDeliveryOrderByWithAggregationInput[]
    by: ItemDeliveryScalarFieldEnum[] | ItemDeliveryScalarFieldEnum
    having?: itemDeliveryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItemDeliveryCountAggregateInputType | true
    _avg?: ItemDeliveryAvgAggregateInputType
    _sum?: ItemDeliverySumAggregateInputType
    _min?: ItemDeliveryMinAggregateInputType
    _max?: ItemDeliveryMaxAggregateInputType
  }

  export type ItemDeliveryGroupByOutputType = {
    id: number
    itemName: string
    itemWeight: number
    type: string
    stoneWeight: number
    netWeight: number
    wastageType: $Enums.WastageType
    wastageValue: number
    finalPurity: number
    goldsmithId: number | null
    jobcardId: number | null
    createdAt: Date
    updatedAt: Date
    _count: ItemDeliveryCountAggregateOutputType | null
    _avg: ItemDeliveryAvgAggregateOutputType | null
    _sum: ItemDeliverySumAggregateOutputType | null
    _min: ItemDeliveryMinAggregateOutputType | null
    _max: ItemDeliveryMaxAggregateOutputType | null
  }

  type GetItemDeliveryGroupByPayload<T extends itemDeliveryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ItemDeliveryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItemDeliveryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItemDeliveryGroupByOutputType[P]>
            : GetScalarType<T[P], ItemDeliveryGroupByOutputType[P]>
        }
      >
    >


  export type itemDeliverySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    itemName?: boolean
    itemWeight?: boolean
    type?: boolean
    stoneWeight?: boolean
    netWeight?: boolean
    wastageType?: boolean
    wastageValue?: boolean
    finalPurity?: boolean
    goldsmithId?: boolean
    jobcardId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    goldsmith?: boolean | itemDelivery$goldsmithArgs<ExtArgs>
    jobcard?: boolean | itemDelivery$jobcardArgs<ExtArgs>
  }, ExtArgs["result"]["itemDelivery"]>



  export type itemDeliverySelectScalar = {
    id?: boolean
    itemName?: boolean
    itemWeight?: boolean
    type?: boolean
    stoneWeight?: boolean
    netWeight?: boolean
    wastageType?: boolean
    wastageValue?: boolean
    finalPurity?: boolean
    goldsmithId?: boolean
    jobcardId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type itemDeliveryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "itemName" | "itemWeight" | "type" | "stoneWeight" | "netWeight" | "wastageType" | "wastageValue" | "finalPurity" | "goldsmithId" | "jobcardId" | "createdAt" | "updatedAt", ExtArgs["result"]["itemDelivery"]>
  export type itemDeliveryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    goldsmith?: boolean | itemDelivery$goldsmithArgs<ExtArgs>
    jobcard?: boolean | itemDelivery$jobcardArgs<ExtArgs>
  }

  export type $itemDeliveryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "itemDelivery"
    objects: {
      goldsmith: Prisma.$GoldsmithPayload<ExtArgs> | null
      jobcard: Prisma.$JobcardPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      itemName: string
      itemWeight: number
      type: string
      stoneWeight: number
      netWeight: number
      wastageType: $Enums.WastageType
      wastageValue: number
      finalPurity: number
      goldsmithId: number | null
      jobcardId: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["itemDelivery"]>
    composites: {}
  }

  type itemDeliveryGetPayload<S extends boolean | null | undefined | itemDeliveryDefaultArgs> = $Result.GetResult<Prisma.$itemDeliveryPayload, S>

  type itemDeliveryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<itemDeliveryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ItemDeliveryCountAggregateInputType | true
    }

  export interface itemDeliveryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['itemDelivery'], meta: { name: 'itemDelivery' } }
    /**
     * Find zero or one ItemDelivery that matches the filter.
     * @param {itemDeliveryFindUniqueArgs} args - Arguments to find a ItemDelivery
     * @example
     * // Get one ItemDelivery
     * const itemDelivery = await prisma.itemDelivery.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends itemDeliveryFindUniqueArgs>(args: SelectSubset<T, itemDeliveryFindUniqueArgs<ExtArgs>>): Prisma__itemDeliveryClient<$Result.GetResult<Prisma.$itemDeliveryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ItemDelivery that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {itemDeliveryFindUniqueOrThrowArgs} args - Arguments to find a ItemDelivery
     * @example
     * // Get one ItemDelivery
     * const itemDelivery = await prisma.itemDelivery.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends itemDeliveryFindUniqueOrThrowArgs>(args: SelectSubset<T, itemDeliveryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__itemDeliveryClient<$Result.GetResult<Prisma.$itemDeliveryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ItemDelivery that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {itemDeliveryFindFirstArgs} args - Arguments to find a ItemDelivery
     * @example
     * // Get one ItemDelivery
     * const itemDelivery = await prisma.itemDelivery.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends itemDeliveryFindFirstArgs>(args?: SelectSubset<T, itemDeliveryFindFirstArgs<ExtArgs>>): Prisma__itemDeliveryClient<$Result.GetResult<Prisma.$itemDeliveryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ItemDelivery that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {itemDeliveryFindFirstOrThrowArgs} args - Arguments to find a ItemDelivery
     * @example
     * // Get one ItemDelivery
     * const itemDelivery = await prisma.itemDelivery.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends itemDeliveryFindFirstOrThrowArgs>(args?: SelectSubset<T, itemDeliveryFindFirstOrThrowArgs<ExtArgs>>): Prisma__itemDeliveryClient<$Result.GetResult<Prisma.$itemDeliveryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ItemDeliveries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {itemDeliveryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ItemDeliveries
     * const itemDeliveries = await prisma.itemDelivery.findMany()
     * 
     * // Get first 10 ItemDeliveries
     * const itemDeliveries = await prisma.itemDelivery.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const itemDeliveryWithIdOnly = await prisma.itemDelivery.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends itemDeliveryFindManyArgs>(args?: SelectSubset<T, itemDeliveryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$itemDeliveryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ItemDelivery.
     * @param {itemDeliveryCreateArgs} args - Arguments to create a ItemDelivery.
     * @example
     * // Create one ItemDelivery
     * const ItemDelivery = await prisma.itemDelivery.create({
     *   data: {
     *     // ... data to create a ItemDelivery
     *   }
     * })
     * 
     */
    create<T extends itemDeliveryCreateArgs>(args: SelectSubset<T, itemDeliveryCreateArgs<ExtArgs>>): Prisma__itemDeliveryClient<$Result.GetResult<Prisma.$itemDeliveryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ItemDeliveries.
     * @param {itemDeliveryCreateManyArgs} args - Arguments to create many ItemDeliveries.
     * @example
     * // Create many ItemDeliveries
     * const itemDelivery = await prisma.itemDelivery.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends itemDeliveryCreateManyArgs>(args?: SelectSubset<T, itemDeliveryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ItemDelivery.
     * @param {itemDeliveryDeleteArgs} args - Arguments to delete one ItemDelivery.
     * @example
     * // Delete one ItemDelivery
     * const ItemDelivery = await prisma.itemDelivery.delete({
     *   where: {
     *     // ... filter to delete one ItemDelivery
     *   }
     * })
     * 
     */
    delete<T extends itemDeliveryDeleteArgs>(args: SelectSubset<T, itemDeliveryDeleteArgs<ExtArgs>>): Prisma__itemDeliveryClient<$Result.GetResult<Prisma.$itemDeliveryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ItemDelivery.
     * @param {itemDeliveryUpdateArgs} args - Arguments to update one ItemDelivery.
     * @example
     * // Update one ItemDelivery
     * const itemDelivery = await prisma.itemDelivery.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends itemDeliveryUpdateArgs>(args: SelectSubset<T, itemDeliveryUpdateArgs<ExtArgs>>): Prisma__itemDeliveryClient<$Result.GetResult<Prisma.$itemDeliveryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ItemDeliveries.
     * @param {itemDeliveryDeleteManyArgs} args - Arguments to filter ItemDeliveries to delete.
     * @example
     * // Delete a few ItemDeliveries
     * const { count } = await prisma.itemDelivery.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends itemDeliveryDeleteManyArgs>(args?: SelectSubset<T, itemDeliveryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ItemDeliveries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {itemDeliveryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ItemDeliveries
     * const itemDelivery = await prisma.itemDelivery.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends itemDeliveryUpdateManyArgs>(args: SelectSubset<T, itemDeliveryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ItemDelivery.
     * @param {itemDeliveryUpsertArgs} args - Arguments to update or create a ItemDelivery.
     * @example
     * // Update or create a ItemDelivery
     * const itemDelivery = await prisma.itemDelivery.upsert({
     *   create: {
     *     // ... data to create a ItemDelivery
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ItemDelivery we want to update
     *   }
     * })
     */
    upsert<T extends itemDeliveryUpsertArgs>(args: SelectSubset<T, itemDeliveryUpsertArgs<ExtArgs>>): Prisma__itemDeliveryClient<$Result.GetResult<Prisma.$itemDeliveryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ItemDeliveries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {itemDeliveryCountArgs} args - Arguments to filter ItemDeliveries to count.
     * @example
     * // Count the number of ItemDeliveries
     * const count = await prisma.itemDelivery.count({
     *   where: {
     *     // ... the filter for the ItemDeliveries we want to count
     *   }
     * })
    **/
    count<T extends itemDeliveryCountArgs>(
      args?: Subset<T, itemDeliveryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItemDeliveryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ItemDelivery.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemDeliveryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItemDeliveryAggregateArgs>(args: Subset<T, ItemDeliveryAggregateArgs>): Prisma.PrismaPromise<GetItemDeliveryAggregateType<T>>

    /**
     * Group by ItemDelivery.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {itemDeliveryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends itemDeliveryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: itemDeliveryGroupByArgs['orderBy'] }
        : { orderBy?: itemDeliveryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, itemDeliveryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItemDeliveryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the itemDelivery model
   */
  readonly fields: itemDeliveryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for itemDelivery.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__itemDeliveryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    goldsmith<T extends itemDelivery$goldsmithArgs<ExtArgs> = {}>(args?: Subset<T, itemDelivery$goldsmithArgs<ExtArgs>>): Prisma__GoldsmithClient<$Result.GetResult<Prisma.$GoldsmithPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    jobcard<T extends itemDelivery$jobcardArgs<ExtArgs> = {}>(args?: Subset<T, itemDelivery$jobcardArgs<ExtArgs>>): Prisma__JobcardClient<$Result.GetResult<Prisma.$JobcardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the itemDelivery model
   */
  interface itemDeliveryFieldRefs {
    readonly id: FieldRef<"itemDelivery", 'Int'>
    readonly itemName: FieldRef<"itemDelivery", 'String'>
    readonly itemWeight: FieldRef<"itemDelivery", 'Float'>
    readonly type: FieldRef<"itemDelivery", 'String'>
    readonly stoneWeight: FieldRef<"itemDelivery", 'Float'>
    readonly netWeight: FieldRef<"itemDelivery", 'Float'>
    readonly wastageType: FieldRef<"itemDelivery", 'WastageType'>
    readonly wastageValue: FieldRef<"itemDelivery", 'Float'>
    readonly finalPurity: FieldRef<"itemDelivery", 'Float'>
    readonly goldsmithId: FieldRef<"itemDelivery", 'Int'>
    readonly jobcardId: FieldRef<"itemDelivery", 'Int'>
    readonly createdAt: FieldRef<"itemDelivery", 'DateTime'>
    readonly updatedAt: FieldRef<"itemDelivery", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * itemDelivery findUnique
   */
  export type itemDeliveryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the itemDelivery
     */
    select?: itemDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the itemDelivery
     */
    omit?: itemDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemDeliveryInclude<ExtArgs> | null
    /**
     * Filter, which itemDelivery to fetch.
     */
    where: itemDeliveryWhereUniqueInput
  }

  /**
   * itemDelivery findUniqueOrThrow
   */
  export type itemDeliveryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the itemDelivery
     */
    select?: itemDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the itemDelivery
     */
    omit?: itemDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemDeliveryInclude<ExtArgs> | null
    /**
     * Filter, which itemDelivery to fetch.
     */
    where: itemDeliveryWhereUniqueInput
  }

  /**
   * itemDelivery findFirst
   */
  export type itemDeliveryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the itemDelivery
     */
    select?: itemDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the itemDelivery
     */
    omit?: itemDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemDeliveryInclude<ExtArgs> | null
    /**
     * Filter, which itemDelivery to fetch.
     */
    where?: itemDeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of itemDeliveries to fetch.
     */
    orderBy?: itemDeliveryOrderByWithRelationInput | itemDeliveryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for itemDeliveries.
     */
    cursor?: itemDeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` itemDeliveries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` itemDeliveries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of itemDeliveries.
     */
    distinct?: ItemDeliveryScalarFieldEnum | ItemDeliveryScalarFieldEnum[]
  }

  /**
   * itemDelivery findFirstOrThrow
   */
  export type itemDeliveryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the itemDelivery
     */
    select?: itemDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the itemDelivery
     */
    omit?: itemDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemDeliveryInclude<ExtArgs> | null
    /**
     * Filter, which itemDelivery to fetch.
     */
    where?: itemDeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of itemDeliveries to fetch.
     */
    orderBy?: itemDeliveryOrderByWithRelationInput | itemDeliveryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for itemDeliveries.
     */
    cursor?: itemDeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` itemDeliveries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` itemDeliveries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of itemDeliveries.
     */
    distinct?: ItemDeliveryScalarFieldEnum | ItemDeliveryScalarFieldEnum[]
  }

  /**
   * itemDelivery findMany
   */
  export type itemDeliveryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the itemDelivery
     */
    select?: itemDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the itemDelivery
     */
    omit?: itemDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemDeliveryInclude<ExtArgs> | null
    /**
     * Filter, which itemDeliveries to fetch.
     */
    where?: itemDeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of itemDeliveries to fetch.
     */
    orderBy?: itemDeliveryOrderByWithRelationInput | itemDeliveryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing itemDeliveries.
     */
    cursor?: itemDeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` itemDeliveries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` itemDeliveries.
     */
    skip?: number
    distinct?: ItemDeliveryScalarFieldEnum | ItemDeliveryScalarFieldEnum[]
  }

  /**
   * itemDelivery create
   */
  export type itemDeliveryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the itemDelivery
     */
    select?: itemDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the itemDelivery
     */
    omit?: itemDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemDeliveryInclude<ExtArgs> | null
    /**
     * The data needed to create a itemDelivery.
     */
    data: XOR<itemDeliveryCreateInput, itemDeliveryUncheckedCreateInput>
  }

  /**
   * itemDelivery createMany
   */
  export type itemDeliveryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many itemDeliveries.
     */
    data: itemDeliveryCreateManyInput | itemDeliveryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * itemDelivery update
   */
  export type itemDeliveryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the itemDelivery
     */
    select?: itemDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the itemDelivery
     */
    omit?: itemDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemDeliveryInclude<ExtArgs> | null
    /**
     * The data needed to update a itemDelivery.
     */
    data: XOR<itemDeliveryUpdateInput, itemDeliveryUncheckedUpdateInput>
    /**
     * Choose, which itemDelivery to update.
     */
    where: itemDeliveryWhereUniqueInput
  }

  /**
   * itemDelivery updateMany
   */
  export type itemDeliveryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update itemDeliveries.
     */
    data: XOR<itemDeliveryUpdateManyMutationInput, itemDeliveryUncheckedUpdateManyInput>
    /**
     * Filter which itemDeliveries to update
     */
    where?: itemDeliveryWhereInput
    /**
     * Limit how many itemDeliveries to update.
     */
    limit?: number
  }

  /**
   * itemDelivery upsert
   */
  export type itemDeliveryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the itemDelivery
     */
    select?: itemDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the itemDelivery
     */
    omit?: itemDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemDeliveryInclude<ExtArgs> | null
    /**
     * The filter to search for the itemDelivery to update in case it exists.
     */
    where: itemDeliveryWhereUniqueInput
    /**
     * In case the itemDelivery found by the `where` argument doesn't exist, create a new itemDelivery with this data.
     */
    create: XOR<itemDeliveryCreateInput, itemDeliveryUncheckedCreateInput>
    /**
     * In case the itemDelivery was found with the provided `where` argument, update it with this data.
     */
    update: XOR<itemDeliveryUpdateInput, itemDeliveryUncheckedUpdateInput>
  }

  /**
   * itemDelivery delete
   */
  export type itemDeliveryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the itemDelivery
     */
    select?: itemDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the itemDelivery
     */
    omit?: itemDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemDeliveryInclude<ExtArgs> | null
    /**
     * Filter which itemDelivery to delete.
     */
    where: itemDeliveryWhereUniqueInput
  }

  /**
   * itemDelivery deleteMany
   */
  export type itemDeliveryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which itemDeliveries to delete
     */
    where?: itemDeliveryWhereInput
    /**
     * Limit how many itemDeliveries to delete.
     */
    limit?: number
  }

  /**
   * itemDelivery.goldsmith
   */
  export type itemDelivery$goldsmithArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goldsmith
     */
    select?: GoldsmithSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Goldsmith
     */
    omit?: GoldsmithOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoldsmithInclude<ExtArgs> | null
    where?: GoldsmithWhereInput
  }

  /**
   * itemDelivery.jobcard
   */
  export type itemDelivery$jobcardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobcard
     */
    select?: JobcardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Jobcard
     */
    omit?: JobcardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobcardInclude<ExtArgs> | null
    where?: JobcardWhereInput
  }

  /**
   * itemDelivery without action
   */
  export type itemDeliveryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the itemDelivery
     */
    select?: itemDeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the itemDelivery
     */
    omit?: itemDeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemDeliveryInclude<ExtArgs> | null
  }


  /**
   * Model Receivedsection
   */

  export type AggregateReceivedsection = {
    _count: ReceivedsectionCountAggregateOutputType | null
    _avg: ReceivedsectionAvgAggregateOutputType | null
    _sum: ReceivedsectionSumAggregateOutputType | null
    _min: ReceivedsectionMinAggregateOutputType | null
    _max: ReceivedsectionMaxAggregateOutputType | null
  }

  export type ReceivedsectionAvgAggregateOutputType = {
    id: number | null
    weight: number | null
    touch: number | null
    purity: number | null
    jobcardId: number | null
    goldsmithId: number | null
  }

  export type ReceivedsectionSumAggregateOutputType = {
    id: number | null
    weight: number | null
    touch: number | null
    purity: number | null
    jobcardId: number | null
    goldsmithId: number | null
  }

  export type ReceivedsectionMinAggregateOutputType = {
    id: number | null
    weight: number | null
    touch: number | null
    purity: number | null
    jobcardId: number | null
    goldsmithId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReceivedsectionMaxAggregateOutputType = {
    id: number | null
    weight: number | null
    touch: number | null
    purity: number | null
    jobcardId: number | null
    goldsmithId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReceivedsectionCountAggregateOutputType = {
    id: number
    weight: number
    touch: number
    purity: number
    jobcardId: number
    goldsmithId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ReceivedsectionAvgAggregateInputType = {
    id?: true
    weight?: true
    touch?: true
    purity?: true
    jobcardId?: true
    goldsmithId?: true
  }

  export type ReceivedsectionSumAggregateInputType = {
    id?: true
    weight?: true
    touch?: true
    purity?: true
    jobcardId?: true
    goldsmithId?: true
  }

  export type ReceivedsectionMinAggregateInputType = {
    id?: true
    weight?: true
    touch?: true
    purity?: true
    jobcardId?: true
    goldsmithId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReceivedsectionMaxAggregateInputType = {
    id?: true
    weight?: true
    touch?: true
    purity?: true
    jobcardId?: true
    goldsmithId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReceivedsectionCountAggregateInputType = {
    id?: true
    weight?: true
    touch?: true
    purity?: true
    jobcardId?: true
    goldsmithId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ReceivedsectionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Receivedsection to aggregate.
     */
    where?: ReceivedsectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Receivedsections to fetch.
     */
    orderBy?: ReceivedsectionOrderByWithRelationInput | ReceivedsectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReceivedsectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Receivedsections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Receivedsections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Receivedsections
    **/
    _count?: true | ReceivedsectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReceivedsectionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReceivedsectionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReceivedsectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReceivedsectionMaxAggregateInputType
  }

  export type GetReceivedsectionAggregateType<T extends ReceivedsectionAggregateArgs> = {
        [P in keyof T & keyof AggregateReceivedsection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReceivedsection[P]>
      : GetScalarType<T[P], AggregateReceivedsection[P]>
  }




  export type ReceivedsectionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReceivedsectionWhereInput
    orderBy?: ReceivedsectionOrderByWithAggregationInput | ReceivedsectionOrderByWithAggregationInput[]
    by: ReceivedsectionScalarFieldEnum[] | ReceivedsectionScalarFieldEnum
    having?: ReceivedsectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReceivedsectionCountAggregateInputType | true
    _avg?: ReceivedsectionAvgAggregateInputType
    _sum?: ReceivedsectionSumAggregateInputType
    _min?: ReceivedsectionMinAggregateInputType
    _max?: ReceivedsectionMaxAggregateInputType
  }

  export type ReceivedsectionGroupByOutputType = {
    id: number
    weight: number
    touch: number
    purity: number
    jobcardId: number | null
    goldsmithId: number | null
    createdAt: Date
    updatedAt: Date
    _count: ReceivedsectionCountAggregateOutputType | null
    _avg: ReceivedsectionAvgAggregateOutputType | null
    _sum: ReceivedsectionSumAggregateOutputType | null
    _min: ReceivedsectionMinAggregateOutputType | null
    _max: ReceivedsectionMaxAggregateOutputType | null
  }

  type GetReceivedsectionGroupByPayload<T extends ReceivedsectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReceivedsectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReceivedsectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReceivedsectionGroupByOutputType[P]>
            : GetScalarType<T[P], ReceivedsectionGroupByOutputType[P]>
        }
      >
    >


  export type ReceivedsectionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    weight?: boolean
    touch?: boolean
    purity?: boolean
    jobcardId?: boolean
    goldsmithId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    jobcard?: boolean | Receivedsection$jobcardArgs<ExtArgs>
    goldsmith?: boolean | Receivedsection$goldsmithArgs<ExtArgs>
  }, ExtArgs["result"]["receivedsection"]>



  export type ReceivedsectionSelectScalar = {
    id?: boolean
    weight?: boolean
    touch?: boolean
    purity?: boolean
    jobcardId?: boolean
    goldsmithId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ReceivedsectionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "weight" | "touch" | "purity" | "jobcardId" | "goldsmithId" | "createdAt" | "updatedAt", ExtArgs["result"]["receivedsection"]>
  export type ReceivedsectionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jobcard?: boolean | Receivedsection$jobcardArgs<ExtArgs>
    goldsmith?: boolean | Receivedsection$goldsmithArgs<ExtArgs>
  }

  export type $ReceivedsectionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Receivedsection"
    objects: {
      jobcard: Prisma.$JobcardPayload<ExtArgs> | null
      goldsmith: Prisma.$GoldsmithPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      weight: number
      touch: number
      purity: number
      jobcardId: number | null
      goldsmithId: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["receivedsection"]>
    composites: {}
  }

  type ReceivedsectionGetPayload<S extends boolean | null | undefined | ReceivedsectionDefaultArgs> = $Result.GetResult<Prisma.$ReceivedsectionPayload, S>

  type ReceivedsectionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReceivedsectionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReceivedsectionCountAggregateInputType | true
    }

  export interface ReceivedsectionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Receivedsection'], meta: { name: 'Receivedsection' } }
    /**
     * Find zero or one Receivedsection that matches the filter.
     * @param {ReceivedsectionFindUniqueArgs} args - Arguments to find a Receivedsection
     * @example
     * // Get one Receivedsection
     * const receivedsection = await prisma.receivedsection.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReceivedsectionFindUniqueArgs>(args: SelectSubset<T, ReceivedsectionFindUniqueArgs<ExtArgs>>): Prisma__ReceivedsectionClient<$Result.GetResult<Prisma.$ReceivedsectionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Receivedsection that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReceivedsectionFindUniqueOrThrowArgs} args - Arguments to find a Receivedsection
     * @example
     * // Get one Receivedsection
     * const receivedsection = await prisma.receivedsection.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReceivedsectionFindUniqueOrThrowArgs>(args: SelectSubset<T, ReceivedsectionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReceivedsectionClient<$Result.GetResult<Prisma.$ReceivedsectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Receivedsection that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceivedsectionFindFirstArgs} args - Arguments to find a Receivedsection
     * @example
     * // Get one Receivedsection
     * const receivedsection = await prisma.receivedsection.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReceivedsectionFindFirstArgs>(args?: SelectSubset<T, ReceivedsectionFindFirstArgs<ExtArgs>>): Prisma__ReceivedsectionClient<$Result.GetResult<Prisma.$ReceivedsectionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Receivedsection that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceivedsectionFindFirstOrThrowArgs} args - Arguments to find a Receivedsection
     * @example
     * // Get one Receivedsection
     * const receivedsection = await prisma.receivedsection.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReceivedsectionFindFirstOrThrowArgs>(args?: SelectSubset<T, ReceivedsectionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReceivedsectionClient<$Result.GetResult<Prisma.$ReceivedsectionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Receivedsections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceivedsectionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Receivedsections
     * const receivedsections = await prisma.receivedsection.findMany()
     * 
     * // Get first 10 Receivedsections
     * const receivedsections = await prisma.receivedsection.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const receivedsectionWithIdOnly = await prisma.receivedsection.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReceivedsectionFindManyArgs>(args?: SelectSubset<T, ReceivedsectionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReceivedsectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Receivedsection.
     * @param {ReceivedsectionCreateArgs} args - Arguments to create a Receivedsection.
     * @example
     * // Create one Receivedsection
     * const Receivedsection = await prisma.receivedsection.create({
     *   data: {
     *     // ... data to create a Receivedsection
     *   }
     * })
     * 
     */
    create<T extends ReceivedsectionCreateArgs>(args: SelectSubset<T, ReceivedsectionCreateArgs<ExtArgs>>): Prisma__ReceivedsectionClient<$Result.GetResult<Prisma.$ReceivedsectionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Receivedsections.
     * @param {ReceivedsectionCreateManyArgs} args - Arguments to create many Receivedsections.
     * @example
     * // Create many Receivedsections
     * const receivedsection = await prisma.receivedsection.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReceivedsectionCreateManyArgs>(args?: SelectSubset<T, ReceivedsectionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Receivedsection.
     * @param {ReceivedsectionDeleteArgs} args - Arguments to delete one Receivedsection.
     * @example
     * // Delete one Receivedsection
     * const Receivedsection = await prisma.receivedsection.delete({
     *   where: {
     *     // ... filter to delete one Receivedsection
     *   }
     * })
     * 
     */
    delete<T extends ReceivedsectionDeleteArgs>(args: SelectSubset<T, ReceivedsectionDeleteArgs<ExtArgs>>): Prisma__ReceivedsectionClient<$Result.GetResult<Prisma.$ReceivedsectionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Receivedsection.
     * @param {ReceivedsectionUpdateArgs} args - Arguments to update one Receivedsection.
     * @example
     * // Update one Receivedsection
     * const receivedsection = await prisma.receivedsection.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReceivedsectionUpdateArgs>(args: SelectSubset<T, ReceivedsectionUpdateArgs<ExtArgs>>): Prisma__ReceivedsectionClient<$Result.GetResult<Prisma.$ReceivedsectionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Receivedsections.
     * @param {ReceivedsectionDeleteManyArgs} args - Arguments to filter Receivedsections to delete.
     * @example
     * // Delete a few Receivedsections
     * const { count } = await prisma.receivedsection.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReceivedsectionDeleteManyArgs>(args?: SelectSubset<T, ReceivedsectionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Receivedsections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceivedsectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Receivedsections
     * const receivedsection = await prisma.receivedsection.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReceivedsectionUpdateManyArgs>(args: SelectSubset<T, ReceivedsectionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Receivedsection.
     * @param {ReceivedsectionUpsertArgs} args - Arguments to update or create a Receivedsection.
     * @example
     * // Update or create a Receivedsection
     * const receivedsection = await prisma.receivedsection.upsert({
     *   create: {
     *     // ... data to create a Receivedsection
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Receivedsection we want to update
     *   }
     * })
     */
    upsert<T extends ReceivedsectionUpsertArgs>(args: SelectSubset<T, ReceivedsectionUpsertArgs<ExtArgs>>): Prisma__ReceivedsectionClient<$Result.GetResult<Prisma.$ReceivedsectionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Receivedsections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceivedsectionCountArgs} args - Arguments to filter Receivedsections to count.
     * @example
     * // Count the number of Receivedsections
     * const count = await prisma.receivedsection.count({
     *   where: {
     *     // ... the filter for the Receivedsections we want to count
     *   }
     * })
    **/
    count<T extends ReceivedsectionCountArgs>(
      args?: Subset<T, ReceivedsectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReceivedsectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Receivedsection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceivedsectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReceivedsectionAggregateArgs>(args: Subset<T, ReceivedsectionAggregateArgs>): Prisma.PrismaPromise<GetReceivedsectionAggregateType<T>>

    /**
     * Group by Receivedsection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceivedsectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReceivedsectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReceivedsectionGroupByArgs['orderBy'] }
        : { orderBy?: ReceivedsectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReceivedsectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReceivedsectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Receivedsection model
   */
  readonly fields: ReceivedsectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Receivedsection.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReceivedsectionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    jobcard<T extends Receivedsection$jobcardArgs<ExtArgs> = {}>(args?: Subset<T, Receivedsection$jobcardArgs<ExtArgs>>): Prisma__JobcardClient<$Result.GetResult<Prisma.$JobcardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    goldsmith<T extends Receivedsection$goldsmithArgs<ExtArgs> = {}>(args?: Subset<T, Receivedsection$goldsmithArgs<ExtArgs>>): Prisma__GoldsmithClient<$Result.GetResult<Prisma.$GoldsmithPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Receivedsection model
   */
  interface ReceivedsectionFieldRefs {
    readonly id: FieldRef<"Receivedsection", 'Int'>
    readonly weight: FieldRef<"Receivedsection", 'Float'>
    readonly touch: FieldRef<"Receivedsection", 'Float'>
    readonly purity: FieldRef<"Receivedsection", 'Float'>
    readonly jobcardId: FieldRef<"Receivedsection", 'Int'>
    readonly goldsmithId: FieldRef<"Receivedsection", 'Int'>
    readonly createdAt: FieldRef<"Receivedsection", 'DateTime'>
    readonly updatedAt: FieldRef<"Receivedsection", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Receivedsection findUnique
   */
  export type ReceivedsectionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receivedsection
     */
    select?: ReceivedsectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Receivedsection
     */
    omit?: ReceivedsectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceivedsectionInclude<ExtArgs> | null
    /**
     * Filter, which Receivedsection to fetch.
     */
    where: ReceivedsectionWhereUniqueInput
  }

  /**
   * Receivedsection findUniqueOrThrow
   */
  export type ReceivedsectionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receivedsection
     */
    select?: ReceivedsectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Receivedsection
     */
    omit?: ReceivedsectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceivedsectionInclude<ExtArgs> | null
    /**
     * Filter, which Receivedsection to fetch.
     */
    where: ReceivedsectionWhereUniqueInput
  }

  /**
   * Receivedsection findFirst
   */
  export type ReceivedsectionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receivedsection
     */
    select?: ReceivedsectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Receivedsection
     */
    omit?: ReceivedsectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceivedsectionInclude<ExtArgs> | null
    /**
     * Filter, which Receivedsection to fetch.
     */
    where?: ReceivedsectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Receivedsections to fetch.
     */
    orderBy?: ReceivedsectionOrderByWithRelationInput | ReceivedsectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Receivedsections.
     */
    cursor?: ReceivedsectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Receivedsections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Receivedsections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Receivedsections.
     */
    distinct?: ReceivedsectionScalarFieldEnum | ReceivedsectionScalarFieldEnum[]
  }

  /**
   * Receivedsection findFirstOrThrow
   */
  export type ReceivedsectionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receivedsection
     */
    select?: ReceivedsectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Receivedsection
     */
    omit?: ReceivedsectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceivedsectionInclude<ExtArgs> | null
    /**
     * Filter, which Receivedsection to fetch.
     */
    where?: ReceivedsectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Receivedsections to fetch.
     */
    orderBy?: ReceivedsectionOrderByWithRelationInput | ReceivedsectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Receivedsections.
     */
    cursor?: ReceivedsectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Receivedsections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Receivedsections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Receivedsections.
     */
    distinct?: ReceivedsectionScalarFieldEnum | ReceivedsectionScalarFieldEnum[]
  }

  /**
   * Receivedsection findMany
   */
  export type ReceivedsectionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receivedsection
     */
    select?: ReceivedsectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Receivedsection
     */
    omit?: ReceivedsectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceivedsectionInclude<ExtArgs> | null
    /**
     * Filter, which Receivedsections to fetch.
     */
    where?: ReceivedsectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Receivedsections to fetch.
     */
    orderBy?: ReceivedsectionOrderByWithRelationInput | ReceivedsectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Receivedsections.
     */
    cursor?: ReceivedsectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Receivedsections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Receivedsections.
     */
    skip?: number
    distinct?: ReceivedsectionScalarFieldEnum | ReceivedsectionScalarFieldEnum[]
  }

  /**
   * Receivedsection create
   */
  export type ReceivedsectionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receivedsection
     */
    select?: ReceivedsectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Receivedsection
     */
    omit?: ReceivedsectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceivedsectionInclude<ExtArgs> | null
    /**
     * The data needed to create a Receivedsection.
     */
    data: XOR<ReceivedsectionCreateInput, ReceivedsectionUncheckedCreateInput>
  }

  /**
   * Receivedsection createMany
   */
  export type ReceivedsectionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Receivedsections.
     */
    data: ReceivedsectionCreateManyInput | ReceivedsectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Receivedsection update
   */
  export type ReceivedsectionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receivedsection
     */
    select?: ReceivedsectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Receivedsection
     */
    omit?: ReceivedsectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceivedsectionInclude<ExtArgs> | null
    /**
     * The data needed to update a Receivedsection.
     */
    data: XOR<ReceivedsectionUpdateInput, ReceivedsectionUncheckedUpdateInput>
    /**
     * Choose, which Receivedsection to update.
     */
    where: ReceivedsectionWhereUniqueInput
  }

  /**
   * Receivedsection updateMany
   */
  export type ReceivedsectionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Receivedsections.
     */
    data: XOR<ReceivedsectionUpdateManyMutationInput, ReceivedsectionUncheckedUpdateManyInput>
    /**
     * Filter which Receivedsections to update
     */
    where?: ReceivedsectionWhereInput
    /**
     * Limit how many Receivedsections to update.
     */
    limit?: number
  }

  /**
   * Receivedsection upsert
   */
  export type ReceivedsectionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receivedsection
     */
    select?: ReceivedsectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Receivedsection
     */
    omit?: ReceivedsectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceivedsectionInclude<ExtArgs> | null
    /**
     * The filter to search for the Receivedsection to update in case it exists.
     */
    where: ReceivedsectionWhereUniqueInput
    /**
     * In case the Receivedsection found by the `where` argument doesn't exist, create a new Receivedsection with this data.
     */
    create: XOR<ReceivedsectionCreateInput, ReceivedsectionUncheckedCreateInput>
    /**
     * In case the Receivedsection was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReceivedsectionUpdateInput, ReceivedsectionUncheckedUpdateInput>
  }

  /**
   * Receivedsection delete
   */
  export type ReceivedsectionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receivedsection
     */
    select?: ReceivedsectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Receivedsection
     */
    omit?: ReceivedsectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceivedsectionInclude<ExtArgs> | null
    /**
     * Filter which Receivedsection to delete.
     */
    where: ReceivedsectionWhereUniqueInput
  }

  /**
   * Receivedsection deleteMany
   */
  export type ReceivedsectionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Receivedsections to delete
     */
    where?: ReceivedsectionWhereInput
    /**
     * Limit how many Receivedsections to delete.
     */
    limit?: number
  }

  /**
   * Receivedsection.jobcard
   */
  export type Receivedsection$jobcardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobcard
     */
    select?: JobcardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Jobcard
     */
    omit?: JobcardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobcardInclude<ExtArgs> | null
    where?: JobcardWhereInput
  }

  /**
   * Receivedsection.goldsmith
   */
  export type Receivedsection$goldsmithArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Goldsmith
     */
    select?: GoldsmithSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Goldsmith
     */
    omit?: GoldsmithOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoldsmithInclude<ExtArgs> | null
    where?: GoldsmithWhereInput
  }

  /**
   * Receivedsection without action
   */
  export type ReceivedsectionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receivedsection
     */
    select?: ReceivedsectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Receivedsection
     */
    omit?: ReceivedsectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceivedsectionInclude<ExtArgs> | null
  }


  /**
   * Model Balances
   */

  export type AggregateBalances = {
    _count: BalancesCountAggregateOutputType | null
    _avg: BalancesAvgAggregateOutputType | null
    _sum: BalancesSumAggregateOutputType | null
    _min: BalancesMinAggregateOutputType | null
    _max: BalancesMaxAggregateOutputType | null
  }

  export type BalancesAvgAggregateOutputType = {
    id: number | null
    goldsmithId: number | null
    totalDeliveries: number | null
    totalItemWeight: number | null
    totalNetWeight: number | null
    totalPurity: number | null
    totalReceivedWeight: number | null
    totalReceivedTouch: number | null
    totalReceivedPurity: number | null
  }

  export type BalancesSumAggregateOutputType = {
    id: number | null
    goldsmithId: number | null
    totalDeliveries: number | null
    totalItemWeight: number | null
    totalNetWeight: number | null
    totalPurity: number | null
    totalReceivedWeight: number | null
    totalReceivedTouch: number | null
    totalReceivedPurity: number | null
  }

  export type BalancesMinAggregateOutputType = {
    id: number | null
    goldsmithId: number | null
    totalDeliveries: number | null
    totalItemWeight: number | null
    totalNetWeight: number | null
    totalPurity: number | null
    totalReceivedWeight: number | null
    totalReceivedTouch: number | null
    totalReceivedPurity: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BalancesMaxAggregateOutputType = {
    id: number | null
    goldsmithId: number | null
    totalDeliveries: number | null
    totalItemWeight: number | null
    totalNetWeight: number | null
    totalPurity: number | null
    totalReceivedWeight: number | null
    totalReceivedTouch: number | null
    totalReceivedPurity: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BalancesCountAggregateOutputType = {
    id: number
    goldsmithId: number
    totalDeliveries: number
    totalItemWeight: number
    totalNetWeight: number
    totalPurity: number
    totalReceivedWeight: number
    totalReceivedTouch: number
    totalReceivedPurity: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BalancesAvgAggregateInputType = {
    id?: true
    goldsmithId?: true
    totalDeliveries?: true
    totalItemWeight?: true
    totalNetWeight?: true
    totalPurity?: true
    totalReceivedWeight?: true
    totalReceivedTouch?: true
    totalReceivedPurity?: true
  }

  export type BalancesSumAggregateInputType = {
    id?: true
    goldsmithId?: true
    totalDeliveries?: true
    totalItemWeight?: true
    totalNetWeight?: true
    totalPurity?: true
    totalReceivedWeight?: true
    totalReceivedTouch?: true
    totalReceivedPurity?: true
  }

  export type BalancesMinAggregateInputType = {
    id?: true
    goldsmithId?: true
    totalDeliveries?: true
    totalItemWeight?: true
    totalNetWeight?: true
    totalPurity?: true
    totalReceivedWeight?: true
    totalReceivedTouch?: true
    totalReceivedPurity?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BalancesMaxAggregateInputType = {
    id?: true
    goldsmithId?: true
    totalDeliveries?: true
    totalItemWeight?: true
    totalNetWeight?: true
    totalPurity?: true
    totalReceivedWeight?: true
    totalReceivedTouch?: true
    totalReceivedPurity?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BalancesCountAggregateInputType = {
    id?: true
    goldsmithId?: true
    totalDeliveries?: true
    totalItemWeight?: true
    totalNetWeight?: true
    totalPurity?: true
    totalReceivedWeight?: true
    totalReceivedTouch?: true
    totalReceivedPurity?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BalancesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Balances to aggregate.
     */
    where?: BalancesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Balances to fetch.
     */
    orderBy?: BalancesOrderByWithRelationInput | BalancesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BalancesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Balances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Balances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Balances
    **/
    _count?: true | BalancesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BalancesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BalancesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BalancesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BalancesMaxAggregateInputType
  }

  export type GetBalancesAggregateType<T extends BalancesAggregateArgs> = {
        [P in keyof T & keyof AggregateBalances]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBalances[P]>
      : GetScalarType<T[P], AggregateBalances[P]>
  }




  export type BalancesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BalancesWhereInput
    orderBy?: BalancesOrderByWithAggregationInput | BalancesOrderByWithAggregationInput[]
    by: BalancesScalarFieldEnum[] | BalancesScalarFieldEnum
    having?: BalancesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BalancesCountAggregateInputType | true
    _avg?: BalancesAvgAggregateInputType
    _sum?: BalancesSumAggregateInputType
    _min?: BalancesMinAggregateInputType
    _max?: BalancesMaxAggregateInputType
  }

  export type BalancesGroupByOutputType = {
    id: number
    goldsmithId: number
    totalDeliveries: number
    totalItemWeight: number
    totalNetWeight: number
    totalPurity: number
    totalReceivedWeight: number
    totalReceivedTouch: number
    totalReceivedPurity: number
    createdAt: Date
    updatedAt: Date
    _count: BalancesCountAggregateOutputType | null
    _avg: BalancesAvgAggregateOutputType | null
    _sum: BalancesSumAggregateOutputType | null
    _min: BalancesMinAggregateOutputType | null
    _max: BalancesMaxAggregateOutputType | null
  }

  type GetBalancesGroupByPayload<T extends BalancesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BalancesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BalancesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BalancesGroupByOutputType[P]>
            : GetScalarType<T[P], BalancesGroupByOutputType[P]>
        }
      >
    >


  export type BalancesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    goldsmithId?: boolean
    totalDeliveries?: boolean
    totalItemWeight?: boolean
    totalNetWeight?: boolean
    totalPurity?: boolean
    totalReceivedWeight?: boolean
    totalReceivedTouch?: boolean
    totalReceivedPurity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    goldsmith?: boolean | GoldsmithDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["balances"]>



  export type BalancesSelectScalar = {
    id?: boolean
    goldsmithId?: boolean
    totalDeliveries?: boolean
    totalItemWeight?: boolean
    totalNetWeight?: boolean
    totalPurity?: boolean
    totalReceivedWeight?: boolean
    totalReceivedTouch?: boolean
    totalReceivedPurity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BalancesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "goldsmithId" | "totalDeliveries" | "totalItemWeight" | "totalNetWeight" | "totalPurity" | "totalReceivedWeight" | "totalReceivedTouch" | "totalReceivedPurity" | "createdAt" | "updatedAt", ExtArgs["result"]["balances"]>
  export type BalancesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    goldsmith?: boolean | GoldsmithDefaultArgs<ExtArgs>
  }

  export type $BalancesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Balances"
    objects: {
      goldsmith: Prisma.$GoldsmithPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      goldsmithId: number
      totalDeliveries: number
      totalItemWeight: number
      totalNetWeight: number
      totalPurity: number
      totalReceivedWeight: number
      totalReceivedTouch: number
      totalReceivedPurity: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["balances"]>
    composites: {}
  }

  type BalancesGetPayload<S extends boolean | null | undefined | BalancesDefaultArgs> = $Result.GetResult<Prisma.$BalancesPayload, S>

  type BalancesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BalancesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BalancesCountAggregateInputType | true
    }

  export interface BalancesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Balances'], meta: { name: 'Balances' } }
    /**
     * Find zero or one Balances that matches the filter.
     * @param {BalancesFindUniqueArgs} args - Arguments to find a Balances
     * @example
     * // Get one Balances
     * const balances = await prisma.balances.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BalancesFindUniqueArgs>(args: SelectSubset<T, BalancesFindUniqueArgs<ExtArgs>>): Prisma__BalancesClient<$Result.GetResult<Prisma.$BalancesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Balances that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BalancesFindUniqueOrThrowArgs} args - Arguments to find a Balances
     * @example
     * // Get one Balances
     * const balances = await prisma.balances.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BalancesFindUniqueOrThrowArgs>(args: SelectSubset<T, BalancesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BalancesClient<$Result.GetResult<Prisma.$BalancesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Balances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BalancesFindFirstArgs} args - Arguments to find a Balances
     * @example
     * // Get one Balances
     * const balances = await prisma.balances.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BalancesFindFirstArgs>(args?: SelectSubset<T, BalancesFindFirstArgs<ExtArgs>>): Prisma__BalancesClient<$Result.GetResult<Prisma.$BalancesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Balances that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BalancesFindFirstOrThrowArgs} args - Arguments to find a Balances
     * @example
     * // Get one Balances
     * const balances = await prisma.balances.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BalancesFindFirstOrThrowArgs>(args?: SelectSubset<T, BalancesFindFirstOrThrowArgs<ExtArgs>>): Prisma__BalancesClient<$Result.GetResult<Prisma.$BalancesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Balances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BalancesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Balances
     * const balances = await prisma.balances.findMany()
     * 
     * // Get first 10 Balances
     * const balances = await prisma.balances.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const balancesWithIdOnly = await prisma.balances.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BalancesFindManyArgs>(args?: SelectSubset<T, BalancesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BalancesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Balances.
     * @param {BalancesCreateArgs} args - Arguments to create a Balances.
     * @example
     * // Create one Balances
     * const Balances = await prisma.balances.create({
     *   data: {
     *     // ... data to create a Balances
     *   }
     * })
     * 
     */
    create<T extends BalancesCreateArgs>(args: SelectSubset<T, BalancesCreateArgs<ExtArgs>>): Prisma__BalancesClient<$Result.GetResult<Prisma.$BalancesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Balances.
     * @param {BalancesCreateManyArgs} args - Arguments to create many Balances.
     * @example
     * // Create many Balances
     * const balances = await prisma.balances.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BalancesCreateManyArgs>(args?: SelectSubset<T, BalancesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Balances.
     * @param {BalancesDeleteArgs} args - Arguments to delete one Balances.
     * @example
     * // Delete one Balances
     * const Balances = await prisma.balances.delete({
     *   where: {
     *     // ... filter to delete one Balances
     *   }
     * })
     * 
     */
    delete<T extends BalancesDeleteArgs>(args: SelectSubset<T, BalancesDeleteArgs<ExtArgs>>): Prisma__BalancesClient<$Result.GetResult<Prisma.$BalancesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Balances.
     * @param {BalancesUpdateArgs} args - Arguments to update one Balances.
     * @example
     * // Update one Balances
     * const balances = await prisma.balances.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BalancesUpdateArgs>(args: SelectSubset<T, BalancesUpdateArgs<ExtArgs>>): Prisma__BalancesClient<$Result.GetResult<Prisma.$BalancesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Balances.
     * @param {BalancesDeleteManyArgs} args - Arguments to filter Balances to delete.
     * @example
     * // Delete a few Balances
     * const { count } = await prisma.balances.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BalancesDeleteManyArgs>(args?: SelectSubset<T, BalancesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Balances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BalancesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Balances
     * const balances = await prisma.balances.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BalancesUpdateManyArgs>(args: SelectSubset<T, BalancesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Balances.
     * @param {BalancesUpsertArgs} args - Arguments to update or create a Balances.
     * @example
     * // Update or create a Balances
     * const balances = await prisma.balances.upsert({
     *   create: {
     *     // ... data to create a Balances
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Balances we want to update
     *   }
     * })
     */
    upsert<T extends BalancesUpsertArgs>(args: SelectSubset<T, BalancesUpsertArgs<ExtArgs>>): Prisma__BalancesClient<$Result.GetResult<Prisma.$BalancesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Balances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BalancesCountArgs} args - Arguments to filter Balances to count.
     * @example
     * // Count the number of Balances
     * const count = await prisma.balances.count({
     *   where: {
     *     // ... the filter for the Balances we want to count
     *   }
     * })
    **/
    count<T extends BalancesCountArgs>(
      args?: Subset<T, BalancesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BalancesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Balances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BalancesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BalancesAggregateArgs>(args: Subset<T, BalancesAggregateArgs>): Prisma.PrismaPromise<GetBalancesAggregateType<T>>

    /**
     * Group by Balances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BalancesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BalancesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BalancesGroupByArgs['orderBy'] }
        : { orderBy?: BalancesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BalancesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBalancesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Balances model
   */
  readonly fields: BalancesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Balances.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BalancesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    goldsmith<T extends GoldsmithDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GoldsmithDefaultArgs<ExtArgs>>): Prisma__GoldsmithClient<$Result.GetResult<Prisma.$GoldsmithPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Balances model
   */
  interface BalancesFieldRefs {
    readonly id: FieldRef<"Balances", 'Int'>
    readonly goldsmithId: FieldRef<"Balances", 'Int'>
    readonly totalDeliveries: FieldRef<"Balances", 'Int'>
    readonly totalItemWeight: FieldRef<"Balances", 'Float'>
    readonly totalNetWeight: FieldRef<"Balances", 'Float'>
    readonly totalPurity: FieldRef<"Balances", 'Float'>
    readonly totalReceivedWeight: FieldRef<"Balances", 'Float'>
    readonly totalReceivedTouch: FieldRef<"Balances", 'Float'>
    readonly totalReceivedPurity: FieldRef<"Balances", 'Float'>
    readonly createdAt: FieldRef<"Balances", 'DateTime'>
    readonly updatedAt: FieldRef<"Balances", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Balances findUnique
   */
  export type BalancesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Balances
     */
    select?: BalancesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Balances
     */
    omit?: BalancesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalancesInclude<ExtArgs> | null
    /**
     * Filter, which Balances to fetch.
     */
    where: BalancesWhereUniqueInput
  }

  /**
   * Balances findUniqueOrThrow
   */
  export type BalancesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Balances
     */
    select?: BalancesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Balances
     */
    omit?: BalancesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalancesInclude<ExtArgs> | null
    /**
     * Filter, which Balances to fetch.
     */
    where: BalancesWhereUniqueInput
  }

  /**
   * Balances findFirst
   */
  export type BalancesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Balances
     */
    select?: BalancesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Balances
     */
    omit?: BalancesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalancesInclude<ExtArgs> | null
    /**
     * Filter, which Balances to fetch.
     */
    where?: BalancesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Balances to fetch.
     */
    orderBy?: BalancesOrderByWithRelationInput | BalancesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Balances.
     */
    cursor?: BalancesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Balances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Balances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Balances.
     */
    distinct?: BalancesScalarFieldEnum | BalancesScalarFieldEnum[]
  }

  /**
   * Balances findFirstOrThrow
   */
  export type BalancesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Balances
     */
    select?: BalancesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Balances
     */
    omit?: BalancesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalancesInclude<ExtArgs> | null
    /**
     * Filter, which Balances to fetch.
     */
    where?: BalancesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Balances to fetch.
     */
    orderBy?: BalancesOrderByWithRelationInput | BalancesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Balances.
     */
    cursor?: BalancesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Balances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Balances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Balances.
     */
    distinct?: BalancesScalarFieldEnum | BalancesScalarFieldEnum[]
  }

  /**
   * Balances findMany
   */
  export type BalancesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Balances
     */
    select?: BalancesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Balances
     */
    omit?: BalancesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalancesInclude<ExtArgs> | null
    /**
     * Filter, which Balances to fetch.
     */
    where?: BalancesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Balances to fetch.
     */
    orderBy?: BalancesOrderByWithRelationInput | BalancesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Balances.
     */
    cursor?: BalancesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Balances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Balances.
     */
    skip?: number
    distinct?: BalancesScalarFieldEnum | BalancesScalarFieldEnum[]
  }

  /**
   * Balances create
   */
  export type BalancesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Balances
     */
    select?: BalancesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Balances
     */
    omit?: BalancesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalancesInclude<ExtArgs> | null
    /**
     * The data needed to create a Balances.
     */
    data: XOR<BalancesCreateInput, BalancesUncheckedCreateInput>
  }

  /**
   * Balances createMany
   */
  export type BalancesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Balances.
     */
    data: BalancesCreateManyInput | BalancesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Balances update
   */
  export type BalancesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Balances
     */
    select?: BalancesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Balances
     */
    omit?: BalancesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalancesInclude<ExtArgs> | null
    /**
     * The data needed to update a Balances.
     */
    data: XOR<BalancesUpdateInput, BalancesUncheckedUpdateInput>
    /**
     * Choose, which Balances to update.
     */
    where: BalancesWhereUniqueInput
  }

  /**
   * Balances updateMany
   */
  export type BalancesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Balances.
     */
    data: XOR<BalancesUpdateManyMutationInput, BalancesUncheckedUpdateManyInput>
    /**
     * Filter which Balances to update
     */
    where?: BalancesWhereInput
    /**
     * Limit how many Balances to update.
     */
    limit?: number
  }

  /**
   * Balances upsert
   */
  export type BalancesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Balances
     */
    select?: BalancesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Balances
     */
    omit?: BalancesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalancesInclude<ExtArgs> | null
    /**
     * The filter to search for the Balances to update in case it exists.
     */
    where: BalancesWhereUniqueInput
    /**
     * In case the Balances found by the `where` argument doesn't exist, create a new Balances with this data.
     */
    create: XOR<BalancesCreateInput, BalancesUncheckedCreateInput>
    /**
     * In case the Balances was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BalancesUpdateInput, BalancesUncheckedUpdateInput>
  }

  /**
   * Balances delete
   */
  export type BalancesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Balances
     */
    select?: BalancesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Balances
     */
    omit?: BalancesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalancesInclude<ExtArgs> | null
    /**
     * Filter which Balances to delete.
     */
    where: BalancesWhereUniqueInput
  }

  /**
   * Balances deleteMany
   */
  export type BalancesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Balances to delete
     */
    where?: BalancesWhereInput
    /**
     * Limit how many Balances to delete.
     */
    limit?: number
  }

  /**
   * Balances without action
   */
  export type BalancesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Balances
     */
    select?: BalancesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Balances
     */
    omit?: BalancesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalancesInclude<ExtArgs> | null
  }


  /**
   * Model Repair
   */

  export type AggregateRepair = {
    _count: RepairCountAggregateOutputType | null
    _avg: RepairAvgAggregateOutputType | null
    _sum: RepairSumAggregateOutputType | null
    _min: RepairMinAggregateOutputType | null
    _max: RepairMaxAggregateOutputType | null
  }

  export type RepairAvgAggregateOutputType = {
    id: number | null
    goldsmithId: number | null
    totalGiven: number | null
    totalItem: number | null
    stone: number | null
    touch: number | null
    netWeight: number | null
  }

  export type RepairSumAggregateOutputType = {
    id: number | null
    goldsmithId: number | null
    totalGiven: number | null
    totalItem: number | null
    stone: number | null
    touch: number | null
    netWeight: number | null
  }

  export type RepairMinAggregateOutputType = {
    id: number | null
    goldsmithId: number | null
    totalGiven: number | null
    totalItem: number | null
    stone: number | null
    wastageType: string | null
    touch: number | null
    netWeight: number | null
    createdAt: Date | null
  }

  export type RepairMaxAggregateOutputType = {
    id: number | null
    goldsmithId: number | null
    totalGiven: number | null
    totalItem: number | null
    stone: number | null
    wastageType: string | null
    touch: number | null
    netWeight: number | null
    createdAt: Date | null
  }

  export type RepairCountAggregateOutputType = {
    id: number
    goldsmithId: number
    givenWeights: number
    totalGiven: number
    itemWeights: number
    totalItem: number
    stone: number
    wastageType: number
    touch: number
    netWeight: number
    createdAt: number
    _all: number
  }


  export type RepairAvgAggregateInputType = {
    id?: true
    goldsmithId?: true
    totalGiven?: true
    totalItem?: true
    stone?: true
    touch?: true
    netWeight?: true
  }

  export type RepairSumAggregateInputType = {
    id?: true
    goldsmithId?: true
    totalGiven?: true
    totalItem?: true
    stone?: true
    touch?: true
    netWeight?: true
  }

  export type RepairMinAggregateInputType = {
    id?: true
    goldsmithId?: true
    totalGiven?: true
    totalItem?: true
    stone?: true
    wastageType?: true
    touch?: true
    netWeight?: true
    createdAt?: true
  }

  export type RepairMaxAggregateInputType = {
    id?: true
    goldsmithId?: true
    totalGiven?: true
    totalItem?: true
    stone?: true
    wastageType?: true
    touch?: true
    netWeight?: true
    createdAt?: true
  }

  export type RepairCountAggregateInputType = {
    id?: true
    goldsmithId?: true
    givenWeights?: true
    totalGiven?: true
    itemWeights?: true
    totalItem?: true
    stone?: true
    wastageType?: true
    touch?: true
    netWeight?: true
    createdAt?: true
    _all?: true
  }

  export type RepairAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Repair to aggregate.
     */
    where?: RepairWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Repairs to fetch.
     */
    orderBy?: RepairOrderByWithRelationInput | RepairOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RepairWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Repairs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Repairs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Repairs
    **/
    _count?: true | RepairCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RepairAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RepairSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RepairMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RepairMaxAggregateInputType
  }

  export type GetRepairAggregateType<T extends RepairAggregateArgs> = {
        [P in keyof T & keyof AggregateRepair]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRepair[P]>
      : GetScalarType<T[P], AggregateRepair[P]>
  }




  export type RepairGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RepairWhereInput
    orderBy?: RepairOrderByWithAggregationInput | RepairOrderByWithAggregationInput[]
    by: RepairScalarFieldEnum[] | RepairScalarFieldEnum
    having?: RepairScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RepairCountAggregateInputType | true
    _avg?: RepairAvgAggregateInputType
    _sum?: RepairSumAggregateInputType
    _min?: RepairMinAggregateInputType
    _max?: RepairMaxAggregateInputType
  }

  export type RepairGroupByOutputType = {
    id: number
    goldsmithId: number
    givenWeights: JsonValue
    totalGiven: number
    itemWeights: JsonValue
    totalItem: number
    stone: number
    wastageType: string
    touch: number
    netWeight: number
    createdAt: Date
    _count: RepairCountAggregateOutputType | null
    _avg: RepairAvgAggregateOutputType | null
    _sum: RepairSumAggregateOutputType | null
    _min: RepairMinAggregateOutputType | null
    _max: RepairMaxAggregateOutputType | null
  }

  type GetRepairGroupByPayload<T extends RepairGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RepairGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RepairGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RepairGroupByOutputType[P]>
            : GetScalarType<T[P], RepairGroupByOutputType[P]>
        }
      >
    >


  export type RepairSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    goldsmithId?: boolean
    givenWeights?: boolean
    totalGiven?: boolean
    itemWeights?: boolean
    totalItem?: boolean
    stone?: boolean
    wastageType?: boolean
    touch?: boolean
    netWeight?: boolean
    createdAt?: boolean
    goldsmith?: boolean | GoldsmithDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["repair"]>



  export type RepairSelectScalar = {
    id?: boolean
    goldsmithId?: boolean
    givenWeights?: boolean
    totalGiven?: boolean
    itemWeights?: boolean
    totalItem?: boolean
    stone?: boolean
    wastageType?: boolean
    touch?: boolean
    netWeight?: boolean
    createdAt?: boolean
  }

  export type RepairOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "goldsmithId" | "givenWeights" | "totalGiven" | "itemWeights" | "totalItem" | "stone" | "wastageType" | "touch" | "netWeight" | "createdAt", ExtArgs["result"]["repair"]>
  export type RepairInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    goldsmith?: boolean | GoldsmithDefaultArgs<ExtArgs>
  }

  export type $RepairPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Repair"
    objects: {
      goldsmith: Prisma.$GoldsmithPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      goldsmithId: number
      givenWeights: Prisma.JsonValue
      totalGiven: number
      itemWeights: Prisma.JsonValue
      totalItem: number
      stone: number
      wastageType: string
      touch: number
      netWeight: number
      createdAt: Date
    }, ExtArgs["result"]["repair"]>
    composites: {}
  }

  type RepairGetPayload<S extends boolean | null | undefined | RepairDefaultArgs> = $Result.GetResult<Prisma.$RepairPayload, S>

  type RepairCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RepairFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RepairCountAggregateInputType | true
    }

  export interface RepairDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Repair'], meta: { name: 'Repair' } }
    /**
     * Find zero or one Repair that matches the filter.
     * @param {RepairFindUniqueArgs} args - Arguments to find a Repair
     * @example
     * // Get one Repair
     * const repair = await prisma.repair.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RepairFindUniqueArgs>(args: SelectSubset<T, RepairFindUniqueArgs<ExtArgs>>): Prisma__RepairClient<$Result.GetResult<Prisma.$RepairPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Repair that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RepairFindUniqueOrThrowArgs} args - Arguments to find a Repair
     * @example
     * // Get one Repair
     * const repair = await prisma.repair.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RepairFindUniqueOrThrowArgs>(args: SelectSubset<T, RepairFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RepairClient<$Result.GetResult<Prisma.$RepairPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Repair that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepairFindFirstArgs} args - Arguments to find a Repair
     * @example
     * // Get one Repair
     * const repair = await prisma.repair.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RepairFindFirstArgs>(args?: SelectSubset<T, RepairFindFirstArgs<ExtArgs>>): Prisma__RepairClient<$Result.GetResult<Prisma.$RepairPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Repair that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepairFindFirstOrThrowArgs} args - Arguments to find a Repair
     * @example
     * // Get one Repair
     * const repair = await prisma.repair.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RepairFindFirstOrThrowArgs>(args?: SelectSubset<T, RepairFindFirstOrThrowArgs<ExtArgs>>): Prisma__RepairClient<$Result.GetResult<Prisma.$RepairPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Repairs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepairFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Repairs
     * const repairs = await prisma.repair.findMany()
     * 
     * // Get first 10 Repairs
     * const repairs = await prisma.repair.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const repairWithIdOnly = await prisma.repair.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RepairFindManyArgs>(args?: SelectSubset<T, RepairFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RepairPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Repair.
     * @param {RepairCreateArgs} args - Arguments to create a Repair.
     * @example
     * // Create one Repair
     * const Repair = await prisma.repair.create({
     *   data: {
     *     // ... data to create a Repair
     *   }
     * })
     * 
     */
    create<T extends RepairCreateArgs>(args: SelectSubset<T, RepairCreateArgs<ExtArgs>>): Prisma__RepairClient<$Result.GetResult<Prisma.$RepairPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Repairs.
     * @param {RepairCreateManyArgs} args - Arguments to create many Repairs.
     * @example
     * // Create many Repairs
     * const repair = await prisma.repair.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RepairCreateManyArgs>(args?: SelectSubset<T, RepairCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Repair.
     * @param {RepairDeleteArgs} args - Arguments to delete one Repair.
     * @example
     * // Delete one Repair
     * const Repair = await prisma.repair.delete({
     *   where: {
     *     // ... filter to delete one Repair
     *   }
     * })
     * 
     */
    delete<T extends RepairDeleteArgs>(args: SelectSubset<T, RepairDeleteArgs<ExtArgs>>): Prisma__RepairClient<$Result.GetResult<Prisma.$RepairPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Repair.
     * @param {RepairUpdateArgs} args - Arguments to update one Repair.
     * @example
     * // Update one Repair
     * const repair = await prisma.repair.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RepairUpdateArgs>(args: SelectSubset<T, RepairUpdateArgs<ExtArgs>>): Prisma__RepairClient<$Result.GetResult<Prisma.$RepairPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Repairs.
     * @param {RepairDeleteManyArgs} args - Arguments to filter Repairs to delete.
     * @example
     * // Delete a few Repairs
     * const { count } = await prisma.repair.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RepairDeleteManyArgs>(args?: SelectSubset<T, RepairDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Repairs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepairUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Repairs
     * const repair = await prisma.repair.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RepairUpdateManyArgs>(args: SelectSubset<T, RepairUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Repair.
     * @param {RepairUpsertArgs} args - Arguments to update or create a Repair.
     * @example
     * // Update or create a Repair
     * const repair = await prisma.repair.upsert({
     *   create: {
     *     // ... data to create a Repair
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Repair we want to update
     *   }
     * })
     */
    upsert<T extends RepairUpsertArgs>(args: SelectSubset<T, RepairUpsertArgs<ExtArgs>>): Prisma__RepairClient<$Result.GetResult<Prisma.$RepairPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Repairs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepairCountArgs} args - Arguments to filter Repairs to count.
     * @example
     * // Count the number of Repairs
     * const count = await prisma.repair.count({
     *   where: {
     *     // ... the filter for the Repairs we want to count
     *   }
     * })
    **/
    count<T extends RepairCountArgs>(
      args?: Subset<T, RepairCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RepairCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Repair.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepairAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RepairAggregateArgs>(args: Subset<T, RepairAggregateArgs>): Prisma.PrismaPromise<GetRepairAggregateType<T>>

    /**
     * Group by Repair.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepairGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RepairGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RepairGroupByArgs['orderBy'] }
        : { orderBy?: RepairGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RepairGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRepairGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Repair model
   */
  readonly fields: RepairFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Repair.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RepairClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    goldsmith<T extends GoldsmithDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GoldsmithDefaultArgs<ExtArgs>>): Prisma__GoldsmithClient<$Result.GetResult<Prisma.$GoldsmithPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Repair model
   */
  interface RepairFieldRefs {
    readonly id: FieldRef<"Repair", 'Int'>
    readonly goldsmithId: FieldRef<"Repair", 'Int'>
    readonly givenWeights: FieldRef<"Repair", 'Json'>
    readonly totalGiven: FieldRef<"Repair", 'Float'>
    readonly itemWeights: FieldRef<"Repair", 'Json'>
    readonly totalItem: FieldRef<"Repair", 'Float'>
    readonly stone: FieldRef<"Repair", 'Float'>
    readonly wastageType: FieldRef<"Repair", 'String'>
    readonly touch: FieldRef<"Repair", 'Float'>
    readonly netWeight: FieldRef<"Repair", 'Float'>
    readonly createdAt: FieldRef<"Repair", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Repair findUnique
   */
  export type RepairFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Repair
     */
    select?: RepairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Repair
     */
    omit?: RepairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepairInclude<ExtArgs> | null
    /**
     * Filter, which Repair to fetch.
     */
    where: RepairWhereUniqueInput
  }

  /**
   * Repair findUniqueOrThrow
   */
  export type RepairFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Repair
     */
    select?: RepairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Repair
     */
    omit?: RepairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepairInclude<ExtArgs> | null
    /**
     * Filter, which Repair to fetch.
     */
    where: RepairWhereUniqueInput
  }

  /**
   * Repair findFirst
   */
  export type RepairFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Repair
     */
    select?: RepairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Repair
     */
    omit?: RepairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepairInclude<ExtArgs> | null
    /**
     * Filter, which Repair to fetch.
     */
    where?: RepairWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Repairs to fetch.
     */
    orderBy?: RepairOrderByWithRelationInput | RepairOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Repairs.
     */
    cursor?: RepairWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Repairs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Repairs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Repairs.
     */
    distinct?: RepairScalarFieldEnum | RepairScalarFieldEnum[]
  }

  /**
   * Repair findFirstOrThrow
   */
  export type RepairFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Repair
     */
    select?: RepairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Repair
     */
    omit?: RepairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepairInclude<ExtArgs> | null
    /**
     * Filter, which Repair to fetch.
     */
    where?: RepairWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Repairs to fetch.
     */
    orderBy?: RepairOrderByWithRelationInput | RepairOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Repairs.
     */
    cursor?: RepairWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Repairs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Repairs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Repairs.
     */
    distinct?: RepairScalarFieldEnum | RepairScalarFieldEnum[]
  }

  /**
   * Repair findMany
   */
  export type RepairFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Repair
     */
    select?: RepairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Repair
     */
    omit?: RepairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepairInclude<ExtArgs> | null
    /**
     * Filter, which Repairs to fetch.
     */
    where?: RepairWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Repairs to fetch.
     */
    orderBy?: RepairOrderByWithRelationInput | RepairOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Repairs.
     */
    cursor?: RepairWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Repairs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Repairs.
     */
    skip?: number
    distinct?: RepairScalarFieldEnum | RepairScalarFieldEnum[]
  }

  /**
   * Repair create
   */
  export type RepairCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Repair
     */
    select?: RepairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Repair
     */
    omit?: RepairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepairInclude<ExtArgs> | null
    /**
     * The data needed to create a Repair.
     */
    data: XOR<RepairCreateInput, RepairUncheckedCreateInput>
  }

  /**
   * Repair createMany
   */
  export type RepairCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Repairs.
     */
    data: RepairCreateManyInput | RepairCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Repair update
   */
  export type RepairUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Repair
     */
    select?: RepairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Repair
     */
    omit?: RepairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepairInclude<ExtArgs> | null
    /**
     * The data needed to update a Repair.
     */
    data: XOR<RepairUpdateInput, RepairUncheckedUpdateInput>
    /**
     * Choose, which Repair to update.
     */
    where: RepairWhereUniqueInput
  }

  /**
   * Repair updateMany
   */
  export type RepairUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Repairs.
     */
    data: XOR<RepairUpdateManyMutationInput, RepairUncheckedUpdateManyInput>
    /**
     * Filter which Repairs to update
     */
    where?: RepairWhereInput
    /**
     * Limit how many Repairs to update.
     */
    limit?: number
  }

  /**
   * Repair upsert
   */
  export type RepairUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Repair
     */
    select?: RepairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Repair
     */
    omit?: RepairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepairInclude<ExtArgs> | null
    /**
     * The filter to search for the Repair to update in case it exists.
     */
    where: RepairWhereUniqueInput
    /**
     * In case the Repair found by the `where` argument doesn't exist, create a new Repair with this data.
     */
    create: XOR<RepairCreateInput, RepairUncheckedCreateInput>
    /**
     * In case the Repair was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RepairUpdateInput, RepairUncheckedUpdateInput>
  }

  /**
   * Repair delete
   */
  export type RepairDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Repair
     */
    select?: RepairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Repair
     */
    omit?: RepairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepairInclude<ExtArgs> | null
    /**
     * Filter which Repair to delete.
     */
    where: RepairWhereUniqueInput
  }

  /**
   * Repair deleteMany
   */
  export type RepairDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Repairs to delete
     */
    where?: RepairWhereInput
    /**
     * Limit how many Repairs to delete.
     */
    limit?: number
  }

  /**
   * Repair without action
   */
  export type RepairDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Repair
     */
    select?: RepairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Repair
     */
    omit?: RepairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepairInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    username: 'username',
    password: 'password',
    createdAt: 'createdAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const CustomerScalarFieldEnum: {
    id: 'id',
    name: 'name',
    phone: 'phone',
    address: 'address',
    createdAt: 'createdAt'
  };

  export type CustomerScalarFieldEnum = (typeof CustomerScalarFieldEnum)[keyof typeof CustomerScalarFieldEnum]


  export const MasterItemScalarFieldEnum: {
    id: 'id',
    itemName: 'itemName',
    createdAt: 'createdAt'
  };

  export type MasterItemScalarFieldEnum = (typeof MasterItemScalarFieldEnum)[keyof typeof MasterItemScalarFieldEnum]


  export const MasterTouchScalarFieldEnum: {
    id: 'id',
    touch: 'touch',
    createdAt: 'createdAt'
  };

  export type MasterTouchScalarFieldEnum = (typeof MasterTouchScalarFieldEnum)[keyof typeof MasterTouchScalarFieldEnum]


  export const JewelStockScalarFieldEnum: {
    id: 'id',
    jewelName: 'jewelName',
    weight: 'weight',
    stoneWeight: 'stoneWeight',
    finalWeight: 'finalWeight',
    touch: 'touch',
    purityValue: 'purityValue',
    createdAt: 'createdAt'
  };

  export type JewelStockScalarFieldEnum = (typeof JewelStockScalarFieldEnum)[keyof typeof JewelStockScalarFieldEnum]


  export const TransactionScalarFieldEnum: {
    id: 'id',
    date: 'date',
    type: 'type',
    value: 'value',
    goldRate: 'goldRate',
    purity: 'purity',
    touch: 'touch',
    customerId: 'customerId',
    createdAt: 'createdAt'
  };

  export type TransactionScalarFieldEnum = (typeof TransactionScalarFieldEnum)[keyof typeof TransactionScalarFieldEnum]


  export const EntryScalarFieldEnum: {
    id: 'id',
    date: 'date',
    type: 'type',
    cashAmount: 'cashAmount',
    goldValue: 'goldValue',
    touch: 'touch',
    purity: 'purity',
    goldRate: 'goldRate',
    createdAt: 'createdAt'
  };

  export type EntryScalarFieldEnum = (typeof EntryScalarFieldEnum)[keyof typeof EntryScalarFieldEnum]


  export const Customer_orderScalarFieldEnum: {
    id: 'id',
    customer_id: 'customer_id',
    order_group_id: 'order_group_id',
    item_name: 'item_name',
    description: 'description',
    weight: 'weight',
    image: 'image',
    due_date: 'due_date',
    status: 'status',
    worker_name: 'worker_name',
    created_at: 'created_at',
    updatedAt: 'updatedAt'
  };

  export type Customer_orderScalarFieldEnum = (typeof Customer_orderScalarFieldEnum)[keyof typeof Customer_orderScalarFieldEnum]


  export const Product_multiple_imagesScalarFieldEnum: {
    id: 'id',
    customer_order_id: 'customer_order_id',
    filename: 'filename'
  };

  export type Product_multiple_imagesScalarFieldEnum = (typeof Product_multiple_imagesScalarFieldEnum)[keyof typeof Product_multiple_imagesScalarFieldEnum]


  export const MasterBullionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    phone: 'phone',
    address: 'address'
  };

  export type MasterBullionScalarFieldEnum = (typeof MasterBullionScalarFieldEnum)[keyof typeof MasterBullionScalarFieldEnum]


  export const BullionPurchaseScalarFieldEnum: {
    id: 'id',
    bullionId: 'bullionId',
    grams: 'grams',
    touch: 'touch',
    purity: 'purity',
    rate: 'rate',
    amount: 'amount',
    balance: 'balance',
    createdAt: 'createdAt'
  };

  export type BullionPurchaseScalarFieldEnum = (typeof BullionPurchaseScalarFieldEnum)[keyof typeof BullionPurchaseScalarFieldEnum]


  export const GivenDetailScalarFieldEnum: {
    id: 'id',
    amount: 'amount',
    grams: 'grams',
    touch: 'touch',
    purity: 'purity',
    purchaseId: 'purchaseId'
  };

  export type GivenDetailScalarFieldEnum = (typeof GivenDetailScalarFieldEnum)[keyof typeof GivenDetailScalarFieldEnum]


  export const GoldsmithScalarFieldEnum: {
    id: 'id',
    name: 'name',
    phone: 'phone',
    address: 'address',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GoldsmithScalarFieldEnum = (typeof GoldsmithScalarFieldEnum)[keyof typeof GoldsmithScalarFieldEnum]


  export const JobcardScalarFieldEnum: {
    id: 'id',
    goldsmithId: 'goldsmithId',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type JobcardScalarFieldEnum = (typeof JobcardScalarFieldEnum)[keyof typeof JobcardScalarFieldEnum]


  export const GivenGoldScalarFieldEnum: {
    id: 'id',
    goldsmithId: 'goldsmithId',
    jobcardId: 'jobcardId',
    weight: 'weight',
    touch: 'touch',
    purity: 'purity',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GivenGoldScalarFieldEnum = (typeof GivenGoldScalarFieldEnum)[keyof typeof GivenGoldScalarFieldEnum]


  export const TotalScalarFieldEnum: {
    id: 'id',
    goldsmithId: 'goldsmithId',
    totalPurity: 'totalPurity',
    openingBalance: 'openingBalance',
    totalBalance: 'totalBalance',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TotalScalarFieldEnum = (typeof TotalScalarFieldEnum)[keyof typeof TotalScalarFieldEnum]


  export const ItemDeliveryScalarFieldEnum: {
    id: 'id',
    itemName: 'itemName',
    itemWeight: 'itemWeight',
    type: 'type',
    stoneWeight: 'stoneWeight',
    netWeight: 'netWeight',
    wastageType: 'wastageType',
    wastageValue: 'wastageValue',
    finalPurity: 'finalPurity',
    goldsmithId: 'goldsmithId',
    jobcardId: 'jobcardId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ItemDeliveryScalarFieldEnum = (typeof ItemDeliveryScalarFieldEnum)[keyof typeof ItemDeliveryScalarFieldEnum]


  export const ReceivedsectionScalarFieldEnum: {
    id: 'id',
    weight: 'weight',
    touch: 'touch',
    purity: 'purity',
    jobcardId: 'jobcardId',
    goldsmithId: 'goldsmithId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ReceivedsectionScalarFieldEnum = (typeof ReceivedsectionScalarFieldEnum)[keyof typeof ReceivedsectionScalarFieldEnum]


  export const BalancesScalarFieldEnum: {
    id: 'id',
    goldsmithId: 'goldsmithId',
    totalDeliveries: 'totalDeliveries',
    totalItemWeight: 'totalItemWeight',
    totalNetWeight: 'totalNetWeight',
    totalPurity: 'totalPurity',
    totalReceivedWeight: 'totalReceivedWeight',
    totalReceivedTouch: 'totalReceivedTouch',
    totalReceivedPurity: 'totalReceivedPurity',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BalancesScalarFieldEnum = (typeof BalancesScalarFieldEnum)[keyof typeof BalancesScalarFieldEnum]


  export const RepairScalarFieldEnum: {
    id: 'id',
    goldsmithId: 'goldsmithId',
    givenWeights: 'givenWeights',
    totalGiven: 'totalGiven',
    itemWeights: 'itemWeights',
    totalItem: 'totalItem',
    stone: 'stone',
    wastageType: 'wastageType',
    touch: 'touch',
    netWeight: 'netWeight',
    createdAt: 'createdAt'
  };

  export type RepairScalarFieldEnum = (typeof RepairScalarFieldEnum)[keyof typeof RepairScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const UserOrderByRelevanceFieldEnum: {
    username: 'username',
    password: 'password'
  };

  export type UserOrderByRelevanceFieldEnum = (typeof UserOrderByRelevanceFieldEnum)[keyof typeof UserOrderByRelevanceFieldEnum]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const CustomerOrderByRelevanceFieldEnum: {
    name: 'name',
    phone: 'phone',
    address: 'address'
  };

  export type CustomerOrderByRelevanceFieldEnum = (typeof CustomerOrderByRelevanceFieldEnum)[keyof typeof CustomerOrderByRelevanceFieldEnum]


  export const MasterItemOrderByRelevanceFieldEnum: {
    itemName: 'itemName'
  };

  export type MasterItemOrderByRelevanceFieldEnum = (typeof MasterItemOrderByRelevanceFieldEnum)[keyof typeof MasterItemOrderByRelevanceFieldEnum]


  export const JewelStockOrderByRelevanceFieldEnum: {
    jewelName: 'jewelName'
  };

  export type JewelStockOrderByRelevanceFieldEnum = (typeof JewelStockOrderByRelevanceFieldEnum)[keyof typeof JewelStockOrderByRelevanceFieldEnum]


  export const TransactionOrderByRelevanceFieldEnum: {
    type: 'type'
  };

  export type TransactionOrderByRelevanceFieldEnum = (typeof TransactionOrderByRelevanceFieldEnum)[keyof typeof TransactionOrderByRelevanceFieldEnum]


  export const EntryOrderByRelevanceFieldEnum: {
    type: 'type'
  };

  export type EntryOrderByRelevanceFieldEnum = (typeof EntryOrderByRelevanceFieldEnum)[keyof typeof EntryOrderByRelevanceFieldEnum]


  export const customer_orderOrderByRelevanceFieldEnum: {
    item_name: 'item_name',
    description: 'description',
    image: 'image',
    status: 'status',
    worker_name: 'worker_name'
  };

  export type customer_orderOrderByRelevanceFieldEnum = (typeof customer_orderOrderByRelevanceFieldEnum)[keyof typeof customer_orderOrderByRelevanceFieldEnum]


  export const product_multiple_imagesOrderByRelevanceFieldEnum: {
    filename: 'filename'
  };

  export type product_multiple_imagesOrderByRelevanceFieldEnum = (typeof product_multiple_imagesOrderByRelevanceFieldEnum)[keyof typeof product_multiple_imagesOrderByRelevanceFieldEnum]


  export const MasterBullionOrderByRelevanceFieldEnum: {
    name: 'name',
    phone: 'phone',
    address: 'address'
  };

  export type MasterBullionOrderByRelevanceFieldEnum = (typeof MasterBullionOrderByRelevanceFieldEnum)[keyof typeof MasterBullionOrderByRelevanceFieldEnum]


  export const GoldsmithOrderByRelevanceFieldEnum: {
    name: 'name',
    phone: 'phone',
    address: 'address'
  };

  export type GoldsmithOrderByRelevanceFieldEnum = (typeof GoldsmithOrderByRelevanceFieldEnum)[keyof typeof GoldsmithOrderByRelevanceFieldEnum]


  export const JobcardOrderByRelevanceFieldEnum: {
    description: 'description'
  };

  export type JobcardOrderByRelevanceFieldEnum = (typeof JobcardOrderByRelevanceFieldEnum)[keyof typeof JobcardOrderByRelevanceFieldEnum]


  export const itemDeliveryOrderByRelevanceFieldEnum: {
    itemName: 'itemName',
    type: 'type'
  };

  export type itemDeliveryOrderByRelevanceFieldEnum = (typeof itemDeliveryOrderByRelevanceFieldEnum)[keyof typeof itemDeliveryOrderByRelevanceFieldEnum]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const RepairOrderByRelevanceFieldEnum: {
    wastageType: 'wastageType'
  };

  export type RepairOrderByRelevanceFieldEnum = (typeof RepairOrderByRelevanceFieldEnum)[keyof typeof RepairOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'WastageType'
   */
  export type EnumWastageTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WastageType'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    username?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    _relevance?: UserOrderByRelevanceInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    username?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
  }, "id" | "username">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    username?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type CustomerWhereInput = {
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    id?: IntFilter<"Customer"> | number
    name?: StringFilter<"Customer"> | string
    phone?: StringNullableFilter<"Customer"> | string | null
    address?: StringNullableFilter<"Customer"> | string | null
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    transactions?: TransactionListRelationFilter
    customerOrders?: Customer_orderListRelationFilter
  }

  export type CustomerOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    transactions?: TransactionOrderByRelationAggregateInput
    customerOrders?: customer_orderOrderByRelationAggregateInput
    _relevance?: CustomerOrderByRelevanceInput
  }

  export type CustomerWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    name?: StringFilter<"Customer"> | string
    phone?: StringNullableFilter<"Customer"> | string | null
    address?: StringNullableFilter<"Customer"> | string | null
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    transactions?: TransactionListRelationFilter
    customerOrders?: Customer_orderListRelationFilter
  }, "id">

  export type CustomerOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: CustomerCountOrderByAggregateInput
    _avg?: CustomerAvgOrderByAggregateInput
    _max?: CustomerMaxOrderByAggregateInput
    _min?: CustomerMinOrderByAggregateInput
    _sum?: CustomerSumOrderByAggregateInput
  }

  export type CustomerScalarWhereWithAggregatesInput = {
    AND?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    OR?: CustomerScalarWhereWithAggregatesInput[]
    NOT?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Customer"> | number
    name?: StringWithAggregatesFilter<"Customer"> | string
    phone?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    address?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
  }

  export type MasterItemWhereInput = {
    AND?: MasterItemWhereInput | MasterItemWhereInput[]
    OR?: MasterItemWhereInput[]
    NOT?: MasterItemWhereInput | MasterItemWhereInput[]
    id?: IntFilter<"MasterItem"> | number
    itemName?: StringFilter<"MasterItem"> | string
    createdAt?: DateTimeFilter<"MasterItem"> | Date | string
  }

  export type MasterItemOrderByWithRelationInput = {
    id?: SortOrder
    itemName?: SortOrder
    createdAt?: SortOrder
    _relevance?: MasterItemOrderByRelevanceInput
  }

  export type MasterItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MasterItemWhereInput | MasterItemWhereInput[]
    OR?: MasterItemWhereInput[]
    NOT?: MasterItemWhereInput | MasterItemWhereInput[]
    itemName?: StringFilter<"MasterItem"> | string
    createdAt?: DateTimeFilter<"MasterItem"> | Date | string
  }, "id">

  export type MasterItemOrderByWithAggregationInput = {
    id?: SortOrder
    itemName?: SortOrder
    createdAt?: SortOrder
    _count?: MasterItemCountOrderByAggregateInput
    _avg?: MasterItemAvgOrderByAggregateInput
    _max?: MasterItemMaxOrderByAggregateInput
    _min?: MasterItemMinOrderByAggregateInput
    _sum?: MasterItemSumOrderByAggregateInput
  }

  export type MasterItemScalarWhereWithAggregatesInput = {
    AND?: MasterItemScalarWhereWithAggregatesInput | MasterItemScalarWhereWithAggregatesInput[]
    OR?: MasterItemScalarWhereWithAggregatesInput[]
    NOT?: MasterItemScalarWhereWithAggregatesInput | MasterItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MasterItem"> | number
    itemName?: StringWithAggregatesFilter<"MasterItem"> | string
    createdAt?: DateTimeWithAggregatesFilter<"MasterItem"> | Date | string
  }

  export type MasterTouchWhereInput = {
    AND?: MasterTouchWhereInput | MasterTouchWhereInput[]
    OR?: MasterTouchWhereInput[]
    NOT?: MasterTouchWhereInput | MasterTouchWhereInput[]
    id?: IntFilter<"MasterTouch"> | number
    touch?: FloatFilter<"MasterTouch"> | number
    createdAt?: DateTimeFilter<"MasterTouch"> | Date | string
  }

  export type MasterTouchOrderByWithRelationInput = {
    id?: SortOrder
    touch?: SortOrder
    createdAt?: SortOrder
  }

  export type MasterTouchWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MasterTouchWhereInput | MasterTouchWhereInput[]
    OR?: MasterTouchWhereInput[]
    NOT?: MasterTouchWhereInput | MasterTouchWhereInput[]
    touch?: FloatFilter<"MasterTouch"> | number
    createdAt?: DateTimeFilter<"MasterTouch"> | Date | string
  }, "id">

  export type MasterTouchOrderByWithAggregationInput = {
    id?: SortOrder
    touch?: SortOrder
    createdAt?: SortOrder
    _count?: MasterTouchCountOrderByAggregateInput
    _avg?: MasterTouchAvgOrderByAggregateInput
    _max?: MasterTouchMaxOrderByAggregateInput
    _min?: MasterTouchMinOrderByAggregateInput
    _sum?: MasterTouchSumOrderByAggregateInput
  }

  export type MasterTouchScalarWhereWithAggregatesInput = {
    AND?: MasterTouchScalarWhereWithAggregatesInput | MasterTouchScalarWhereWithAggregatesInput[]
    OR?: MasterTouchScalarWhereWithAggregatesInput[]
    NOT?: MasterTouchScalarWhereWithAggregatesInput | MasterTouchScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MasterTouch"> | number
    touch?: FloatWithAggregatesFilter<"MasterTouch"> | number
    createdAt?: DateTimeWithAggregatesFilter<"MasterTouch"> | Date | string
  }

  export type JewelStockWhereInput = {
    AND?: JewelStockWhereInput | JewelStockWhereInput[]
    OR?: JewelStockWhereInput[]
    NOT?: JewelStockWhereInput | JewelStockWhereInput[]
    id?: IntFilter<"JewelStock"> | number
    jewelName?: StringFilter<"JewelStock"> | string
    weight?: FloatFilter<"JewelStock"> | number
    stoneWeight?: FloatFilter<"JewelStock"> | number
    finalWeight?: FloatFilter<"JewelStock"> | number
    touch?: FloatFilter<"JewelStock"> | number
    purityValue?: FloatFilter<"JewelStock"> | number
    createdAt?: DateTimeFilter<"JewelStock"> | Date | string
  }

  export type JewelStockOrderByWithRelationInput = {
    id?: SortOrder
    jewelName?: SortOrder
    weight?: SortOrder
    stoneWeight?: SortOrder
    finalWeight?: SortOrder
    touch?: SortOrder
    purityValue?: SortOrder
    createdAt?: SortOrder
    _relevance?: JewelStockOrderByRelevanceInput
  }

  export type JewelStockWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: JewelStockWhereInput | JewelStockWhereInput[]
    OR?: JewelStockWhereInput[]
    NOT?: JewelStockWhereInput | JewelStockWhereInput[]
    jewelName?: StringFilter<"JewelStock"> | string
    weight?: FloatFilter<"JewelStock"> | number
    stoneWeight?: FloatFilter<"JewelStock"> | number
    finalWeight?: FloatFilter<"JewelStock"> | number
    touch?: FloatFilter<"JewelStock"> | number
    purityValue?: FloatFilter<"JewelStock"> | number
    createdAt?: DateTimeFilter<"JewelStock"> | Date | string
  }, "id">

  export type JewelStockOrderByWithAggregationInput = {
    id?: SortOrder
    jewelName?: SortOrder
    weight?: SortOrder
    stoneWeight?: SortOrder
    finalWeight?: SortOrder
    touch?: SortOrder
    purityValue?: SortOrder
    createdAt?: SortOrder
    _count?: JewelStockCountOrderByAggregateInput
    _avg?: JewelStockAvgOrderByAggregateInput
    _max?: JewelStockMaxOrderByAggregateInput
    _min?: JewelStockMinOrderByAggregateInput
    _sum?: JewelStockSumOrderByAggregateInput
  }

  export type JewelStockScalarWhereWithAggregatesInput = {
    AND?: JewelStockScalarWhereWithAggregatesInput | JewelStockScalarWhereWithAggregatesInput[]
    OR?: JewelStockScalarWhereWithAggregatesInput[]
    NOT?: JewelStockScalarWhereWithAggregatesInput | JewelStockScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"JewelStock"> | number
    jewelName?: StringWithAggregatesFilter<"JewelStock"> | string
    weight?: FloatWithAggregatesFilter<"JewelStock"> | number
    stoneWeight?: FloatWithAggregatesFilter<"JewelStock"> | number
    finalWeight?: FloatWithAggregatesFilter<"JewelStock"> | number
    touch?: FloatWithAggregatesFilter<"JewelStock"> | number
    purityValue?: FloatWithAggregatesFilter<"JewelStock"> | number
    createdAt?: DateTimeWithAggregatesFilter<"JewelStock"> | Date | string
  }

  export type TransactionWhereInput = {
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    id?: IntFilter<"Transaction"> | number
    date?: DateTimeFilter<"Transaction"> | Date | string
    type?: StringFilter<"Transaction"> | string
    value?: FloatFilter<"Transaction"> | number
    goldRate?: FloatNullableFilter<"Transaction"> | number | null
    purity?: FloatFilter<"Transaction"> | number
    touch?: FloatNullableFilter<"Transaction"> | number | null
    customerId?: IntFilter<"Transaction"> | number
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
  }

  export type TransactionOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    type?: SortOrder
    value?: SortOrder
    goldRate?: SortOrderInput | SortOrder
    purity?: SortOrder
    touch?: SortOrderInput | SortOrder
    customerId?: SortOrder
    createdAt?: SortOrder
    customer?: CustomerOrderByWithRelationInput
    _relevance?: TransactionOrderByRelevanceInput
  }

  export type TransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    date?: DateTimeFilter<"Transaction"> | Date | string
    type?: StringFilter<"Transaction"> | string
    value?: FloatFilter<"Transaction"> | number
    goldRate?: FloatNullableFilter<"Transaction"> | number | null
    purity?: FloatFilter<"Transaction"> | number
    touch?: FloatNullableFilter<"Transaction"> | number | null
    customerId?: IntFilter<"Transaction"> | number
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
  }, "id">

  export type TransactionOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    type?: SortOrder
    value?: SortOrder
    goldRate?: SortOrderInput | SortOrder
    purity?: SortOrder
    touch?: SortOrderInput | SortOrder
    customerId?: SortOrder
    createdAt?: SortOrder
    _count?: TransactionCountOrderByAggregateInput
    _avg?: TransactionAvgOrderByAggregateInput
    _max?: TransactionMaxOrderByAggregateInput
    _min?: TransactionMinOrderByAggregateInput
    _sum?: TransactionSumOrderByAggregateInput
  }

  export type TransactionScalarWhereWithAggregatesInput = {
    AND?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    OR?: TransactionScalarWhereWithAggregatesInput[]
    NOT?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Transaction"> | number
    date?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
    type?: StringWithAggregatesFilter<"Transaction"> | string
    value?: FloatWithAggregatesFilter<"Transaction"> | number
    goldRate?: FloatNullableWithAggregatesFilter<"Transaction"> | number | null
    purity?: FloatWithAggregatesFilter<"Transaction"> | number
    touch?: FloatNullableWithAggregatesFilter<"Transaction"> | number | null
    customerId?: IntWithAggregatesFilter<"Transaction"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
  }

  export type EntryWhereInput = {
    AND?: EntryWhereInput | EntryWhereInput[]
    OR?: EntryWhereInput[]
    NOT?: EntryWhereInput | EntryWhereInput[]
    id?: IntFilter<"Entry"> | number
    date?: DateTimeFilter<"Entry"> | Date | string
    type?: StringFilter<"Entry"> | string
    cashAmount?: FloatNullableFilter<"Entry"> | number | null
    goldValue?: FloatNullableFilter<"Entry"> | number | null
    touch?: FloatNullableFilter<"Entry"> | number | null
    purity?: FloatNullableFilter<"Entry"> | number | null
    goldRate?: FloatNullableFilter<"Entry"> | number | null
    createdAt?: DateTimeFilter<"Entry"> | Date | string
  }

  export type EntryOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    type?: SortOrder
    cashAmount?: SortOrderInput | SortOrder
    goldValue?: SortOrderInput | SortOrder
    touch?: SortOrderInput | SortOrder
    purity?: SortOrderInput | SortOrder
    goldRate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _relevance?: EntryOrderByRelevanceInput
  }

  export type EntryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EntryWhereInput | EntryWhereInput[]
    OR?: EntryWhereInput[]
    NOT?: EntryWhereInput | EntryWhereInput[]
    date?: DateTimeFilter<"Entry"> | Date | string
    type?: StringFilter<"Entry"> | string
    cashAmount?: FloatNullableFilter<"Entry"> | number | null
    goldValue?: FloatNullableFilter<"Entry"> | number | null
    touch?: FloatNullableFilter<"Entry"> | number | null
    purity?: FloatNullableFilter<"Entry"> | number | null
    goldRate?: FloatNullableFilter<"Entry"> | number | null
    createdAt?: DateTimeFilter<"Entry"> | Date | string
  }, "id">

  export type EntryOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    type?: SortOrder
    cashAmount?: SortOrderInput | SortOrder
    goldValue?: SortOrderInput | SortOrder
    touch?: SortOrderInput | SortOrder
    purity?: SortOrderInput | SortOrder
    goldRate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: EntryCountOrderByAggregateInput
    _avg?: EntryAvgOrderByAggregateInput
    _max?: EntryMaxOrderByAggregateInput
    _min?: EntryMinOrderByAggregateInput
    _sum?: EntrySumOrderByAggregateInput
  }

  export type EntryScalarWhereWithAggregatesInput = {
    AND?: EntryScalarWhereWithAggregatesInput | EntryScalarWhereWithAggregatesInput[]
    OR?: EntryScalarWhereWithAggregatesInput[]
    NOT?: EntryScalarWhereWithAggregatesInput | EntryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Entry"> | number
    date?: DateTimeWithAggregatesFilter<"Entry"> | Date | string
    type?: StringWithAggregatesFilter<"Entry"> | string
    cashAmount?: FloatNullableWithAggregatesFilter<"Entry"> | number | null
    goldValue?: FloatNullableWithAggregatesFilter<"Entry"> | number | null
    touch?: FloatNullableWithAggregatesFilter<"Entry"> | number | null
    purity?: FloatNullableWithAggregatesFilter<"Entry"> | number | null
    goldRate?: FloatNullableWithAggregatesFilter<"Entry"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Entry"> | Date | string
  }

  export type customer_orderWhereInput = {
    AND?: customer_orderWhereInput | customer_orderWhereInput[]
    OR?: customer_orderWhereInput[]
    NOT?: customer_orderWhereInput | customer_orderWhereInput[]
    id?: IntFilter<"customer_order"> | number
    customer_id?: IntFilter<"customer_order"> | number
    order_group_id?: IntFilter<"customer_order"> | number
    item_name?: StringFilter<"customer_order"> | string
    description?: StringFilter<"customer_order"> | string
    weight?: FloatFilter<"customer_order"> | number
    image?: StringNullableFilter<"customer_order"> | string | null
    due_date?: DateTimeNullableFilter<"customer_order"> | Date | string | null
    status?: StringFilter<"customer_order"> | string
    worker_name?: StringNullableFilter<"customer_order"> | string | null
    created_at?: DateTimeFilter<"customer_order"> | Date | string
    updatedAt?: DateTimeFilter<"customer_order"> | Date | string
    customers?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    productImages?: Product_multiple_imagesListRelationFilter
  }

  export type customer_orderOrderByWithRelationInput = {
    id?: SortOrder
    customer_id?: SortOrder
    order_group_id?: SortOrder
    item_name?: SortOrder
    description?: SortOrder
    weight?: SortOrder
    image?: SortOrderInput | SortOrder
    due_date?: SortOrderInput | SortOrder
    status?: SortOrder
    worker_name?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updatedAt?: SortOrder
    customers?: CustomerOrderByWithRelationInput
    productImages?: product_multiple_imagesOrderByRelationAggregateInput
    _relevance?: customer_orderOrderByRelevanceInput
  }

  export type customer_orderWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: customer_orderWhereInput | customer_orderWhereInput[]
    OR?: customer_orderWhereInput[]
    NOT?: customer_orderWhereInput | customer_orderWhereInput[]
    customer_id?: IntFilter<"customer_order"> | number
    order_group_id?: IntFilter<"customer_order"> | number
    item_name?: StringFilter<"customer_order"> | string
    description?: StringFilter<"customer_order"> | string
    weight?: FloatFilter<"customer_order"> | number
    image?: StringNullableFilter<"customer_order"> | string | null
    due_date?: DateTimeNullableFilter<"customer_order"> | Date | string | null
    status?: StringFilter<"customer_order"> | string
    worker_name?: StringNullableFilter<"customer_order"> | string | null
    created_at?: DateTimeFilter<"customer_order"> | Date | string
    updatedAt?: DateTimeFilter<"customer_order"> | Date | string
    customers?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    productImages?: Product_multiple_imagesListRelationFilter
  }, "id">

  export type customer_orderOrderByWithAggregationInput = {
    id?: SortOrder
    customer_id?: SortOrder
    order_group_id?: SortOrder
    item_name?: SortOrder
    description?: SortOrder
    weight?: SortOrder
    image?: SortOrderInput | SortOrder
    due_date?: SortOrderInput | SortOrder
    status?: SortOrder
    worker_name?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updatedAt?: SortOrder
    _count?: customer_orderCountOrderByAggregateInput
    _avg?: customer_orderAvgOrderByAggregateInput
    _max?: customer_orderMaxOrderByAggregateInput
    _min?: customer_orderMinOrderByAggregateInput
    _sum?: customer_orderSumOrderByAggregateInput
  }

  export type customer_orderScalarWhereWithAggregatesInput = {
    AND?: customer_orderScalarWhereWithAggregatesInput | customer_orderScalarWhereWithAggregatesInput[]
    OR?: customer_orderScalarWhereWithAggregatesInput[]
    NOT?: customer_orderScalarWhereWithAggregatesInput | customer_orderScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"customer_order"> | number
    customer_id?: IntWithAggregatesFilter<"customer_order"> | number
    order_group_id?: IntWithAggregatesFilter<"customer_order"> | number
    item_name?: StringWithAggregatesFilter<"customer_order"> | string
    description?: StringWithAggregatesFilter<"customer_order"> | string
    weight?: FloatWithAggregatesFilter<"customer_order"> | number
    image?: StringNullableWithAggregatesFilter<"customer_order"> | string | null
    due_date?: DateTimeNullableWithAggregatesFilter<"customer_order"> | Date | string | null
    status?: StringWithAggregatesFilter<"customer_order"> | string
    worker_name?: StringNullableWithAggregatesFilter<"customer_order"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"customer_order"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"customer_order"> | Date | string
  }

  export type product_multiple_imagesWhereInput = {
    AND?: product_multiple_imagesWhereInput | product_multiple_imagesWhereInput[]
    OR?: product_multiple_imagesWhereInput[]
    NOT?: product_multiple_imagesWhereInput | product_multiple_imagesWhereInput[]
    id?: IntFilter<"product_multiple_images"> | number
    customer_order_id?: IntFilter<"product_multiple_images"> | number
    filename?: StringFilter<"product_multiple_images"> | string
    customerOrderDetails?: XOR<Customer_orderScalarRelationFilter, customer_orderWhereInput>
  }

  export type product_multiple_imagesOrderByWithRelationInput = {
    id?: SortOrder
    customer_order_id?: SortOrder
    filename?: SortOrder
    customerOrderDetails?: customer_orderOrderByWithRelationInput
    _relevance?: product_multiple_imagesOrderByRelevanceInput
  }

  export type product_multiple_imagesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: product_multiple_imagesWhereInput | product_multiple_imagesWhereInput[]
    OR?: product_multiple_imagesWhereInput[]
    NOT?: product_multiple_imagesWhereInput | product_multiple_imagesWhereInput[]
    customer_order_id?: IntFilter<"product_multiple_images"> | number
    filename?: StringFilter<"product_multiple_images"> | string
    customerOrderDetails?: XOR<Customer_orderScalarRelationFilter, customer_orderWhereInput>
  }, "id">

  export type product_multiple_imagesOrderByWithAggregationInput = {
    id?: SortOrder
    customer_order_id?: SortOrder
    filename?: SortOrder
    _count?: product_multiple_imagesCountOrderByAggregateInput
    _avg?: product_multiple_imagesAvgOrderByAggregateInput
    _max?: product_multiple_imagesMaxOrderByAggregateInput
    _min?: product_multiple_imagesMinOrderByAggregateInput
    _sum?: product_multiple_imagesSumOrderByAggregateInput
  }

  export type product_multiple_imagesScalarWhereWithAggregatesInput = {
    AND?: product_multiple_imagesScalarWhereWithAggregatesInput | product_multiple_imagesScalarWhereWithAggregatesInput[]
    OR?: product_multiple_imagesScalarWhereWithAggregatesInput[]
    NOT?: product_multiple_imagesScalarWhereWithAggregatesInput | product_multiple_imagesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"product_multiple_images"> | number
    customer_order_id?: IntWithAggregatesFilter<"product_multiple_images"> | number
    filename?: StringWithAggregatesFilter<"product_multiple_images"> | string
  }

  export type MasterBullionWhereInput = {
    AND?: MasterBullionWhereInput | MasterBullionWhereInput[]
    OR?: MasterBullionWhereInput[]
    NOT?: MasterBullionWhereInput | MasterBullionWhereInput[]
    id?: IntFilter<"MasterBullion"> | number
    name?: StringFilter<"MasterBullion"> | string
    phone?: StringNullableFilter<"MasterBullion"> | string | null
    address?: StringNullableFilter<"MasterBullion"> | string | null
    purchases?: BullionPurchaseListRelationFilter
  }

  export type MasterBullionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    purchases?: BullionPurchaseOrderByRelationAggregateInput
    _relevance?: MasterBullionOrderByRelevanceInput
  }

  export type MasterBullionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MasterBullionWhereInput | MasterBullionWhereInput[]
    OR?: MasterBullionWhereInput[]
    NOT?: MasterBullionWhereInput | MasterBullionWhereInput[]
    name?: StringFilter<"MasterBullion"> | string
    phone?: StringNullableFilter<"MasterBullion"> | string | null
    address?: StringNullableFilter<"MasterBullion"> | string | null
    purchases?: BullionPurchaseListRelationFilter
  }, "id">

  export type MasterBullionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    _count?: MasterBullionCountOrderByAggregateInput
    _avg?: MasterBullionAvgOrderByAggregateInput
    _max?: MasterBullionMaxOrderByAggregateInput
    _min?: MasterBullionMinOrderByAggregateInput
    _sum?: MasterBullionSumOrderByAggregateInput
  }

  export type MasterBullionScalarWhereWithAggregatesInput = {
    AND?: MasterBullionScalarWhereWithAggregatesInput | MasterBullionScalarWhereWithAggregatesInput[]
    OR?: MasterBullionScalarWhereWithAggregatesInput[]
    NOT?: MasterBullionScalarWhereWithAggregatesInput | MasterBullionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MasterBullion"> | number
    name?: StringWithAggregatesFilter<"MasterBullion"> | string
    phone?: StringNullableWithAggregatesFilter<"MasterBullion"> | string | null
    address?: StringNullableWithAggregatesFilter<"MasterBullion"> | string | null
  }

  export type BullionPurchaseWhereInput = {
    AND?: BullionPurchaseWhereInput | BullionPurchaseWhereInput[]
    OR?: BullionPurchaseWhereInput[]
    NOT?: BullionPurchaseWhereInput | BullionPurchaseWhereInput[]
    id?: IntFilter<"BullionPurchase"> | number
    bullionId?: IntFilter<"BullionPurchase"> | number
    grams?: FloatFilter<"BullionPurchase"> | number
    touch?: FloatNullableFilter<"BullionPurchase"> | number | null
    purity?: FloatNullableFilter<"BullionPurchase"> | number | null
    rate?: FloatFilter<"BullionPurchase"> | number
    amount?: FloatFilter<"BullionPurchase"> | number
    balance?: FloatFilter<"BullionPurchase"> | number
    createdAt?: DateTimeFilter<"BullionPurchase"> | Date | string
    bullion?: XOR<MasterBullionScalarRelationFilter, MasterBullionWhereInput>
    givenDetails?: GivenDetailListRelationFilter
  }

  export type BullionPurchaseOrderByWithRelationInput = {
    id?: SortOrder
    bullionId?: SortOrder
    grams?: SortOrder
    touch?: SortOrderInput | SortOrder
    purity?: SortOrderInput | SortOrder
    rate?: SortOrder
    amount?: SortOrder
    balance?: SortOrder
    createdAt?: SortOrder
    bullion?: MasterBullionOrderByWithRelationInput
    givenDetails?: GivenDetailOrderByRelationAggregateInput
  }

  export type BullionPurchaseWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BullionPurchaseWhereInput | BullionPurchaseWhereInput[]
    OR?: BullionPurchaseWhereInput[]
    NOT?: BullionPurchaseWhereInput | BullionPurchaseWhereInput[]
    bullionId?: IntFilter<"BullionPurchase"> | number
    grams?: FloatFilter<"BullionPurchase"> | number
    touch?: FloatNullableFilter<"BullionPurchase"> | number | null
    purity?: FloatNullableFilter<"BullionPurchase"> | number | null
    rate?: FloatFilter<"BullionPurchase"> | number
    amount?: FloatFilter<"BullionPurchase"> | number
    balance?: FloatFilter<"BullionPurchase"> | number
    createdAt?: DateTimeFilter<"BullionPurchase"> | Date | string
    bullion?: XOR<MasterBullionScalarRelationFilter, MasterBullionWhereInput>
    givenDetails?: GivenDetailListRelationFilter
  }, "id">

  export type BullionPurchaseOrderByWithAggregationInput = {
    id?: SortOrder
    bullionId?: SortOrder
    grams?: SortOrder
    touch?: SortOrderInput | SortOrder
    purity?: SortOrderInput | SortOrder
    rate?: SortOrder
    amount?: SortOrder
    balance?: SortOrder
    createdAt?: SortOrder
    _count?: BullionPurchaseCountOrderByAggregateInput
    _avg?: BullionPurchaseAvgOrderByAggregateInput
    _max?: BullionPurchaseMaxOrderByAggregateInput
    _min?: BullionPurchaseMinOrderByAggregateInput
    _sum?: BullionPurchaseSumOrderByAggregateInput
  }

  export type BullionPurchaseScalarWhereWithAggregatesInput = {
    AND?: BullionPurchaseScalarWhereWithAggregatesInput | BullionPurchaseScalarWhereWithAggregatesInput[]
    OR?: BullionPurchaseScalarWhereWithAggregatesInput[]
    NOT?: BullionPurchaseScalarWhereWithAggregatesInput | BullionPurchaseScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BullionPurchase"> | number
    bullionId?: IntWithAggregatesFilter<"BullionPurchase"> | number
    grams?: FloatWithAggregatesFilter<"BullionPurchase"> | number
    touch?: FloatNullableWithAggregatesFilter<"BullionPurchase"> | number | null
    purity?: FloatNullableWithAggregatesFilter<"BullionPurchase"> | number | null
    rate?: FloatWithAggregatesFilter<"BullionPurchase"> | number
    amount?: FloatWithAggregatesFilter<"BullionPurchase"> | number
    balance?: FloatWithAggregatesFilter<"BullionPurchase"> | number
    createdAt?: DateTimeWithAggregatesFilter<"BullionPurchase"> | Date | string
  }

  export type GivenDetailWhereInput = {
    AND?: GivenDetailWhereInput | GivenDetailWhereInput[]
    OR?: GivenDetailWhereInput[]
    NOT?: GivenDetailWhereInput | GivenDetailWhereInput[]
    id?: IntFilter<"GivenDetail"> | number
    amount?: FloatFilter<"GivenDetail"> | number
    grams?: FloatFilter<"GivenDetail"> | number
    touch?: FloatNullableFilter<"GivenDetail"> | number | null
    purity?: FloatNullableFilter<"GivenDetail"> | number | null
    purchaseId?: IntFilter<"GivenDetail"> | number
    bullionPurchase?: XOR<BullionPurchaseScalarRelationFilter, BullionPurchaseWhereInput>
  }

  export type GivenDetailOrderByWithRelationInput = {
    id?: SortOrder
    amount?: SortOrder
    grams?: SortOrder
    touch?: SortOrderInput | SortOrder
    purity?: SortOrderInput | SortOrder
    purchaseId?: SortOrder
    bullionPurchase?: BullionPurchaseOrderByWithRelationInput
  }

  export type GivenDetailWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: GivenDetailWhereInput | GivenDetailWhereInput[]
    OR?: GivenDetailWhereInput[]
    NOT?: GivenDetailWhereInput | GivenDetailWhereInput[]
    amount?: FloatFilter<"GivenDetail"> | number
    grams?: FloatFilter<"GivenDetail"> | number
    touch?: FloatNullableFilter<"GivenDetail"> | number | null
    purity?: FloatNullableFilter<"GivenDetail"> | number | null
    purchaseId?: IntFilter<"GivenDetail"> | number
    bullionPurchase?: XOR<BullionPurchaseScalarRelationFilter, BullionPurchaseWhereInput>
  }, "id">

  export type GivenDetailOrderByWithAggregationInput = {
    id?: SortOrder
    amount?: SortOrder
    grams?: SortOrder
    touch?: SortOrderInput | SortOrder
    purity?: SortOrderInput | SortOrder
    purchaseId?: SortOrder
    _count?: GivenDetailCountOrderByAggregateInput
    _avg?: GivenDetailAvgOrderByAggregateInput
    _max?: GivenDetailMaxOrderByAggregateInput
    _min?: GivenDetailMinOrderByAggregateInput
    _sum?: GivenDetailSumOrderByAggregateInput
  }

  export type GivenDetailScalarWhereWithAggregatesInput = {
    AND?: GivenDetailScalarWhereWithAggregatesInput | GivenDetailScalarWhereWithAggregatesInput[]
    OR?: GivenDetailScalarWhereWithAggregatesInput[]
    NOT?: GivenDetailScalarWhereWithAggregatesInput | GivenDetailScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"GivenDetail"> | number
    amount?: FloatWithAggregatesFilter<"GivenDetail"> | number
    grams?: FloatWithAggregatesFilter<"GivenDetail"> | number
    touch?: FloatNullableWithAggregatesFilter<"GivenDetail"> | number | null
    purity?: FloatNullableWithAggregatesFilter<"GivenDetail"> | number | null
    purchaseId?: IntWithAggregatesFilter<"GivenDetail"> | number
  }

  export type GoldsmithWhereInput = {
    AND?: GoldsmithWhereInput | GoldsmithWhereInput[]
    OR?: GoldsmithWhereInput[]
    NOT?: GoldsmithWhereInput | GoldsmithWhereInput[]
    id?: IntFilter<"Goldsmith"> | number
    name?: StringFilter<"Goldsmith"> | string
    phone?: StringNullableFilter<"Goldsmith"> | string | null
    address?: StringNullableFilter<"Goldsmith"> | string | null
    createdAt?: DateTimeFilter<"Goldsmith"> | Date | string
    updatedAt?: DateTimeFilter<"Goldsmith"> | Date | string
    jobcards?: JobcardListRelationFilter
    totals?: TotalListRelationFilter
    givenGold?: GivenGoldListRelationFilter
    deliveries?: ItemDeliveryListRelationFilter
    received?: ReceivedsectionListRelationFilter
    repairs?: RepairListRelationFilter
    summaries?: BalancesListRelationFilter
  }

  export type GoldsmithOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    jobcards?: JobcardOrderByRelationAggregateInput
    totals?: TotalOrderByRelationAggregateInput
    givenGold?: givenGoldOrderByRelationAggregateInput
    deliveries?: itemDeliveryOrderByRelationAggregateInput
    received?: ReceivedsectionOrderByRelationAggregateInput
    repairs?: RepairOrderByRelationAggregateInput
    summaries?: BalancesOrderByRelationAggregateInput
    _relevance?: GoldsmithOrderByRelevanceInput
  }

  export type GoldsmithWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: GoldsmithWhereInput | GoldsmithWhereInput[]
    OR?: GoldsmithWhereInput[]
    NOT?: GoldsmithWhereInput | GoldsmithWhereInput[]
    name?: StringFilter<"Goldsmith"> | string
    phone?: StringNullableFilter<"Goldsmith"> | string | null
    address?: StringNullableFilter<"Goldsmith"> | string | null
    createdAt?: DateTimeFilter<"Goldsmith"> | Date | string
    updatedAt?: DateTimeFilter<"Goldsmith"> | Date | string
    jobcards?: JobcardListRelationFilter
    totals?: TotalListRelationFilter
    givenGold?: GivenGoldListRelationFilter
    deliveries?: ItemDeliveryListRelationFilter
    received?: ReceivedsectionListRelationFilter
    repairs?: RepairListRelationFilter
    summaries?: BalancesListRelationFilter
  }, "id">

  export type GoldsmithOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GoldsmithCountOrderByAggregateInput
    _avg?: GoldsmithAvgOrderByAggregateInput
    _max?: GoldsmithMaxOrderByAggregateInput
    _min?: GoldsmithMinOrderByAggregateInput
    _sum?: GoldsmithSumOrderByAggregateInput
  }

  export type GoldsmithScalarWhereWithAggregatesInput = {
    AND?: GoldsmithScalarWhereWithAggregatesInput | GoldsmithScalarWhereWithAggregatesInput[]
    OR?: GoldsmithScalarWhereWithAggregatesInput[]
    NOT?: GoldsmithScalarWhereWithAggregatesInput | GoldsmithScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Goldsmith"> | number
    name?: StringWithAggregatesFilter<"Goldsmith"> | string
    phone?: StringNullableWithAggregatesFilter<"Goldsmith"> | string | null
    address?: StringNullableWithAggregatesFilter<"Goldsmith"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Goldsmith"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Goldsmith"> | Date | string
  }

  export type JobcardWhereInput = {
    AND?: JobcardWhereInput | JobcardWhereInput[]
    OR?: JobcardWhereInput[]
    NOT?: JobcardWhereInput | JobcardWhereInput[]
    id?: IntFilter<"Jobcard"> | number
    goldsmithId?: IntFilter<"Jobcard"> | number
    description?: StringFilter<"Jobcard"> | string
    createdAt?: DateTimeFilter<"Jobcard"> | Date | string
    updatedAt?: DateTimeFilter<"Jobcard"> | Date | string
    goldsmith?: XOR<GoldsmithScalarRelationFilter, GoldsmithWhereInput>
    givenGold?: GivenGoldListRelationFilter
    deliveries?: ItemDeliveryListRelationFilter
    received?: ReceivedsectionListRelationFilter
  }

  export type JobcardOrderByWithRelationInput = {
    id?: SortOrder
    goldsmithId?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    goldsmith?: GoldsmithOrderByWithRelationInput
    givenGold?: givenGoldOrderByRelationAggregateInput
    deliveries?: itemDeliveryOrderByRelationAggregateInput
    received?: ReceivedsectionOrderByRelationAggregateInput
    _relevance?: JobcardOrderByRelevanceInput
  }

  export type JobcardWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: JobcardWhereInput | JobcardWhereInput[]
    OR?: JobcardWhereInput[]
    NOT?: JobcardWhereInput | JobcardWhereInput[]
    goldsmithId?: IntFilter<"Jobcard"> | number
    description?: StringFilter<"Jobcard"> | string
    createdAt?: DateTimeFilter<"Jobcard"> | Date | string
    updatedAt?: DateTimeFilter<"Jobcard"> | Date | string
    goldsmith?: XOR<GoldsmithScalarRelationFilter, GoldsmithWhereInput>
    givenGold?: GivenGoldListRelationFilter
    deliveries?: ItemDeliveryListRelationFilter
    received?: ReceivedsectionListRelationFilter
  }, "id">

  export type JobcardOrderByWithAggregationInput = {
    id?: SortOrder
    goldsmithId?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: JobcardCountOrderByAggregateInput
    _avg?: JobcardAvgOrderByAggregateInput
    _max?: JobcardMaxOrderByAggregateInput
    _min?: JobcardMinOrderByAggregateInput
    _sum?: JobcardSumOrderByAggregateInput
  }

  export type JobcardScalarWhereWithAggregatesInput = {
    AND?: JobcardScalarWhereWithAggregatesInput | JobcardScalarWhereWithAggregatesInput[]
    OR?: JobcardScalarWhereWithAggregatesInput[]
    NOT?: JobcardScalarWhereWithAggregatesInput | JobcardScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Jobcard"> | number
    goldsmithId?: IntWithAggregatesFilter<"Jobcard"> | number
    description?: StringWithAggregatesFilter<"Jobcard"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Jobcard"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Jobcard"> | Date | string
  }

  export type givenGoldWhereInput = {
    AND?: givenGoldWhereInput | givenGoldWhereInput[]
    OR?: givenGoldWhereInput[]
    NOT?: givenGoldWhereInput | givenGoldWhereInput[]
    id?: IntFilter<"givenGold"> | number
    goldsmithId?: IntNullableFilter<"givenGold"> | number | null
    jobcardId?: IntNullableFilter<"givenGold"> | number | null
    weight?: FloatFilter<"givenGold"> | number
    touch?: FloatFilter<"givenGold"> | number
    purity?: FloatFilter<"givenGold"> | number
    createdAt?: DateTimeFilter<"givenGold"> | Date | string
    updatedAt?: DateTimeFilter<"givenGold"> | Date | string
    goldsmith?: XOR<GoldsmithNullableScalarRelationFilter, GoldsmithWhereInput> | null
    jobcard?: XOR<JobcardNullableScalarRelationFilter, JobcardWhereInput> | null
  }

  export type givenGoldOrderByWithRelationInput = {
    id?: SortOrder
    goldsmithId?: SortOrderInput | SortOrder
    jobcardId?: SortOrderInput | SortOrder
    weight?: SortOrder
    touch?: SortOrder
    purity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    goldsmith?: GoldsmithOrderByWithRelationInput
    jobcard?: JobcardOrderByWithRelationInput
  }

  export type givenGoldWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: givenGoldWhereInput | givenGoldWhereInput[]
    OR?: givenGoldWhereInput[]
    NOT?: givenGoldWhereInput | givenGoldWhereInput[]
    goldsmithId?: IntNullableFilter<"givenGold"> | number | null
    jobcardId?: IntNullableFilter<"givenGold"> | number | null
    weight?: FloatFilter<"givenGold"> | number
    touch?: FloatFilter<"givenGold"> | number
    purity?: FloatFilter<"givenGold"> | number
    createdAt?: DateTimeFilter<"givenGold"> | Date | string
    updatedAt?: DateTimeFilter<"givenGold"> | Date | string
    goldsmith?: XOR<GoldsmithNullableScalarRelationFilter, GoldsmithWhereInput> | null
    jobcard?: XOR<JobcardNullableScalarRelationFilter, JobcardWhereInput> | null
  }, "id">

  export type givenGoldOrderByWithAggregationInput = {
    id?: SortOrder
    goldsmithId?: SortOrderInput | SortOrder
    jobcardId?: SortOrderInput | SortOrder
    weight?: SortOrder
    touch?: SortOrder
    purity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: givenGoldCountOrderByAggregateInput
    _avg?: givenGoldAvgOrderByAggregateInput
    _max?: givenGoldMaxOrderByAggregateInput
    _min?: givenGoldMinOrderByAggregateInput
    _sum?: givenGoldSumOrderByAggregateInput
  }

  export type givenGoldScalarWhereWithAggregatesInput = {
    AND?: givenGoldScalarWhereWithAggregatesInput | givenGoldScalarWhereWithAggregatesInput[]
    OR?: givenGoldScalarWhereWithAggregatesInput[]
    NOT?: givenGoldScalarWhereWithAggregatesInput | givenGoldScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"givenGold"> | number
    goldsmithId?: IntNullableWithAggregatesFilter<"givenGold"> | number | null
    jobcardId?: IntNullableWithAggregatesFilter<"givenGold"> | number | null
    weight?: FloatWithAggregatesFilter<"givenGold"> | number
    touch?: FloatWithAggregatesFilter<"givenGold"> | number
    purity?: FloatWithAggregatesFilter<"givenGold"> | number
    createdAt?: DateTimeWithAggregatesFilter<"givenGold"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"givenGold"> | Date | string
  }

  export type TotalWhereInput = {
    AND?: TotalWhereInput | TotalWhereInput[]
    OR?: TotalWhereInput[]
    NOT?: TotalWhereInput | TotalWhereInput[]
    id?: IntFilter<"Total"> | number
    goldsmithId?: IntFilter<"Total"> | number
    totalPurity?: FloatFilter<"Total"> | number
    openingBalance?: FloatFilter<"Total"> | number
    totalBalance?: FloatFilter<"Total"> | number
    createdAt?: DateTimeFilter<"Total"> | Date | string
    updatedAt?: DateTimeFilter<"Total"> | Date | string
    goldsmith?: XOR<GoldsmithScalarRelationFilter, GoldsmithWhereInput>
  }

  export type TotalOrderByWithRelationInput = {
    id?: SortOrder
    goldsmithId?: SortOrder
    totalPurity?: SortOrder
    openingBalance?: SortOrder
    totalBalance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    goldsmith?: GoldsmithOrderByWithRelationInput
  }

  export type TotalWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TotalWhereInput | TotalWhereInput[]
    OR?: TotalWhereInput[]
    NOT?: TotalWhereInput | TotalWhereInput[]
    goldsmithId?: IntFilter<"Total"> | number
    totalPurity?: FloatFilter<"Total"> | number
    openingBalance?: FloatFilter<"Total"> | number
    totalBalance?: FloatFilter<"Total"> | number
    createdAt?: DateTimeFilter<"Total"> | Date | string
    updatedAt?: DateTimeFilter<"Total"> | Date | string
    goldsmith?: XOR<GoldsmithScalarRelationFilter, GoldsmithWhereInput>
  }, "id">

  export type TotalOrderByWithAggregationInput = {
    id?: SortOrder
    goldsmithId?: SortOrder
    totalPurity?: SortOrder
    openingBalance?: SortOrder
    totalBalance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TotalCountOrderByAggregateInput
    _avg?: TotalAvgOrderByAggregateInput
    _max?: TotalMaxOrderByAggregateInput
    _min?: TotalMinOrderByAggregateInput
    _sum?: TotalSumOrderByAggregateInput
  }

  export type TotalScalarWhereWithAggregatesInput = {
    AND?: TotalScalarWhereWithAggregatesInput | TotalScalarWhereWithAggregatesInput[]
    OR?: TotalScalarWhereWithAggregatesInput[]
    NOT?: TotalScalarWhereWithAggregatesInput | TotalScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Total"> | number
    goldsmithId?: IntWithAggregatesFilter<"Total"> | number
    totalPurity?: FloatWithAggregatesFilter<"Total"> | number
    openingBalance?: FloatWithAggregatesFilter<"Total"> | number
    totalBalance?: FloatWithAggregatesFilter<"Total"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Total"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Total"> | Date | string
  }

  export type itemDeliveryWhereInput = {
    AND?: itemDeliveryWhereInput | itemDeliveryWhereInput[]
    OR?: itemDeliveryWhereInput[]
    NOT?: itemDeliveryWhereInput | itemDeliveryWhereInput[]
    id?: IntFilter<"itemDelivery"> | number
    itemName?: StringFilter<"itemDelivery"> | string
    itemWeight?: FloatFilter<"itemDelivery"> | number
    type?: StringFilter<"itemDelivery"> | string
    stoneWeight?: FloatFilter<"itemDelivery"> | number
    netWeight?: FloatFilter<"itemDelivery"> | number
    wastageType?: EnumWastageTypeFilter<"itemDelivery"> | $Enums.WastageType
    wastageValue?: FloatFilter<"itemDelivery"> | number
    finalPurity?: FloatFilter<"itemDelivery"> | number
    goldsmithId?: IntNullableFilter<"itemDelivery"> | number | null
    jobcardId?: IntNullableFilter<"itemDelivery"> | number | null
    createdAt?: DateTimeFilter<"itemDelivery"> | Date | string
    updatedAt?: DateTimeFilter<"itemDelivery"> | Date | string
    goldsmith?: XOR<GoldsmithNullableScalarRelationFilter, GoldsmithWhereInput> | null
    jobcard?: XOR<JobcardNullableScalarRelationFilter, JobcardWhereInput> | null
  }

  export type itemDeliveryOrderByWithRelationInput = {
    id?: SortOrder
    itemName?: SortOrder
    itemWeight?: SortOrder
    type?: SortOrder
    stoneWeight?: SortOrder
    netWeight?: SortOrder
    wastageType?: SortOrder
    wastageValue?: SortOrder
    finalPurity?: SortOrder
    goldsmithId?: SortOrderInput | SortOrder
    jobcardId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    goldsmith?: GoldsmithOrderByWithRelationInput
    jobcard?: JobcardOrderByWithRelationInput
    _relevance?: itemDeliveryOrderByRelevanceInput
  }

  export type itemDeliveryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: itemDeliveryWhereInput | itemDeliveryWhereInput[]
    OR?: itemDeliveryWhereInput[]
    NOT?: itemDeliveryWhereInput | itemDeliveryWhereInput[]
    itemName?: StringFilter<"itemDelivery"> | string
    itemWeight?: FloatFilter<"itemDelivery"> | number
    type?: StringFilter<"itemDelivery"> | string
    stoneWeight?: FloatFilter<"itemDelivery"> | number
    netWeight?: FloatFilter<"itemDelivery"> | number
    wastageType?: EnumWastageTypeFilter<"itemDelivery"> | $Enums.WastageType
    wastageValue?: FloatFilter<"itemDelivery"> | number
    finalPurity?: FloatFilter<"itemDelivery"> | number
    goldsmithId?: IntNullableFilter<"itemDelivery"> | number | null
    jobcardId?: IntNullableFilter<"itemDelivery"> | number | null
    createdAt?: DateTimeFilter<"itemDelivery"> | Date | string
    updatedAt?: DateTimeFilter<"itemDelivery"> | Date | string
    goldsmith?: XOR<GoldsmithNullableScalarRelationFilter, GoldsmithWhereInput> | null
    jobcard?: XOR<JobcardNullableScalarRelationFilter, JobcardWhereInput> | null
  }, "id">

  export type itemDeliveryOrderByWithAggregationInput = {
    id?: SortOrder
    itemName?: SortOrder
    itemWeight?: SortOrder
    type?: SortOrder
    stoneWeight?: SortOrder
    netWeight?: SortOrder
    wastageType?: SortOrder
    wastageValue?: SortOrder
    finalPurity?: SortOrder
    goldsmithId?: SortOrderInput | SortOrder
    jobcardId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: itemDeliveryCountOrderByAggregateInput
    _avg?: itemDeliveryAvgOrderByAggregateInput
    _max?: itemDeliveryMaxOrderByAggregateInput
    _min?: itemDeliveryMinOrderByAggregateInput
    _sum?: itemDeliverySumOrderByAggregateInput
  }

  export type itemDeliveryScalarWhereWithAggregatesInput = {
    AND?: itemDeliveryScalarWhereWithAggregatesInput | itemDeliveryScalarWhereWithAggregatesInput[]
    OR?: itemDeliveryScalarWhereWithAggregatesInput[]
    NOT?: itemDeliveryScalarWhereWithAggregatesInput | itemDeliveryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"itemDelivery"> | number
    itemName?: StringWithAggregatesFilter<"itemDelivery"> | string
    itemWeight?: FloatWithAggregatesFilter<"itemDelivery"> | number
    type?: StringWithAggregatesFilter<"itemDelivery"> | string
    stoneWeight?: FloatWithAggregatesFilter<"itemDelivery"> | number
    netWeight?: FloatWithAggregatesFilter<"itemDelivery"> | number
    wastageType?: EnumWastageTypeWithAggregatesFilter<"itemDelivery"> | $Enums.WastageType
    wastageValue?: FloatWithAggregatesFilter<"itemDelivery"> | number
    finalPurity?: FloatWithAggregatesFilter<"itemDelivery"> | number
    goldsmithId?: IntNullableWithAggregatesFilter<"itemDelivery"> | number | null
    jobcardId?: IntNullableWithAggregatesFilter<"itemDelivery"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"itemDelivery"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"itemDelivery"> | Date | string
  }

  export type ReceivedsectionWhereInput = {
    AND?: ReceivedsectionWhereInput | ReceivedsectionWhereInput[]
    OR?: ReceivedsectionWhereInput[]
    NOT?: ReceivedsectionWhereInput | ReceivedsectionWhereInput[]
    id?: IntFilter<"Receivedsection"> | number
    weight?: FloatFilter<"Receivedsection"> | number
    touch?: FloatFilter<"Receivedsection"> | number
    purity?: FloatFilter<"Receivedsection"> | number
    jobcardId?: IntNullableFilter<"Receivedsection"> | number | null
    goldsmithId?: IntNullableFilter<"Receivedsection"> | number | null
    createdAt?: DateTimeFilter<"Receivedsection"> | Date | string
    updatedAt?: DateTimeFilter<"Receivedsection"> | Date | string
    jobcard?: XOR<JobcardNullableScalarRelationFilter, JobcardWhereInput> | null
    goldsmith?: XOR<GoldsmithNullableScalarRelationFilter, GoldsmithWhereInput> | null
  }

  export type ReceivedsectionOrderByWithRelationInput = {
    id?: SortOrder
    weight?: SortOrder
    touch?: SortOrder
    purity?: SortOrder
    jobcardId?: SortOrderInput | SortOrder
    goldsmithId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    jobcard?: JobcardOrderByWithRelationInput
    goldsmith?: GoldsmithOrderByWithRelationInput
  }

  export type ReceivedsectionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ReceivedsectionWhereInput | ReceivedsectionWhereInput[]
    OR?: ReceivedsectionWhereInput[]
    NOT?: ReceivedsectionWhereInput | ReceivedsectionWhereInput[]
    weight?: FloatFilter<"Receivedsection"> | number
    touch?: FloatFilter<"Receivedsection"> | number
    purity?: FloatFilter<"Receivedsection"> | number
    jobcardId?: IntNullableFilter<"Receivedsection"> | number | null
    goldsmithId?: IntNullableFilter<"Receivedsection"> | number | null
    createdAt?: DateTimeFilter<"Receivedsection"> | Date | string
    updatedAt?: DateTimeFilter<"Receivedsection"> | Date | string
    jobcard?: XOR<JobcardNullableScalarRelationFilter, JobcardWhereInput> | null
    goldsmith?: XOR<GoldsmithNullableScalarRelationFilter, GoldsmithWhereInput> | null
  }, "id">

  export type ReceivedsectionOrderByWithAggregationInput = {
    id?: SortOrder
    weight?: SortOrder
    touch?: SortOrder
    purity?: SortOrder
    jobcardId?: SortOrderInput | SortOrder
    goldsmithId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ReceivedsectionCountOrderByAggregateInput
    _avg?: ReceivedsectionAvgOrderByAggregateInput
    _max?: ReceivedsectionMaxOrderByAggregateInput
    _min?: ReceivedsectionMinOrderByAggregateInput
    _sum?: ReceivedsectionSumOrderByAggregateInput
  }

  export type ReceivedsectionScalarWhereWithAggregatesInput = {
    AND?: ReceivedsectionScalarWhereWithAggregatesInput | ReceivedsectionScalarWhereWithAggregatesInput[]
    OR?: ReceivedsectionScalarWhereWithAggregatesInput[]
    NOT?: ReceivedsectionScalarWhereWithAggregatesInput | ReceivedsectionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Receivedsection"> | number
    weight?: FloatWithAggregatesFilter<"Receivedsection"> | number
    touch?: FloatWithAggregatesFilter<"Receivedsection"> | number
    purity?: FloatWithAggregatesFilter<"Receivedsection"> | number
    jobcardId?: IntNullableWithAggregatesFilter<"Receivedsection"> | number | null
    goldsmithId?: IntNullableWithAggregatesFilter<"Receivedsection"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Receivedsection"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Receivedsection"> | Date | string
  }

  export type BalancesWhereInput = {
    AND?: BalancesWhereInput | BalancesWhereInput[]
    OR?: BalancesWhereInput[]
    NOT?: BalancesWhereInput | BalancesWhereInput[]
    id?: IntFilter<"Balances"> | number
    goldsmithId?: IntFilter<"Balances"> | number
    totalDeliveries?: IntFilter<"Balances"> | number
    totalItemWeight?: FloatFilter<"Balances"> | number
    totalNetWeight?: FloatFilter<"Balances"> | number
    totalPurity?: FloatFilter<"Balances"> | number
    totalReceivedWeight?: FloatFilter<"Balances"> | number
    totalReceivedTouch?: FloatFilter<"Balances"> | number
    totalReceivedPurity?: FloatFilter<"Balances"> | number
    createdAt?: DateTimeFilter<"Balances"> | Date | string
    updatedAt?: DateTimeFilter<"Balances"> | Date | string
    goldsmith?: XOR<GoldsmithScalarRelationFilter, GoldsmithWhereInput>
  }

  export type BalancesOrderByWithRelationInput = {
    id?: SortOrder
    goldsmithId?: SortOrder
    totalDeliveries?: SortOrder
    totalItemWeight?: SortOrder
    totalNetWeight?: SortOrder
    totalPurity?: SortOrder
    totalReceivedWeight?: SortOrder
    totalReceivedTouch?: SortOrder
    totalReceivedPurity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    goldsmith?: GoldsmithOrderByWithRelationInput
  }

  export type BalancesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BalancesWhereInput | BalancesWhereInput[]
    OR?: BalancesWhereInput[]
    NOT?: BalancesWhereInput | BalancesWhereInput[]
    goldsmithId?: IntFilter<"Balances"> | number
    totalDeliveries?: IntFilter<"Balances"> | number
    totalItemWeight?: FloatFilter<"Balances"> | number
    totalNetWeight?: FloatFilter<"Balances"> | number
    totalPurity?: FloatFilter<"Balances"> | number
    totalReceivedWeight?: FloatFilter<"Balances"> | number
    totalReceivedTouch?: FloatFilter<"Balances"> | number
    totalReceivedPurity?: FloatFilter<"Balances"> | number
    createdAt?: DateTimeFilter<"Balances"> | Date | string
    updatedAt?: DateTimeFilter<"Balances"> | Date | string
    goldsmith?: XOR<GoldsmithScalarRelationFilter, GoldsmithWhereInput>
  }, "id">

  export type BalancesOrderByWithAggregationInput = {
    id?: SortOrder
    goldsmithId?: SortOrder
    totalDeliveries?: SortOrder
    totalItemWeight?: SortOrder
    totalNetWeight?: SortOrder
    totalPurity?: SortOrder
    totalReceivedWeight?: SortOrder
    totalReceivedTouch?: SortOrder
    totalReceivedPurity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BalancesCountOrderByAggregateInput
    _avg?: BalancesAvgOrderByAggregateInput
    _max?: BalancesMaxOrderByAggregateInput
    _min?: BalancesMinOrderByAggregateInput
    _sum?: BalancesSumOrderByAggregateInput
  }

  export type BalancesScalarWhereWithAggregatesInput = {
    AND?: BalancesScalarWhereWithAggregatesInput | BalancesScalarWhereWithAggregatesInput[]
    OR?: BalancesScalarWhereWithAggregatesInput[]
    NOT?: BalancesScalarWhereWithAggregatesInput | BalancesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Balances"> | number
    goldsmithId?: IntWithAggregatesFilter<"Balances"> | number
    totalDeliveries?: IntWithAggregatesFilter<"Balances"> | number
    totalItemWeight?: FloatWithAggregatesFilter<"Balances"> | number
    totalNetWeight?: FloatWithAggregatesFilter<"Balances"> | number
    totalPurity?: FloatWithAggregatesFilter<"Balances"> | number
    totalReceivedWeight?: FloatWithAggregatesFilter<"Balances"> | number
    totalReceivedTouch?: FloatWithAggregatesFilter<"Balances"> | number
    totalReceivedPurity?: FloatWithAggregatesFilter<"Balances"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Balances"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Balances"> | Date | string
  }

  export type RepairWhereInput = {
    AND?: RepairWhereInput | RepairWhereInput[]
    OR?: RepairWhereInput[]
    NOT?: RepairWhereInput | RepairWhereInput[]
    id?: IntFilter<"Repair"> | number
    goldsmithId?: IntFilter<"Repair"> | number
    givenWeights?: JsonFilter<"Repair">
    totalGiven?: FloatFilter<"Repair"> | number
    itemWeights?: JsonFilter<"Repair">
    totalItem?: FloatFilter<"Repair"> | number
    stone?: FloatFilter<"Repair"> | number
    wastageType?: StringFilter<"Repair"> | string
    touch?: FloatFilter<"Repair"> | number
    netWeight?: FloatFilter<"Repair"> | number
    createdAt?: DateTimeFilter<"Repair"> | Date | string
    goldsmith?: XOR<GoldsmithScalarRelationFilter, GoldsmithWhereInput>
  }

  export type RepairOrderByWithRelationInput = {
    id?: SortOrder
    goldsmithId?: SortOrder
    givenWeights?: SortOrder
    totalGiven?: SortOrder
    itemWeights?: SortOrder
    totalItem?: SortOrder
    stone?: SortOrder
    wastageType?: SortOrder
    touch?: SortOrder
    netWeight?: SortOrder
    createdAt?: SortOrder
    goldsmith?: GoldsmithOrderByWithRelationInput
    _relevance?: RepairOrderByRelevanceInput
  }

  export type RepairWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RepairWhereInput | RepairWhereInput[]
    OR?: RepairWhereInput[]
    NOT?: RepairWhereInput | RepairWhereInput[]
    goldsmithId?: IntFilter<"Repair"> | number
    givenWeights?: JsonFilter<"Repair">
    totalGiven?: FloatFilter<"Repair"> | number
    itemWeights?: JsonFilter<"Repair">
    totalItem?: FloatFilter<"Repair"> | number
    stone?: FloatFilter<"Repair"> | number
    wastageType?: StringFilter<"Repair"> | string
    touch?: FloatFilter<"Repair"> | number
    netWeight?: FloatFilter<"Repair"> | number
    createdAt?: DateTimeFilter<"Repair"> | Date | string
    goldsmith?: XOR<GoldsmithScalarRelationFilter, GoldsmithWhereInput>
  }, "id">

  export type RepairOrderByWithAggregationInput = {
    id?: SortOrder
    goldsmithId?: SortOrder
    givenWeights?: SortOrder
    totalGiven?: SortOrder
    itemWeights?: SortOrder
    totalItem?: SortOrder
    stone?: SortOrder
    wastageType?: SortOrder
    touch?: SortOrder
    netWeight?: SortOrder
    createdAt?: SortOrder
    _count?: RepairCountOrderByAggregateInput
    _avg?: RepairAvgOrderByAggregateInput
    _max?: RepairMaxOrderByAggregateInput
    _min?: RepairMinOrderByAggregateInput
    _sum?: RepairSumOrderByAggregateInput
  }

  export type RepairScalarWhereWithAggregatesInput = {
    AND?: RepairScalarWhereWithAggregatesInput | RepairScalarWhereWithAggregatesInput[]
    OR?: RepairScalarWhereWithAggregatesInput[]
    NOT?: RepairScalarWhereWithAggregatesInput | RepairScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Repair"> | number
    goldsmithId?: IntWithAggregatesFilter<"Repair"> | number
    givenWeights?: JsonWithAggregatesFilter<"Repair">
    totalGiven?: FloatWithAggregatesFilter<"Repair"> | number
    itemWeights?: JsonWithAggregatesFilter<"Repair">
    totalItem?: FloatWithAggregatesFilter<"Repair"> | number
    stone?: FloatWithAggregatesFilter<"Repair"> | number
    wastageType?: StringWithAggregatesFilter<"Repair"> | string
    touch?: FloatWithAggregatesFilter<"Repair"> | number
    netWeight?: FloatWithAggregatesFilter<"Repair"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Repair"> | Date | string
  }

  export type UserCreateInput = {
    username: string
    password: string
    createdAt?: Date | string
  }

  export type UserUncheckedCreateInput = {
    id?: number
    username: string
    password: string
    createdAt?: Date | string
  }

  export type UserUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateManyInput = {
    id?: number
    username: string
    password: string
    createdAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerCreateInput = {
    name: string
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    transactions?: TransactionCreateNestedManyWithoutCustomerInput
    customerOrders?: customer_orderCreateNestedManyWithoutCustomersInput
  }

  export type CustomerUncheckedCreateInput = {
    id?: number
    name: string
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutCustomerInput
    customerOrders?: customer_orderUncheckedCreateNestedManyWithoutCustomersInput
  }

  export type CustomerUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUpdateManyWithoutCustomerNestedInput
    customerOrders?: customer_orderUpdateManyWithoutCustomersNestedInput
  }

  export type CustomerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutCustomerNestedInput
    customerOrders?: customer_orderUncheckedUpdateManyWithoutCustomersNestedInput
  }

  export type CustomerCreateManyInput = {
    id?: number
    name: string
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
  }

  export type CustomerUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MasterItemCreateInput = {
    itemName: string
    createdAt?: Date | string
  }

  export type MasterItemUncheckedCreateInput = {
    id?: number
    itemName: string
    createdAt?: Date | string
  }

  export type MasterItemUpdateInput = {
    itemName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MasterItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MasterItemCreateManyInput = {
    id?: number
    itemName: string
    createdAt?: Date | string
  }

  export type MasterItemUpdateManyMutationInput = {
    itemName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MasterItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MasterTouchCreateInput = {
    touch: number
    createdAt?: Date | string
  }

  export type MasterTouchUncheckedCreateInput = {
    id?: number
    touch: number
    createdAt?: Date | string
  }

  export type MasterTouchUpdateInput = {
    touch?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MasterTouchUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    touch?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MasterTouchCreateManyInput = {
    id?: number
    touch: number
    createdAt?: Date | string
  }

  export type MasterTouchUpdateManyMutationInput = {
    touch?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MasterTouchUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    touch?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JewelStockCreateInput = {
    jewelName: string
    weight: number
    stoneWeight: number
    finalWeight: number
    touch: number
    purityValue: number
    createdAt?: Date | string
  }

  export type JewelStockUncheckedCreateInput = {
    id?: number
    jewelName: string
    weight: number
    stoneWeight: number
    finalWeight: number
    touch: number
    purityValue: number
    createdAt?: Date | string
  }

  export type JewelStockUpdateInput = {
    jewelName?: StringFieldUpdateOperationsInput | string
    weight?: FloatFieldUpdateOperationsInput | number
    stoneWeight?: FloatFieldUpdateOperationsInput | number
    finalWeight?: FloatFieldUpdateOperationsInput | number
    touch?: FloatFieldUpdateOperationsInput | number
    purityValue?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JewelStockUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    jewelName?: StringFieldUpdateOperationsInput | string
    weight?: FloatFieldUpdateOperationsInput | number
    stoneWeight?: FloatFieldUpdateOperationsInput | number
    finalWeight?: FloatFieldUpdateOperationsInput | number
    touch?: FloatFieldUpdateOperationsInput | number
    purityValue?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JewelStockCreateManyInput = {
    id?: number
    jewelName: string
    weight: number
    stoneWeight: number
    finalWeight: number
    touch: number
    purityValue: number
    createdAt?: Date | string
  }

  export type JewelStockUpdateManyMutationInput = {
    jewelName?: StringFieldUpdateOperationsInput | string
    weight?: FloatFieldUpdateOperationsInput | number
    stoneWeight?: FloatFieldUpdateOperationsInput | number
    finalWeight?: FloatFieldUpdateOperationsInput | number
    touch?: FloatFieldUpdateOperationsInput | number
    purityValue?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JewelStockUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    jewelName?: StringFieldUpdateOperationsInput | string
    weight?: FloatFieldUpdateOperationsInput | number
    stoneWeight?: FloatFieldUpdateOperationsInput | number
    finalWeight?: FloatFieldUpdateOperationsInput | number
    touch?: FloatFieldUpdateOperationsInput | number
    purityValue?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateInput = {
    date: Date | string
    type: string
    value: number
    goldRate?: number | null
    purity: number
    touch?: number | null
    createdAt?: Date | string
    customer: CustomerCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateInput = {
    id?: number
    date: Date | string
    type: string
    value: number
    goldRate?: number | null
    purity: number
    touch?: number | null
    customerId: number
    createdAt?: Date | string
  }

  export type TransactionUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    goldRate?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: FloatFieldUpdateOperationsInput | number
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    goldRate?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: FloatFieldUpdateOperationsInput | number
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    customerId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateManyInput = {
    id?: number
    date: Date | string
    type: string
    value: number
    goldRate?: number | null
    purity: number
    touch?: number | null
    customerId: number
    createdAt?: Date | string
  }

  export type TransactionUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    goldRate?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: FloatFieldUpdateOperationsInput | number
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    goldRate?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: FloatFieldUpdateOperationsInput | number
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    customerId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EntryCreateInput = {
    date: Date | string
    type: string
    cashAmount?: number | null
    goldValue?: number | null
    touch?: number | null
    purity?: number | null
    goldRate?: number | null
    createdAt?: Date | string
  }

  export type EntryUncheckedCreateInput = {
    id?: number
    date: Date | string
    type: string
    cashAmount?: number | null
    goldValue?: number | null
    touch?: number | null
    purity?: number | null
    goldRate?: number | null
    createdAt?: Date | string
  }

  export type EntryUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    cashAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    goldValue?: NullableFloatFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    goldRate?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EntryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    cashAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    goldValue?: NullableFloatFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    goldRate?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EntryCreateManyInput = {
    id?: number
    date: Date | string
    type: string
    cashAmount?: number | null
    goldValue?: number | null
    touch?: number | null
    purity?: number | null
    goldRate?: number | null
    createdAt?: Date | string
  }

  export type EntryUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    cashAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    goldValue?: NullableFloatFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    goldRate?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EntryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    cashAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    goldValue?: NullableFloatFieldUpdateOperationsInput | number | null
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    goldRate?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type customer_orderCreateInput = {
    order_group_id: number
    item_name: string
    description: string
    weight: number
    image?: string | null
    due_date?: Date | string | null
    status?: string
    worker_name?: string | null
    created_at?: Date | string
    updatedAt?: Date | string
    customers: CustomerCreateNestedOneWithoutCustomerOrdersInput
    productImages?: product_multiple_imagesCreateNestedManyWithoutCustomerOrderDetailsInput
  }

  export type customer_orderUncheckedCreateInput = {
    id?: number
    customer_id: number
    order_group_id: number
    item_name: string
    description: string
    weight: number
    image?: string | null
    due_date?: Date | string | null
    status?: string
    worker_name?: string | null
    created_at?: Date | string
    updatedAt?: Date | string
    productImages?: product_multiple_imagesUncheckedCreateNestedManyWithoutCustomerOrderDetailsInput
  }

  export type customer_orderUpdateInput = {
    order_group_id?: IntFieldUpdateOperationsInput | number
    item_name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    weight?: FloatFieldUpdateOperationsInput | number
    image?: NullableStringFieldUpdateOperationsInput | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    worker_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customers?: CustomerUpdateOneRequiredWithoutCustomerOrdersNestedInput
    productImages?: product_multiple_imagesUpdateManyWithoutCustomerOrderDetailsNestedInput
  }

  export type customer_orderUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    customer_id?: IntFieldUpdateOperationsInput | number
    order_group_id?: IntFieldUpdateOperationsInput | number
    item_name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    weight?: FloatFieldUpdateOperationsInput | number
    image?: NullableStringFieldUpdateOperationsInput | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    worker_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productImages?: product_multiple_imagesUncheckedUpdateManyWithoutCustomerOrderDetailsNestedInput
  }

  export type customer_orderCreateManyInput = {
    id?: number
    customer_id: number
    order_group_id: number
    item_name: string
    description: string
    weight: number
    image?: string | null
    due_date?: Date | string | null
    status?: string
    worker_name?: string | null
    created_at?: Date | string
    updatedAt?: Date | string
  }

  export type customer_orderUpdateManyMutationInput = {
    order_group_id?: IntFieldUpdateOperationsInput | number
    item_name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    weight?: FloatFieldUpdateOperationsInput | number
    image?: NullableStringFieldUpdateOperationsInput | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    worker_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type customer_orderUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    customer_id?: IntFieldUpdateOperationsInput | number
    order_group_id?: IntFieldUpdateOperationsInput | number
    item_name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    weight?: FloatFieldUpdateOperationsInput | number
    image?: NullableStringFieldUpdateOperationsInput | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    worker_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type product_multiple_imagesCreateInput = {
    filename: string
    customerOrderDetails: customer_orderCreateNestedOneWithoutProductImagesInput
  }

  export type product_multiple_imagesUncheckedCreateInput = {
    id?: number
    customer_order_id: number
    filename: string
  }

  export type product_multiple_imagesUpdateInput = {
    filename?: StringFieldUpdateOperationsInput | string
    customerOrderDetails?: customer_orderUpdateOneRequiredWithoutProductImagesNestedInput
  }

  export type product_multiple_imagesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    customer_order_id?: IntFieldUpdateOperationsInput | number
    filename?: StringFieldUpdateOperationsInput | string
  }

  export type product_multiple_imagesCreateManyInput = {
    id?: number
    customer_order_id: number
    filename: string
  }

  export type product_multiple_imagesUpdateManyMutationInput = {
    filename?: StringFieldUpdateOperationsInput | string
  }

  export type product_multiple_imagesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    customer_order_id?: IntFieldUpdateOperationsInput | number
    filename?: StringFieldUpdateOperationsInput | string
  }

  export type MasterBullionCreateInput = {
    name: string
    phone?: string | null
    address?: string | null
    purchases?: BullionPurchaseCreateNestedManyWithoutBullionInput
  }

  export type MasterBullionUncheckedCreateInput = {
    id?: number
    name: string
    phone?: string | null
    address?: string | null
    purchases?: BullionPurchaseUncheckedCreateNestedManyWithoutBullionInput
  }

  export type MasterBullionUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    purchases?: BullionPurchaseUpdateManyWithoutBullionNestedInput
  }

  export type MasterBullionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    purchases?: BullionPurchaseUncheckedUpdateManyWithoutBullionNestedInput
  }

  export type MasterBullionCreateManyInput = {
    id?: number
    name: string
    phone?: string | null
    address?: string | null
  }

  export type MasterBullionUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MasterBullionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BullionPurchaseCreateInput = {
    grams: number
    touch?: number | null
    purity?: number | null
    rate: number
    amount: number
    balance: number
    createdAt?: Date | string
    bullion: MasterBullionCreateNestedOneWithoutPurchasesInput
    givenDetails?: GivenDetailCreateNestedManyWithoutBullionPurchaseInput
  }

  export type BullionPurchaseUncheckedCreateInput = {
    id?: number
    bullionId: number
    grams: number
    touch?: number | null
    purity?: number | null
    rate: number
    amount: number
    balance: number
    createdAt?: Date | string
    givenDetails?: GivenDetailUncheckedCreateNestedManyWithoutBullionPurchaseInput
  }

  export type BullionPurchaseUpdateInput = {
    grams?: FloatFieldUpdateOperationsInput | number
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bullion?: MasterBullionUpdateOneRequiredWithoutPurchasesNestedInput
    givenDetails?: GivenDetailUpdateManyWithoutBullionPurchaseNestedInput
  }

  export type BullionPurchaseUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    bullionId?: IntFieldUpdateOperationsInput | number
    grams?: FloatFieldUpdateOperationsInput | number
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    givenDetails?: GivenDetailUncheckedUpdateManyWithoutBullionPurchaseNestedInput
  }

  export type BullionPurchaseCreateManyInput = {
    id?: number
    bullionId: number
    grams: number
    touch?: number | null
    purity?: number | null
    rate: number
    amount: number
    balance: number
    createdAt?: Date | string
  }

  export type BullionPurchaseUpdateManyMutationInput = {
    grams?: FloatFieldUpdateOperationsInput | number
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BullionPurchaseUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    bullionId?: IntFieldUpdateOperationsInput | number
    grams?: FloatFieldUpdateOperationsInput | number
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GivenDetailCreateInput = {
    amount: number
    grams: number
    touch?: number | null
    purity?: number | null
    bullionPurchase: BullionPurchaseCreateNestedOneWithoutGivenDetailsInput
  }

  export type GivenDetailUncheckedCreateInput = {
    id?: number
    amount: number
    grams: number
    touch?: number | null
    purity?: number | null
    purchaseId: number
  }

  export type GivenDetailUpdateInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    grams?: FloatFieldUpdateOperationsInput | number
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    bullionPurchase?: BullionPurchaseUpdateOneRequiredWithoutGivenDetailsNestedInput
  }

  export type GivenDetailUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    grams?: FloatFieldUpdateOperationsInput | number
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    purchaseId?: IntFieldUpdateOperationsInput | number
  }

  export type GivenDetailCreateManyInput = {
    id?: number
    amount: number
    grams: number
    touch?: number | null
    purity?: number | null
    purchaseId: number
  }

  export type GivenDetailUpdateManyMutationInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    grams?: FloatFieldUpdateOperationsInput | number
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type GivenDetailUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    grams?: FloatFieldUpdateOperationsInput | number
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    purchaseId?: IntFieldUpdateOperationsInput | number
  }

  export type GoldsmithCreateInput = {
    name: string
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    jobcards?: JobcardCreateNestedManyWithoutGoldsmithInput
    totals?: TotalCreateNestedManyWithoutGoldsmithInput
    givenGold?: givenGoldCreateNestedManyWithoutGoldsmithInput
    deliveries?: itemDeliveryCreateNestedManyWithoutGoldsmithInput
    received?: ReceivedsectionCreateNestedManyWithoutGoldsmithInput
    repairs?: RepairCreateNestedManyWithoutGoldsmithInput
    summaries?: BalancesCreateNestedManyWithoutGoldsmithInput
  }

  export type GoldsmithUncheckedCreateInput = {
    id?: number
    name: string
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    jobcards?: JobcardUncheckedCreateNestedManyWithoutGoldsmithInput
    totals?: TotalUncheckedCreateNestedManyWithoutGoldsmithInput
    givenGold?: givenGoldUncheckedCreateNestedManyWithoutGoldsmithInput
    deliveries?: itemDeliveryUncheckedCreateNestedManyWithoutGoldsmithInput
    received?: ReceivedsectionUncheckedCreateNestedManyWithoutGoldsmithInput
    repairs?: RepairUncheckedCreateNestedManyWithoutGoldsmithInput
    summaries?: BalancesUncheckedCreateNestedManyWithoutGoldsmithInput
  }

  export type GoldsmithUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobcards?: JobcardUpdateManyWithoutGoldsmithNestedInput
    totals?: TotalUpdateManyWithoutGoldsmithNestedInput
    givenGold?: givenGoldUpdateManyWithoutGoldsmithNestedInput
    deliveries?: itemDeliveryUpdateManyWithoutGoldsmithNestedInput
    received?: ReceivedsectionUpdateManyWithoutGoldsmithNestedInput
    repairs?: RepairUpdateManyWithoutGoldsmithNestedInput
    summaries?: BalancesUpdateManyWithoutGoldsmithNestedInput
  }

  export type GoldsmithUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobcards?: JobcardUncheckedUpdateManyWithoutGoldsmithNestedInput
    totals?: TotalUncheckedUpdateManyWithoutGoldsmithNestedInput
    givenGold?: givenGoldUncheckedUpdateManyWithoutGoldsmithNestedInput
    deliveries?: itemDeliveryUncheckedUpdateManyWithoutGoldsmithNestedInput
    received?: ReceivedsectionUncheckedUpdateManyWithoutGoldsmithNestedInput
    repairs?: RepairUncheckedUpdateManyWithoutGoldsmithNestedInput
    summaries?: BalancesUncheckedUpdateManyWithoutGoldsmithNestedInput
  }

  export type GoldsmithCreateManyInput = {
    id?: number
    name: string
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GoldsmithUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GoldsmithUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobcardCreateInput = {
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    goldsmith: GoldsmithCreateNestedOneWithoutJobcardsInput
    givenGold?: givenGoldCreateNestedManyWithoutJobcardInput
    deliveries?: itemDeliveryCreateNestedManyWithoutJobcardInput
    received?: ReceivedsectionCreateNestedManyWithoutJobcardInput
  }

  export type JobcardUncheckedCreateInput = {
    id?: number
    goldsmithId: number
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    givenGold?: givenGoldUncheckedCreateNestedManyWithoutJobcardInput
    deliveries?: itemDeliveryUncheckedCreateNestedManyWithoutJobcardInput
    received?: ReceivedsectionUncheckedCreateNestedManyWithoutJobcardInput
  }

  export type JobcardUpdateInput = {
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    goldsmith?: GoldsmithUpdateOneRequiredWithoutJobcardsNestedInput
    givenGold?: givenGoldUpdateManyWithoutJobcardNestedInput
    deliveries?: itemDeliveryUpdateManyWithoutJobcardNestedInput
    received?: ReceivedsectionUpdateManyWithoutJobcardNestedInput
  }

  export type JobcardUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    goldsmithId?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    givenGold?: givenGoldUncheckedUpdateManyWithoutJobcardNestedInput
    deliveries?: itemDeliveryUncheckedUpdateManyWithoutJobcardNestedInput
    received?: ReceivedsectionUncheckedUpdateManyWithoutJobcardNestedInput
  }

  export type JobcardCreateManyInput = {
    id?: number
    goldsmithId: number
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JobcardUpdateManyMutationInput = {
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobcardUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    goldsmithId?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type givenGoldCreateInput = {
    weight: number
    touch: number
    purity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    goldsmith?: GoldsmithCreateNestedOneWithoutGivenGoldInput
    jobcard?: JobcardCreateNestedOneWithoutGivenGoldInput
  }

  export type givenGoldUncheckedCreateInput = {
    id?: number
    goldsmithId?: number | null
    jobcardId?: number | null
    weight: number
    touch: number
    purity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type givenGoldUpdateInput = {
    weight?: FloatFieldUpdateOperationsInput | number
    touch?: FloatFieldUpdateOperationsInput | number
    purity?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    goldsmith?: GoldsmithUpdateOneWithoutGivenGoldNestedInput
    jobcard?: JobcardUpdateOneWithoutGivenGoldNestedInput
  }

  export type givenGoldUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    goldsmithId?: NullableIntFieldUpdateOperationsInput | number | null
    jobcardId?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: FloatFieldUpdateOperationsInput | number
    touch?: FloatFieldUpdateOperationsInput | number
    purity?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type givenGoldCreateManyInput = {
    id?: number
    goldsmithId?: number | null
    jobcardId?: number | null
    weight: number
    touch: number
    purity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type givenGoldUpdateManyMutationInput = {
    weight?: FloatFieldUpdateOperationsInput | number
    touch?: FloatFieldUpdateOperationsInput | number
    purity?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type givenGoldUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    goldsmithId?: NullableIntFieldUpdateOperationsInput | number | null
    jobcardId?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: FloatFieldUpdateOperationsInput | number
    touch?: FloatFieldUpdateOperationsInput | number
    purity?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TotalCreateInput = {
    totalPurity: number
    openingBalance: number
    totalBalance: number
    createdAt?: Date | string
    updatedAt?: Date | string
    goldsmith: GoldsmithCreateNestedOneWithoutTotalsInput
  }

  export type TotalUncheckedCreateInput = {
    id?: number
    goldsmithId: number
    totalPurity: number
    openingBalance: number
    totalBalance: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TotalUpdateInput = {
    totalPurity?: FloatFieldUpdateOperationsInput | number
    openingBalance?: FloatFieldUpdateOperationsInput | number
    totalBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    goldsmith?: GoldsmithUpdateOneRequiredWithoutTotalsNestedInput
  }

  export type TotalUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    goldsmithId?: IntFieldUpdateOperationsInput | number
    totalPurity?: FloatFieldUpdateOperationsInput | number
    openingBalance?: FloatFieldUpdateOperationsInput | number
    totalBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TotalCreateManyInput = {
    id?: number
    goldsmithId: number
    totalPurity: number
    openingBalance: number
    totalBalance: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TotalUpdateManyMutationInput = {
    totalPurity?: FloatFieldUpdateOperationsInput | number
    openingBalance?: FloatFieldUpdateOperationsInput | number
    totalBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TotalUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    goldsmithId?: IntFieldUpdateOperationsInput | number
    totalPurity?: FloatFieldUpdateOperationsInput | number
    openingBalance?: FloatFieldUpdateOperationsInput | number
    totalBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type itemDeliveryCreateInput = {
    itemName: string
    itemWeight: number
    type: string
    stoneWeight: number
    netWeight: number
    wastageType: $Enums.WastageType
    wastageValue: number
    finalPurity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    goldsmith?: GoldsmithCreateNestedOneWithoutDeliveriesInput
    jobcard?: JobcardCreateNestedOneWithoutDeliveriesInput
  }

  export type itemDeliveryUncheckedCreateInput = {
    id?: number
    itemName: string
    itemWeight: number
    type: string
    stoneWeight: number
    netWeight: number
    wastageType: $Enums.WastageType
    wastageValue: number
    finalPurity: number
    goldsmithId?: number | null
    jobcardId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type itemDeliveryUpdateInput = {
    itemName?: StringFieldUpdateOperationsInput | string
    itemWeight?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    stoneWeight?: FloatFieldUpdateOperationsInput | number
    netWeight?: FloatFieldUpdateOperationsInput | number
    wastageType?: EnumWastageTypeFieldUpdateOperationsInput | $Enums.WastageType
    wastageValue?: FloatFieldUpdateOperationsInput | number
    finalPurity?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    goldsmith?: GoldsmithUpdateOneWithoutDeliveriesNestedInput
    jobcard?: JobcardUpdateOneWithoutDeliveriesNestedInput
  }

  export type itemDeliveryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemName?: StringFieldUpdateOperationsInput | string
    itemWeight?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    stoneWeight?: FloatFieldUpdateOperationsInput | number
    netWeight?: FloatFieldUpdateOperationsInput | number
    wastageType?: EnumWastageTypeFieldUpdateOperationsInput | $Enums.WastageType
    wastageValue?: FloatFieldUpdateOperationsInput | number
    finalPurity?: FloatFieldUpdateOperationsInput | number
    goldsmithId?: NullableIntFieldUpdateOperationsInput | number | null
    jobcardId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type itemDeliveryCreateManyInput = {
    id?: number
    itemName: string
    itemWeight: number
    type: string
    stoneWeight: number
    netWeight: number
    wastageType: $Enums.WastageType
    wastageValue: number
    finalPurity: number
    goldsmithId?: number | null
    jobcardId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type itemDeliveryUpdateManyMutationInput = {
    itemName?: StringFieldUpdateOperationsInput | string
    itemWeight?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    stoneWeight?: FloatFieldUpdateOperationsInput | number
    netWeight?: FloatFieldUpdateOperationsInput | number
    wastageType?: EnumWastageTypeFieldUpdateOperationsInput | $Enums.WastageType
    wastageValue?: FloatFieldUpdateOperationsInput | number
    finalPurity?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type itemDeliveryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemName?: StringFieldUpdateOperationsInput | string
    itemWeight?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    stoneWeight?: FloatFieldUpdateOperationsInput | number
    netWeight?: FloatFieldUpdateOperationsInput | number
    wastageType?: EnumWastageTypeFieldUpdateOperationsInput | $Enums.WastageType
    wastageValue?: FloatFieldUpdateOperationsInput | number
    finalPurity?: FloatFieldUpdateOperationsInput | number
    goldsmithId?: NullableIntFieldUpdateOperationsInput | number | null
    jobcardId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReceivedsectionCreateInput = {
    weight: number
    touch: number
    purity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    jobcard?: JobcardCreateNestedOneWithoutReceivedInput
    goldsmith?: GoldsmithCreateNestedOneWithoutReceivedInput
  }

  export type ReceivedsectionUncheckedCreateInput = {
    id?: number
    weight: number
    touch: number
    purity: number
    jobcardId?: number | null
    goldsmithId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReceivedsectionUpdateInput = {
    weight?: FloatFieldUpdateOperationsInput | number
    touch?: FloatFieldUpdateOperationsInput | number
    purity?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobcard?: JobcardUpdateOneWithoutReceivedNestedInput
    goldsmith?: GoldsmithUpdateOneWithoutReceivedNestedInput
  }

  export type ReceivedsectionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    touch?: FloatFieldUpdateOperationsInput | number
    purity?: FloatFieldUpdateOperationsInput | number
    jobcardId?: NullableIntFieldUpdateOperationsInput | number | null
    goldsmithId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReceivedsectionCreateManyInput = {
    id?: number
    weight: number
    touch: number
    purity: number
    jobcardId?: number | null
    goldsmithId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReceivedsectionUpdateManyMutationInput = {
    weight?: FloatFieldUpdateOperationsInput | number
    touch?: FloatFieldUpdateOperationsInput | number
    purity?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReceivedsectionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    touch?: FloatFieldUpdateOperationsInput | number
    purity?: FloatFieldUpdateOperationsInput | number
    jobcardId?: NullableIntFieldUpdateOperationsInput | number | null
    goldsmithId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BalancesCreateInput = {
    totalDeliveries: number
    totalItemWeight: number
    totalNetWeight: number
    totalPurity: number
    totalReceivedWeight: number
    totalReceivedTouch: number
    totalReceivedPurity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    goldsmith: GoldsmithCreateNestedOneWithoutSummariesInput
  }

  export type BalancesUncheckedCreateInput = {
    id?: number
    goldsmithId: number
    totalDeliveries: number
    totalItemWeight: number
    totalNetWeight: number
    totalPurity: number
    totalReceivedWeight: number
    totalReceivedTouch: number
    totalReceivedPurity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BalancesUpdateInput = {
    totalDeliveries?: IntFieldUpdateOperationsInput | number
    totalItemWeight?: FloatFieldUpdateOperationsInput | number
    totalNetWeight?: FloatFieldUpdateOperationsInput | number
    totalPurity?: FloatFieldUpdateOperationsInput | number
    totalReceivedWeight?: FloatFieldUpdateOperationsInput | number
    totalReceivedTouch?: FloatFieldUpdateOperationsInput | number
    totalReceivedPurity?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    goldsmith?: GoldsmithUpdateOneRequiredWithoutSummariesNestedInput
  }

  export type BalancesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    goldsmithId?: IntFieldUpdateOperationsInput | number
    totalDeliveries?: IntFieldUpdateOperationsInput | number
    totalItemWeight?: FloatFieldUpdateOperationsInput | number
    totalNetWeight?: FloatFieldUpdateOperationsInput | number
    totalPurity?: FloatFieldUpdateOperationsInput | number
    totalReceivedWeight?: FloatFieldUpdateOperationsInput | number
    totalReceivedTouch?: FloatFieldUpdateOperationsInput | number
    totalReceivedPurity?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BalancesCreateManyInput = {
    id?: number
    goldsmithId: number
    totalDeliveries: number
    totalItemWeight: number
    totalNetWeight: number
    totalPurity: number
    totalReceivedWeight: number
    totalReceivedTouch: number
    totalReceivedPurity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BalancesUpdateManyMutationInput = {
    totalDeliveries?: IntFieldUpdateOperationsInput | number
    totalItemWeight?: FloatFieldUpdateOperationsInput | number
    totalNetWeight?: FloatFieldUpdateOperationsInput | number
    totalPurity?: FloatFieldUpdateOperationsInput | number
    totalReceivedWeight?: FloatFieldUpdateOperationsInput | number
    totalReceivedTouch?: FloatFieldUpdateOperationsInput | number
    totalReceivedPurity?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BalancesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    goldsmithId?: IntFieldUpdateOperationsInput | number
    totalDeliveries?: IntFieldUpdateOperationsInput | number
    totalItemWeight?: FloatFieldUpdateOperationsInput | number
    totalNetWeight?: FloatFieldUpdateOperationsInput | number
    totalPurity?: FloatFieldUpdateOperationsInput | number
    totalReceivedWeight?: FloatFieldUpdateOperationsInput | number
    totalReceivedTouch?: FloatFieldUpdateOperationsInput | number
    totalReceivedPurity?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RepairCreateInput = {
    givenWeights: JsonNullValueInput | InputJsonValue
    totalGiven: number
    itemWeights: JsonNullValueInput | InputJsonValue
    totalItem: number
    stone: number
    wastageType: string
    touch: number
    netWeight: number
    createdAt?: Date | string
    goldsmith: GoldsmithCreateNestedOneWithoutRepairsInput
  }

  export type RepairUncheckedCreateInput = {
    id?: number
    goldsmithId: number
    givenWeights: JsonNullValueInput | InputJsonValue
    totalGiven: number
    itemWeights: JsonNullValueInput | InputJsonValue
    totalItem: number
    stone: number
    wastageType: string
    touch: number
    netWeight: number
    createdAt?: Date | string
  }

  export type RepairUpdateInput = {
    givenWeights?: JsonNullValueInput | InputJsonValue
    totalGiven?: FloatFieldUpdateOperationsInput | number
    itemWeights?: JsonNullValueInput | InputJsonValue
    totalItem?: FloatFieldUpdateOperationsInput | number
    stone?: FloatFieldUpdateOperationsInput | number
    wastageType?: StringFieldUpdateOperationsInput | string
    touch?: FloatFieldUpdateOperationsInput | number
    netWeight?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    goldsmith?: GoldsmithUpdateOneRequiredWithoutRepairsNestedInput
  }

  export type RepairUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    goldsmithId?: IntFieldUpdateOperationsInput | number
    givenWeights?: JsonNullValueInput | InputJsonValue
    totalGiven?: FloatFieldUpdateOperationsInput | number
    itemWeights?: JsonNullValueInput | InputJsonValue
    totalItem?: FloatFieldUpdateOperationsInput | number
    stone?: FloatFieldUpdateOperationsInput | number
    wastageType?: StringFieldUpdateOperationsInput | string
    touch?: FloatFieldUpdateOperationsInput | number
    netWeight?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RepairCreateManyInput = {
    id?: number
    goldsmithId: number
    givenWeights: JsonNullValueInput | InputJsonValue
    totalGiven: number
    itemWeights: JsonNullValueInput | InputJsonValue
    totalItem: number
    stone: number
    wastageType: string
    touch: number
    netWeight: number
    createdAt?: Date | string
  }

  export type RepairUpdateManyMutationInput = {
    givenWeights?: JsonNullValueInput | InputJsonValue
    totalGiven?: FloatFieldUpdateOperationsInput | number
    itemWeights?: JsonNullValueInput | InputJsonValue
    totalItem?: FloatFieldUpdateOperationsInput | number
    stone?: FloatFieldUpdateOperationsInput | number
    wastageType?: StringFieldUpdateOperationsInput | string
    touch?: FloatFieldUpdateOperationsInput | number
    netWeight?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RepairUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    goldsmithId?: IntFieldUpdateOperationsInput | number
    givenWeights?: JsonNullValueInput | InputJsonValue
    totalGiven?: FloatFieldUpdateOperationsInput | number
    itemWeights?: JsonNullValueInput | InputJsonValue
    totalItem?: FloatFieldUpdateOperationsInput | number
    stone?: FloatFieldUpdateOperationsInput | number
    wastageType?: StringFieldUpdateOperationsInput | string
    touch?: FloatFieldUpdateOperationsInput | number
    netWeight?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserOrderByRelevanceInput = {
    fields: UserOrderByRelevanceFieldEnum | UserOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type TransactionListRelationFilter = {
    every?: TransactionWhereInput
    some?: TransactionWhereInput
    none?: TransactionWhereInput
  }

  export type Customer_orderListRelationFilter = {
    every?: customer_orderWhereInput
    some?: customer_orderWhereInput
    none?: customer_orderWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type TransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type customer_orderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerOrderByRelevanceInput = {
    fields: CustomerOrderByRelevanceFieldEnum | CustomerOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CustomerCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
  }

  export type CustomerAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CustomerMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
  }

  export type CustomerMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
  }

  export type CustomerSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type MasterItemOrderByRelevanceInput = {
    fields: MasterItemOrderByRelevanceFieldEnum | MasterItemOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type MasterItemCountOrderByAggregateInput = {
    id?: SortOrder
    itemName?: SortOrder
    createdAt?: SortOrder
  }

  export type MasterItemAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type MasterItemMaxOrderByAggregateInput = {
    id?: SortOrder
    itemName?: SortOrder
    createdAt?: SortOrder
  }

  export type MasterItemMinOrderByAggregateInput = {
    id?: SortOrder
    itemName?: SortOrder
    createdAt?: SortOrder
  }

  export type MasterItemSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type MasterTouchCountOrderByAggregateInput = {
    id?: SortOrder
    touch?: SortOrder
    createdAt?: SortOrder
  }

  export type MasterTouchAvgOrderByAggregateInput = {
    id?: SortOrder
    touch?: SortOrder
  }

  export type MasterTouchMaxOrderByAggregateInput = {
    id?: SortOrder
    touch?: SortOrder
    createdAt?: SortOrder
  }

  export type MasterTouchMinOrderByAggregateInput = {
    id?: SortOrder
    touch?: SortOrder
    createdAt?: SortOrder
  }

  export type MasterTouchSumOrderByAggregateInput = {
    id?: SortOrder
    touch?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type JewelStockOrderByRelevanceInput = {
    fields: JewelStockOrderByRelevanceFieldEnum | JewelStockOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type JewelStockCountOrderByAggregateInput = {
    id?: SortOrder
    jewelName?: SortOrder
    weight?: SortOrder
    stoneWeight?: SortOrder
    finalWeight?: SortOrder
    touch?: SortOrder
    purityValue?: SortOrder
    createdAt?: SortOrder
  }

  export type JewelStockAvgOrderByAggregateInput = {
    id?: SortOrder
    weight?: SortOrder
    stoneWeight?: SortOrder
    finalWeight?: SortOrder
    touch?: SortOrder
    purityValue?: SortOrder
  }

  export type JewelStockMaxOrderByAggregateInput = {
    id?: SortOrder
    jewelName?: SortOrder
    weight?: SortOrder
    stoneWeight?: SortOrder
    finalWeight?: SortOrder
    touch?: SortOrder
    purityValue?: SortOrder
    createdAt?: SortOrder
  }

  export type JewelStockMinOrderByAggregateInput = {
    id?: SortOrder
    jewelName?: SortOrder
    weight?: SortOrder
    stoneWeight?: SortOrder
    finalWeight?: SortOrder
    touch?: SortOrder
    purityValue?: SortOrder
    createdAt?: SortOrder
  }

  export type JewelStockSumOrderByAggregateInput = {
    id?: SortOrder
    weight?: SortOrder
    stoneWeight?: SortOrder
    finalWeight?: SortOrder
    touch?: SortOrder
    purityValue?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type CustomerScalarRelationFilter = {
    is?: CustomerWhereInput
    isNot?: CustomerWhereInput
  }

  export type TransactionOrderByRelevanceInput = {
    fields: TransactionOrderByRelevanceFieldEnum | TransactionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type TransactionCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    type?: SortOrder
    value?: SortOrder
    goldRate?: SortOrder
    purity?: SortOrder
    touch?: SortOrder
    customerId?: SortOrder
    createdAt?: SortOrder
  }

  export type TransactionAvgOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    goldRate?: SortOrder
    purity?: SortOrder
    touch?: SortOrder
    customerId?: SortOrder
  }

  export type TransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    type?: SortOrder
    value?: SortOrder
    goldRate?: SortOrder
    purity?: SortOrder
    touch?: SortOrder
    customerId?: SortOrder
    createdAt?: SortOrder
  }

  export type TransactionMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    type?: SortOrder
    value?: SortOrder
    goldRate?: SortOrder
    purity?: SortOrder
    touch?: SortOrder
    customerId?: SortOrder
    createdAt?: SortOrder
  }

  export type TransactionSumOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    goldRate?: SortOrder
    purity?: SortOrder
    touch?: SortOrder
    customerId?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EntryOrderByRelevanceInput = {
    fields: EntryOrderByRelevanceFieldEnum | EntryOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type EntryCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    type?: SortOrder
    cashAmount?: SortOrder
    goldValue?: SortOrder
    touch?: SortOrder
    purity?: SortOrder
    goldRate?: SortOrder
    createdAt?: SortOrder
  }

  export type EntryAvgOrderByAggregateInput = {
    id?: SortOrder
    cashAmount?: SortOrder
    goldValue?: SortOrder
    touch?: SortOrder
    purity?: SortOrder
    goldRate?: SortOrder
  }

  export type EntryMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    type?: SortOrder
    cashAmount?: SortOrder
    goldValue?: SortOrder
    touch?: SortOrder
    purity?: SortOrder
    goldRate?: SortOrder
    createdAt?: SortOrder
  }

  export type EntryMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    type?: SortOrder
    cashAmount?: SortOrder
    goldValue?: SortOrder
    touch?: SortOrder
    purity?: SortOrder
    goldRate?: SortOrder
    createdAt?: SortOrder
  }

  export type EntrySumOrderByAggregateInput = {
    id?: SortOrder
    cashAmount?: SortOrder
    goldValue?: SortOrder
    touch?: SortOrder
    purity?: SortOrder
    goldRate?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type Product_multiple_imagesListRelationFilter = {
    every?: product_multiple_imagesWhereInput
    some?: product_multiple_imagesWhereInput
    none?: product_multiple_imagesWhereInput
  }

  export type product_multiple_imagesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type customer_orderOrderByRelevanceInput = {
    fields: customer_orderOrderByRelevanceFieldEnum | customer_orderOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type customer_orderCountOrderByAggregateInput = {
    id?: SortOrder
    customer_id?: SortOrder
    order_group_id?: SortOrder
    item_name?: SortOrder
    description?: SortOrder
    weight?: SortOrder
    image?: SortOrder
    due_date?: SortOrder
    status?: SortOrder
    worker_name?: SortOrder
    created_at?: SortOrder
    updatedAt?: SortOrder
  }

  export type customer_orderAvgOrderByAggregateInput = {
    id?: SortOrder
    customer_id?: SortOrder
    order_group_id?: SortOrder
    weight?: SortOrder
  }

  export type customer_orderMaxOrderByAggregateInput = {
    id?: SortOrder
    customer_id?: SortOrder
    order_group_id?: SortOrder
    item_name?: SortOrder
    description?: SortOrder
    weight?: SortOrder
    image?: SortOrder
    due_date?: SortOrder
    status?: SortOrder
    worker_name?: SortOrder
    created_at?: SortOrder
    updatedAt?: SortOrder
  }

  export type customer_orderMinOrderByAggregateInput = {
    id?: SortOrder
    customer_id?: SortOrder
    order_group_id?: SortOrder
    item_name?: SortOrder
    description?: SortOrder
    weight?: SortOrder
    image?: SortOrder
    due_date?: SortOrder
    status?: SortOrder
    worker_name?: SortOrder
    created_at?: SortOrder
    updatedAt?: SortOrder
  }

  export type customer_orderSumOrderByAggregateInput = {
    id?: SortOrder
    customer_id?: SortOrder
    order_group_id?: SortOrder
    weight?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type Customer_orderScalarRelationFilter = {
    is?: customer_orderWhereInput
    isNot?: customer_orderWhereInput
  }

  export type product_multiple_imagesOrderByRelevanceInput = {
    fields: product_multiple_imagesOrderByRelevanceFieldEnum | product_multiple_imagesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type product_multiple_imagesCountOrderByAggregateInput = {
    id?: SortOrder
    customer_order_id?: SortOrder
    filename?: SortOrder
  }

  export type product_multiple_imagesAvgOrderByAggregateInput = {
    id?: SortOrder
    customer_order_id?: SortOrder
  }

  export type product_multiple_imagesMaxOrderByAggregateInput = {
    id?: SortOrder
    customer_order_id?: SortOrder
    filename?: SortOrder
  }

  export type product_multiple_imagesMinOrderByAggregateInput = {
    id?: SortOrder
    customer_order_id?: SortOrder
    filename?: SortOrder
  }

  export type product_multiple_imagesSumOrderByAggregateInput = {
    id?: SortOrder
    customer_order_id?: SortOrder
  }

  export type BullionPurchaseListRelationFilter = {
    every?: BullionPurchaseWhereInput
    some?: BullionPurchaseWhereInput
    none?: BullionPurchaseWhereInput
  }

  export type BullionPurchaseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MasterBullionOrderByRelevanceInput = {
    fields: MasterBullionOrderByRelevanceFieldEnum | MasterBullionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type MasterBullionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    address?: SortOrder
  }

  export type MasterBullionAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type MasterBullionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    address?: SortOrder
  }

  export type MasterBullionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    address?: SortOrder
  }

  export type MasterBullionSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type MasterBullionScalarRelationFilter = {
    is?: MasterBullionWhereInput
    isNot?: MasterBullionWhereInput
  }

  export type GivenDetailListRelationFilter = {
    every?: GivenDetailWhereInput
    some?: GivenDetailWhereInput
    none?: GivenDetailWhereInput
  }

  export type GivenDetailOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BullionPurchaseCountOrderByAggregateInput = {
    id?: SortOrder
    bullionId?: SortOrder
    grams?: SortOrder
    touch?: SortOrder
    purity?: SortOrder
    rate?: SortOrder
    amount?: SortOrder
    balance?: SortOrder
    createdAt?: SortOrder
  }

  export type BullionPurchaseAvgOrderByAggregateInput = {
    id?: SortOrder
    bullionId?: SortOrder
    grams?: SortOrder
    touch?: SortOrder
    purity?: SortOrder
    rate?: SortOrder
    amount?: SortOrder
    balance?: SortOrder
  }

  export type BullionPurchaseMaxOrderByAggregateInput = {
    id?: SortOrder
    bullionId?: SortOrder
    grams?: SortOrder
    touch?: SortOrder
    purity?: SortOrder
    rate?: SortOrder
    amount?: SortOrder
    balance?: SortOrder
    createdAt?: SortOrder
  }

  export type BullionPurchaseMinOrderByAggregateInput = {
    id?: SortOrder
    bullionId?: SortOrder
    grams?: SortOrder
    touch?: SortOrder
    purity?: SortOrder
    rate?: SortOrder
    amount?: SortOrder
    balance?: SortOrder
    createdAt?: SortOrder
  }

  export type BullionPurchaseSumOrderByAggregateInput = {
    id?: SortOrder
    bullionId?: SortOrder
    grams?: SortOrder
    touch?: SortOrder
    purity?: SortOrder
    rate?: SortOrder
    amount?: SortOrder
    balance?: SortOrder
  }

  export type BullionPurchaseScalarRelationFilter = {
    is?: BullionPurchaseWhereInput
    isNot?: BullionPurchaseWhereInput
  }

  export type GivenDetailCountOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    grams?: SortOrder
    touch?: SortOrder
    purity?: SortOrder
    purchaseId?: SortOrder
  }

  export type GivenDetailAvgOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    grams?: SortOrder
    touch?: SortOrder
    purity?: SortOrder
    purchaseId?: SortOrder
  }

  export type GivenDetailMaxOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    grams?: SortOrder
    touch?: SortOrder
    purity?: SortOrder
    purchaseId?: SortOrder
  }

  export type GivenDetailMinOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    grams?: SortOrder
    touch?: SortOrder
    purity?: SortOrder
    purchaseId?: SortOrder
  }

  export type GivenDetailSumOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    grams?: SortOrder
    touch?: SortOrder
    purity?: SortOrder
    purchaseId?: SortOrder
  }

  export type JobcardListRelationFilter = {
    every?: JobcardWhereInput
    some?: JobcardWhereInput
    none?: JobcardWhereInput
  }

  export type TotalListRelationFilter = {
    every?: TotalWhereInput
    some?: TotalWhereInput
    none?: TotalWhereInput
  }

  export type GivenGoldListRelationFilter = {
    every?: givenGoldWhereInput
    some?: givenGoldWhereInput
    none?: givenGoldWhereInput
  }

  export type ItemDeliveryListRelationFilter = {
    every?: itemDeliveryWhereInput
    some?: itemDeliveryWhereInput
    none?: itemDeliveryWhereInput
  }

  export type ReceivedsectionListRelationFilter = {
    every?: ReceivedsectionWhereInput
    some?: ReceivedsectionWhereInput
    none?: ReceivedsectionWhereInput
  }

  export type RepairListRelationFilter = {
    every?: RepairWhereInput
    some?: RepairWhereInput
    none?: RepairWhereInput
  }

  export type BalancesListRelationFilter = {
    every?: BalancesWhereInput
    some?: BalancesWhereInput
    none?: BalancesWhereInput
  }

  export type JobcardOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TotalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type givenGoldOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type itemDeliveryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReceivedsectionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RepairOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BalancesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GoldsmithOrderByRelevanceInput = {
    fields: GoldsmithOrderByRelevanceFieldEnum | GoldsmithOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type GoldsmithCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GoldsmithAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type GoldsmithMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GoldsmithMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GoldsmithSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type GoldsmithScalarRelationFilter = {
    is?: GoldsmithWhereInput
    isNot?: GoldsmithWhereInput
  }

  export type JobcardOrderByRelevanceInput = {
    fields: JobcardOrderByRelevanceFieldEnum | JobcardOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type JobcardCountOrderByAggregateInput = {
    id?: SortOrder
    goldsmithId?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JobcardAvgOrderByAggregateInput = {
    id?: SortOrder
    goldsmithId?: SortOrder
  }

  export type JobcardMaxOrderByAggregateInput = {
    id?: SortOrder
    goldsmithId?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JobcardMinOrderByAggregateInput = {
    id?: SortOrder
    goldsmithId?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JobcardSumOrderByAggregateInput = {
    id?: SortOrder
    goldsmithId?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type GoldsmithNullableScalarRelationFilter = {
    is?: GoldsmithWhereInput | null
    isNot?: GoldsmithWhereInput | null
  }

  export type JobcardNullableScalarRelationFilter = {
    is?: JobcardWhereInput | null
    isNot?: JobcardWhereInput | null
  }

  export type givenGoldCountOrderByAggregateInput = {
    id?: SortOrder
    goldsmithId?: SortOrder
    jobcardId?: SortOrder
    weight?: SortOrder
    touch?: SortOrder
    purity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type givenGoldAvgOrderByAggregateInput = {
    id?: SortOrder
    goldsmithId?: SortOrder
    jobcardId?: SortOrder
    weight?: SortOrder
    touch?: SortOrder
    purity?: SortOrder
  }

  export type givenGoldMaxOrderByAggregateInput = {
    id?: SortOrder
    goldsmithId?: SortOrder
    jobcardId?: SortOrder
    weight?: SortOrder
    touch?: SortOrder
    purity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type givenGoldMinOrderByAggregateInput = {
    id?: SortOrder
    goldsmithId?: SortOrder
    jobcardId?: SortOrder
    weight?: SortOrder
    touch?: SortOrder
    purity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type givenGoldSumOrderByAggregateInput = {
    id?: SortOrder
    goldsmithId?: SortOrder
    jobcardId?: SortOrder
    weight?: SortOrder
    touch?: SortOrder
    purity?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type TotalCountOrderByAggregateInput = {
    id?: SortOrder
    goldsmithId?: SortOrder
    totalPurity?: SortOrder
    openingBalance?: SortOrder
    totalBalance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TotalAvgOrderByAggregateInput = {
    id?: SortOrder
    goldsmithId?: SortOrder
    totalPurity?: SortOrder
    openingBalance?: SortOrder
    totalBalance?: SortOrder
  }

  export type TotalMaxOrderByAggregateInput = {
    id?: SortOrder
    goldsmithId?: SortOrder
    totalPurity?: SortOrder
    openingBalance?: SortOrder
    totalBalance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TotalMinOrderByAggregateInput = {
    id?: SortOrder
    goldsmithId?: SortOrder
    totalPurity?: SortOrder
    openingBalance?: SortOrder
    totalBalance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TotalSumOrderByAggregateInput = {
    id?: SortOrder
    goldsmithId?: SortOrder
    totalPurity?: SortOrder
    openingBalance?: SortOrder
    totalBalance?: SortOrder
  }

  export type EnumWastageTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.WastageType | EnumWastageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WastageType[]
    notIn?: $Enums.WastageType[]
    not?: NestedEnumWastageTypeFilter<$PrismaModel> | $Enums.WastageType
  }

  export type itemDeliveryOrderByRelevanceInput = {
    fields: itemDeliveryOrderByRelevanceFieldEnum | itemDeliveryOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type itemDeliveryCountOrderByAggregateInput = {
    id?: SortOrder
    itemName?: SortOrder
    itemWeight?: SortOrder
    type?: SortOrder
    stoneWeight?: SortOrder
    netWeight?: SortOrder
    wastageType?: SortOrder
    wastageValue?: SortOrder
    finalPurity?: SortOrder
    goldsmithId?: SortOrder
    jobcardId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type itemDeliveryAvgOrderByAggregateInput = {
    id?: SortOrder
    itemWeight?: SortOrder
    stoneWeight?: SortOrder
    netWeight?: SortOrder
    wastageValue?: SortOrder
    finalPurity?: SortOrder
    goldsmithId?: SortOrder
    jobcardId?: SortOrder
  }

  export type itemDeliveryMaxOrderByAggregateInput = {
    id?: SortOrder
    itemName?: SortOrder
    itemWeight?: SortOrder
    type?: SortOrder
    stoneWeight?: SortOrder
    netWeight?: SortOrder
    wastageType?: SortOrder
    wastageValue?: SortOrder
    finalPurity?: SortOrder
    goldsmithId?: SortOrder
    jobcardId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type itemDeliveryMinOrderByAggregateInput = {
    id?: SortOrder
    itemName?: SortOrder
    itemWeight?: SortOrder
    type?: SortOrder
    stoneWeight?: SortOrder
    netWeight?: SortOrder
    wastageType?: SortOrder
    wastageValue?: SortOrder
    finalPurity?: SortOrder
    goldsmithId?: SortOrder
    jobcardId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type itemDeliverySumOrderByAggregateInput = {
    id?: SortOrder
    itemWeight?: SortOrder
    stoneWeight?: SortOrder
    netWeight?: SortOrder
    wastageValue?: SortOrder
    finalPurity?: SortOrder
    goldsmithId?: SortOrder
    jobcardId?: SortOrder
  }

  export type EnumWastageTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WastageType | EnumWastageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WastageType[]
    notIn?: $Enums.WastageType[]
    not?: NestedEnumWastageTypeWithAggregatesFilter<$PrismaModel> | $Enums.WastageType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWastageTypeFilter<$PrismaModel>
    _max?: NestedEnumWastageTypeFilter<$PrismaModel>
  }

  export type ReceivedsectionCountOrderByAggregateInput = {
    id?: SortOrder
    weight?: SortOrder
    touch?: SortOrder
    purity?: SortOrder
    jobcardId?: SortOrder
    goldsmithId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReceivedsectionAvgOrderByAggregateInput = {
    id?: SortOrder
    weight?: SortOrder
    touch?: SortOrder
    purity?: SortOrder
    jobcardId?: SortOrder
    goldsmithId?: SortOrder
  }

  export type ReceivedsectionMaxOrderByAggregateInput = {
    id?: SortOrder
    weight?: SortOrder
    touch?: SortOrder
    purity?: SortOrder
    jobcardId?: SortOrder
    goldsmithId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReceivedsectionMinOrderByAggregateInput = {
    id?: SortOrder
    weight?: SortOrder
    touch?: SortOrder
    purity?: SortOrder
    jobcardId?: SortOrder
    goldsmithId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReceivedsectionSumOrderByAggregateInput = {
    id?: SortOrder
    weight?: SortOrder
    touch?: SortOrder
    purity?: SortOrder
    jobcardId?: SortOrder
    goldsmithId?: SortOrder
  }

  export type BalancesCountOrderByAggregateInput = {
    id?: SortOrder
    goldsmithId?: SortOrder
    totalDeliveries?: SortOrder
    totalItemWeight?: SortOrder
    totalNetWeight?: SortOrder
    totalPurity?: SortOrder
    totalReceivedWeight?: SortOrder
    totalReceivedTouch?: SortOrder
    totalReceivedPurity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BalancesAvgOrderByAggregateInput = {
    id?: SortOrder
    goldsmithId?: SortOrder
    totalDeliveries?: SortOrder
    totalItemWeight?: SortOrder
    totalNetWeight?: SortOrder
    totalPurity?: SortOrder
    totalReceivedWeight?: SortOrder
    totalReceivedTouch?: SortOrder
    totalReceivedPurity?: SortOrder
  }

  export type BalancesMaxOrderByAggregateInput = {
    id?: SortOrder
    goldsmithId?: SortOrder
    totalDeliveries?: SortOrder
    totalItemWeight?: SortOrder
    totalNetWeight?: SortOrder
    totalPurity?: SortOrder
    totalReceivedWeight?: SortOrder
    totalReceivedTouch?: SortOrder
    totalReceivedPurity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BalancesMinOrderByAggregateInput = {
    id?: SortOrder
    goldsmithId?: SortOrder
    totalDeliveries?: SortOrder
    totalItemWeight?: SortOrder
    totalNetWeight?: SortOrder
    totalPurity?: SortOrder
    totalReceivedWeight?: SortOrder
    totalReceivedTouch?: SortOrder
    totalReceivedPurity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BalancesSumOrderByAggregateInput = {
    id?: SortOrder
    goldsmithId?: SortOrder
    totalDeliveries?: SortOrder
    totalItemWeight?: SortOrder
    totalNetWeight?: SortOrder
    totalPurity?: SortOrder
    totalReceivedWeight?: SortOrder
    totalReceivedTouch?: SortOrder
    totalReceivedPurity?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type RepairOrderByRelevanceInput = {
    fields: RepairOrderByRelevanceFieldEnum | RepairOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type RepairCountOrderByAggregateInput = {
    id?: SortOrder
    goldsmithId?: SortOrder
    givenWeights?: SortOrder
    totalGiven?: SortOrder
    itemWeights?: SortOrder
    totalItem?: SortOrder
    stone?: SortOrder
    wastageType?: SortOrder
    touch?: SortOrder
    netWeight?: SortOrder
    createdAt?: SortOrder
  }

  export type RepairAvgOrderByAggregateInput = {
    id?: SortOrder
    goldsmithId?: SortOrder
    totalGiven?: SortOrder
    totalItem?: SortOrder
    stone?: SortOrder
    touch?: SortOrder
    netWeight?: SortOrder
  }

  export type RepairMaxOrderByAggregateInput = {
    id?: SortOrder
    goldsmithId?: SortOrder
    totalGiven?: SortOrder
    totalItem?: SortOrder
    stone?: SortOrder
    wastageType?: SortOrder
    touch?: SortOrder
    netWeight?: SortOrder
    createdAt?: SortOrder
  }

  export type RepairMinOrderByAggregateInput = {
    id?: SortOrder
    goldsmithId?: SortOrder
    totalGiven?: SortOrder
    totalItem?: SortOrder
    stone?: SortOrder
    wastageType?: SortOrder
    touch?: SortOrder
    netWeight?: SortOrder
    createdAt?: SortOrder
  }

  export type RepairSumOrderByAggregateInput = {
    id?: SortOrder
    goldsmithId?: SortOrder
    totalGiven?: SortOrder
    totalItem?: SortOrder
    stone?: SortOrder
    touch?: SortOrder
    netWeight?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type TransactionCreateNestedManyWithoutCustomerInput = {
    create?: XOR<TransactionCreateWithoutCustomerInput, TransactionUncheckedCreateWithoutCustomerInput> | TransactionCreateWithoutCustomerInput[] | TransactionUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCustomerInput | TransactionCreateOrConnectWithoutCustomerInput[]
    createMany?: TransactionCreateManyCustomerInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type customer_orderCreateNestedManyWithoutCustomersInput = {
    create?: XOR<customer_orderCreateWithoutCustomersInput, customer_orderUncheckedCreateWithoutCustomersInput> | customer_orderCreateWithoutCustomersInput[] | customer_orderUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: customer_orderCreateOrConnectWithoutCustomersInput | customer_orderCreateOrConnectWithoutCustomersInput[]
    createMany?: customer_orderCreateManyCustomersInputEnvelope
    connect?: customer_orderWhereUniqueInput | customer_orderWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<TransactionCreateWithoutCustomerInput, TransactionUncheckedCreateWithoutCustomerInput> | TransactionCreateWithoutCustomerInput[] | TransactionUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCustomerInput | TransactionCreateOrConnectWithoutCustomerInput[]
    createMany?: TransactionCreateManyCustomerInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type customer_orderUncheckedCreateNestedManyWithoutCustomersInput = {
    create?: XOR<customer_orderCreateWithoutCustomersInput, customer_orderUncheckedCreateWithoutCustomersInput> | customer_orderCreateWithoutCustomersInput[] | customer_orderUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: customer_orderCreateOrConnectWithoutCustomersInput | customer_orderCreateOrConnectWithoutCustomersInput[]
    createMany?: customer_orderCreateManyCustomersInputEnvelope
    connect?: customer_orderWhereUniqueInput | customer_orderWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type TransactionUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<TransactionCreateWithoutCustomerInput, TransactionUncheckedCreateWithoutCustomerInput> | TransactionCreateWithoutCustomerInput[] | TransactionUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCustomerInput | TransactionCreateOrConnectWithoutCustomerInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutCustomerInput | TransactionUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: TransactionCreateManyCustomerInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutCustomerInput | TransactionUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutCustomerInput | TransactionUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type customer_orderUpdateManyWithoutCustomersNestedInput = {
    create?: XOR<customer_orderCreateWithoutCustomersInput, customer_orderUncheckedCreateWithoutCustomersInput> | customer_orderCreateWithoutCustomersInput[] | customer_orderUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: customer_orderCreateOrConnectWithoutCustomersInput | customer_orderCreateOrConnectWithoutCustomersInput[]
    upsert?: customer_orderUpsertWithWhereUniqueWithoutCustomersInput | customer_orderUpsertWithWhereUniqueWithoutCustomersInput[]
    createMany?: customer_orderCreateManyCustomersInputEnvelope
    set?: customer_orderWhereUniqueInput | customer_orderWhereUniqueInput[]
    disconnect?: customer_orderWhereUniqueInput | customer_orderWhereUniqueInput[]
    delete?: customer_orderWhereUniqueInput | customer_orderWhereUniqueInput[]
    connect?: customer_orderWhereUniqueInput | customer_orderWhereUniqueInput[]
    update?: customer_orderUpdateWithWhereUniqueWithoutCustomersInput | customer_orderUpdateWithWhereUniqueWithoutCustomersInput[]
    updateMany?: customer_orderUpdateManyWithWhereWithoutCustomersInput | customer_orderUpdateManyWithWhereWithoutCustomersInput[]
    deleteMany?: customer_orderScalarWhereInput | customer_orderScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<TransactionCreateWithoutCustomerInput, TransactionUncheckedCreateWithoutCustomerInput> | TransactionCreateWithoutCustomerInput[] | TransactionUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCustomerInput | TransactionCreateOrConnectWithoutCustomerInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutCustomerInput | TransactionUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: TransactionCreateManyCustomerInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutCustomerInput | TransactionUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutCustomerInput | TransactionUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type customer_orderUncheckedUpdateManyWithoutCustomersNestedInput = {
    create?: XOR<customer_orderCreateWithoutCustomersInput, customer_orderUncheckedCreateWithoutCustomersInput> | customer_orderCreateWithoutCustomersInput[] | customer_orderUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: customer_orderCreateOrConnectWithoutCustomersInput | customer_orderCreateOrConnectWithoutCustomersInput[]
    upsert?: customer_orderUpsertWithWhereUniqueWithoutCustomersInput | customer_orderUpsertWithWhereUniqueWithoutCustomersInput[]
    createMany?: customer_orderCreateManyCustomersInputEnvelope
    set?: customer_orderWhereUniqueInput | customer_orderWhereUniqueInput[]
    disconnect?: customer_orderWhereUniqueInput | customer_orderWhereUniqueInput[]
    delete?: customer_orderWhereUniqueInput | customer_orderWhereUniqueInput[]
    connect?: customer_orderWhereUniqueInput | customer_orderWhereUniqueInput[]
    update?: customer_orderUpdateWithWhereUniqueWithoutCustomersInput | customer_orderUpdateWithWhereUniqueWithoutCustomersInput[]
    updateMany?: customer_orderUpdateManyWithWhereWithoutCustomersInput | customer_orderUpdateManyWithWhereWithoutCustomersInput[]
    deleteMany?: customer_orderScalarWhereInput | customer_orderScalarWhereInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CustomerCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<CustomerCreateWithoutTransactionsInput, CustomerUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutTransactionsInput
    connect?: CustomerWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CustomerUpdateOneRequiredWithoutTransactionsNestedInput = {
    create?: XOR<CustomerCreateWithoutTransactionsInput, CustomerUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutTransactionsInput
    upsert?: CustomerUpsertWithoutTransactionsInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutTransactionsInput, CustomerUpdateWithoutTransactionsInput>, CustomerUncheckedUpdateWithoutTransactionsInput>
  }

  export type CustomerCreateNestedOneWithoutCustomerOrdersInput = {
    create?: XOR<CustomerCreateWithoutCustomerOrdersInput, CustomerUncheckedCreateWithoutCustomerOrdersInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutCustomerOrdersInput
    connect?: CustomerWhereUniqueInput
  }

  export type product_multiple_imagesCreateNestedManyWithoutCustomerOrderDetailsInput = {
    create?: XOR<product_multiple_imagesCreateWithoutCustomerOrderDetailsInput, product_multiple_imagesUncheckedCreateWithoutCustomerOrderDetailsInput> | product_multiple_imagesCreateWithoutCustomerOrderDetailsInput[] | product_multiple_imagesUncheckedCreateWithoutCustomerOrderDetailsInput[]
    connectOrCreate?: product_multiple_imagesCreateOrConnectWithoutCustomerOrderDetailsInput | product_multiple_imagesCreateOrConnectWithoutCustomerOrderDetailsInput[]
    createMany?: product_multiple_imagesCreateManyCustomerOrderDetailsInputEnvelope
    connect?: product_multiple_imagesWhereUniqueInput | product_multiple_imagesWhereUniqueInput[]
  }

  export type product_multiple_imagesUncheckedCreateNestedManyWithoutCustomerOrderDetailsInput = {
    create?: XOR<product_multiple_imagesCreateWithoutCustomerOrderDetailsInput, product_multiple_imagesUncheckedCreateWithoutCustomerOrderDetailsInput> | product_multiple_imagesCreateWithoutCustomerOrderDetailsInput[] | product_multiple_imagesUncheckedCreateWithoutCustomerOrderDetailsInput[]
    connectOrCreate?: product_multiple_imagesCreateOrConnectWithoutCustomerOrderDetailsInput | product_multiple_imagesCreateOrConnectWithoutCustomerOrderDetailsInput[]
    createMany?: product_multiple_imagesCreateManyCustomerOrderDetailsInputEnvelope
    connect?: product_multiple_imagesWhereUniqueInput | product_multiple_imagesWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type CustomerUpdateOneRequiredWithoutCustomerOrdersNestedInput = {
    create?: XOR<CustomerCreateWithoutCustomerOrdersInput, CustomerUncheckedCreateWithoutCustomerOrdersInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutCustomerOrdersInput
    upsert?: CustomerUpsertWithoutCustomerOrdersInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutCustomerOrdersInput, CustomerUpdateWithoutCustomerOrdersInput>, CustomerUncheckedUpdateWithoutCustomerOrdersInput>
  }

  export type product_multiple_imagesUpdateManyWithoutCustomerOrderDetailsNestedInput = {
    create?: XOR<product_multiple_imagesCreateWithoutCustomerOrderDetailsInput, product_multiple_imagesUncheckedCreateWithoutCustomerOrderDetailsInput> | product_multiple_imagesCreateWithoutCustomerOrderDetailsInput[] | product_multiple_imagesUncheckedCreateWithoutCustomerOrderDetailsInput[]
    connectOrCreate?: product_multiple_imagesCreateOrConnectWithoutCustomerOrderDetailsInput | product_multiple_imagesCreateOrConnectWithoutCustomerOrderDetailsInput[]
    upsert?: product_multiple_imagesUpsertWithWhereUniqueWithoutCustomerOrderDetailsInput | product_multiple_imagesUpsertWithWhereUniqueWithoutCustomerOrderDetailsInput[]
    createMany?: product_multiple_imagesCreateManyCustomerOrderDetailsInputEnvelope
    set?: product_multiple_imagesWhereUniqueInput | product_multiple_imagesWhereUniqueInput[]
    disconnect?: product_multiple_imagesWhereUniqueInput | product_multiple_imagesWhereUniqueInput[]
    delete?: product_multiple_imagesWhereUniqueInput | product_multiple_imagesWhereUniqueInput[]
    connect?: product_multiple_imagesWhereUniqueInput | product_multiple_imagesWhereUniqueInput[]
    update?: product_multiple_imagesUpdateWithWhereUniqueWithoutCustomerOrderDetailsInput | product_multiple_imagesUpdateWithWhereUniqueWithoutCustomerOrderDetailsInput[]
    updateMany?: product_multiple_imagesUpdateManyWithWhereWithoutCustomerOrderDetailsInput | product_multiple_imagesUpdateManyWithWhereWithoutCustomerOrderDetailsInput[]
    deleteMany?: product_multiple_imagesScalarWhereInput | product_multiple_imagesScalarWhereInput[]
  }

  export type product_multiple_imagesUncheckedUpdateManyWithoutCustomerOrderDetailsNestedInput = {
    create?: XOR<product_multiple_imagesCreateWithoutCustomerOrderDetailsInput, product_multiple_imagesUncheckedCreateWithoutCustomerOrderDetailsInput> | product_multiple_imagesCreateWithoutCustomerOrderDetailsInput[] | product_multiple_imagesUncheckedCreateWithoutCustomerOrderDetailsInput[]
    connectOrCreate?: product_multiple_imagesCreateOrConnectWithoutCustomerOrderDetailsInput | product_multiple_imagesCreateOrConnectWithoutCustomerOrderDetailsInput[]
    upsert?: product_multiple_imagesUpsertWithWhereUniqueWithoutCustomerOrderDetailsInput | product_multiple_imagesUpsertWithWhereUniqueWithoutCustomerOrderDetailsInput[]
    createMany?: product_multiple_imagesCreateManyCustomerOrderDetailsInputEnvelope
    set?: product_multiple_imagesWhereUniqueInput | product_multiple_imagesWhereUniqueInput[]
    disconnect?: product_multiple_imagesWhereUniqueInput | product_multiple_imagesWhereUniqueInput[]
    delete?: product_multiple_imagesWhereUniqueInput | product_multiple_imagesWhereUniqueInput[]
    connect?: product_multiple_imagesWhereUniqueInput | product_multiple_imagesWhereUniqueInput[]
    update?: product_multiple_imagesUpdateWithWhereUniqueWithoutCustomerOrderDetailsInput | product_multiple_imagesUpdateWithWhereUniqueWithoutCustomerOrderDetailsInput[]
    updateMany?: product_multiple_imagesUpdateManyWithWhereWithoutCustomerOrderDetailsInput | product_multiple_imagesUpdateManyWithWhereWithoutCustomerOrderDetailsInput[]
    deleteMany?: product_multiple_imagesScalarWhereInput | product_multiple_imagesScalarWhereInput[]
  }

  export type customer_orderCreateNestedOneWithoutProductImagesInput = {
    create?: XOR<customer_orderCreateWithoutProductImagesInput, customer_orderUncheckedCreateWithoutProductImagesInput>
    connectOrCreate?: customer_orderCreateOrConnectWithoutProductImagesInput
    connect?: customer_orderWhereUniqueInput
  }

  export type customer_orderUpdateOneRequiredWithoutProductImagesNestedInput = {
    create?: XOR<customer_orderCreateWithoutProductImagesInput, customer_orderUncheckedCreateWithoutProductImagesInput>
    connectOrCreate?: customer_orderCreateOrConnectWithoutProductImagesInput
    upsert?: customer_orderUpsertWithoutProductImagesInput
    connect?: customer_orderWhereUniqueInput
    update?: XOR<XOR<customer_orderUpdateToOneWithWhereWithoutProductImagesInput, customer_orderUpdateWithoutProductImagesInput>, customer_orderUncheckedUpdateWithoutProductImagesInput>
  }

  export type BullionPurchaseCreateNestedManyWithoutBullionInput = {
    create?: XOR<BullionPurchaseCreateWithoutBullionInput, BullionPurchaseUncheckedCreateWithoutBullionInput> | BullionPurchaseCreateWithoutBullionInput[] | BullionPurchaseUncheckedCreateWithoutBullionInput[]
    connectOrCreate?: BullionPurchaseCreateOrConnectWithoutBullionInput | BullionPurchaseCreateOrConnectWithoutBullionInput[]
    createMany?: BullionPurchaseCreateManyBullionInputEnvelope
    connect?: BullionPurchaseWhereUniqueInput | BullionPurchaseWhereUniqueInput[]
  }

  export type BullionPurchaseUncheckedCreateNestedManyWithoutBullionInput = {
    create?: XOR<BullionPurchaseCreateWithoutBullionInput, BullionPurchaseUncheckedCreateWithoutBullionInput> | BullionPurchaseCreateWithoutBullionInput[] | BullionPurchaseUncheckedCreateWithoutBullionInput[]
    connectOrCreate?: BullionPurchaseCreateOrConnectWithoutBullionInput | BullionPurchaseCreateOrConnectWithoutBullionInput[]
    createMany?: BullionPurchaseCreateManyBullionInputEnvelope
    connect?: BullionPurchaseWhereUniqueInput | BullionPurchaseWhereUniqueInput[]
  }

  export type BullionPurchaseUpdateManyWithoutBullionNestedInput = {
    create?: XOR<BullionPurchaseCreateWithoutBullionInput, BullionPurchaseUncheckedCreateWithoutBullionInput> | BullionPurchaseCreateWithoutBullionInput[] | BullionPurchaseUncheckedCreateWithoutBullionInput[]
    connectOrCreate?: BullionPurchaseCreateOrConnectWithoutBullionInput | BullionPurchaseCreateOrConnectWithoutBullionInput[]
    upsert?: BullionPurchaseUpsertWithWhereUniqueWithoutBullionInput | BullionPurchaseUpsertWithWhereUniqueWithoutBullionInput[]
    createMany?: BullionPurchaseCreateManyBullionInputEnvelope
    set?: BullionPurchaseWhereUniqueInput | BullionPurchaseWhereUniqueInput[]
    disconnect?: BullionPurchaseWhereUniqueInput | BullionPurchaseWhereUniqueInput[]
    delete?: BullionPurchaseWhereUniqueInput | BullionPurchaseWhereUniqueInput[]
    connect?: BullionPurchaseWhereUniqueInput | BullionPurchaseWhereUniqueInput[]
    update?: BullionPurchaseUpdateWithWhereUniqueWithoutBullionInput | BullionPurchaseUpdateWithWhereUniqueWithoutBullionInput[]
    updateMany?: BullionPurchaseUpdateManyWithWhereWithoutBullionInput | BullionPurchaseUpdateManyWithWhereWithoutBullionInput[]
    deleteMany?: BullionPurchaseScalarWhereInput | BullionPurchaseScalarWhereInput[]
  }

  export type BullionPurchaseUncheckedUpdateManyWithoutBullionNestedInput = {
    create?: XOR<BullionPurchaseCreateWithoutBullionInput, BullionPurchaseUncheckedCreateWithoutBullionInput> | BullionPurchaseCreateWithoutBullionInput[] | BullionPurchaseUncheckedCreateWithoutBullionInput[]
    connectOrCreate?: BullionPurchaseCreateOrConnectWithoutBullionInput | BullionPurchaseCreateOrConnectWithoutBullionInput[]
    upsert?: BullionPurchaseUpsertWithWhereUniqueWithoutBullionInput | BullionPurchaseUpsertWithWhereUniqueWithoutBullionInput[]
    createMany?: BullionPurchaseCreateManyBullionInputEnvelope
    set?: BullionPurchaseWhereUniqueInput | BullionPurchaseWhereUniqueInput[]
    disconnect?: BullionPurchaseWhereUniqueInput | BullionPurchaseWhereUniqueInput[]
    delete?: BullionPurchaseWhereUniqueInput | BullionPurchaseWhereUniqueInput[]
    connect?: BullionPurchaseWhereUniqueInput | BullionPurchaseWhereUniqueInput[]
    update?: BullionPurchaseUpdateWithWhereUniqueWithoutBullionInput | BullionPurchaseUpdateWithWhereUniqueWithoutBullionInput[]
    updateMany?: BullionPurchaseUpdateManyWithWhereWithoutBullionInput | BullionPurchaseUpdateManyWithWhereWithoutBullionInput[]
    deleteMany?: BullionPurchaseScalarWhereInput | BullionPurchaseScalarWhereInput[]
  }

  export type MasterBullionCreateNestedOneWithoutPurchasesInput = {
    create?: XOR<MasterBullionCreateWithoutPurchasesInput, MasterBullionUncheckedCreateWithoutPurchasesInput>
    connectOrCreate?: MasterBullionCreateOrConnectWithoutPurchasesInput
    connect?: MasterBullionWhereUniqueInput
  }

  export type GivenDetailCreateNestedManyWithoutBullionPurchaseInput = {
    create?: XOR<GivenDetailCreateWithoutBullionPurchaseInput, GivenDetailUncheckedCreateWithoutBullionPurchaseInput> | GivenDetailCreateWithoutBullionPurchaseInput[] | GivenDetailUncheckedCreateWithoutBullionPurchaseInput[]
    connectOrCreate?: GivenDetailCreateOrConnectWithoutBullionPurchaseInput | GivenDetailCreateOrConnectWithoutBullionPurchaseInput[]
    createMany?: GivenDetailCreateManyBullionPurchaseInputEnvelope
    connect?: GivenDetailWhereUniqueInput | GivenDetailWhereUniqueInput[]
  }

  export type GivenDetailUncheckedCreateNestedManyWithoutBullionPurchaseInput = {
    create?: XOR<GivenDetailCreateWithoutBullionPurchaseInput, GivenDetailUncheckedCreateWithoutBullionPurchaseInput> | GivenDetailCreateWithoutBullionPurchaseInput[] | GivenDetailUncheckedCreateWithoutBullionPurchaseInput[]
    connectOrCreate?: GivenDetailCreateOrConnectWithoutBullionPurchaseInput | GivenDetailCreateOrConnectWithoutBullionPurchaseInput[]
    createMany?: GivenDetailCreateManyBullionPurchaseInputEnvelope
    connect?: GivenDetailWhereUniqueInput | GivenDetailWhereUniqueInput[]
  }

  export type MasterBullionUpdateOneRequiredWithoutPurchasesNestedInput = {
    create?: XOR<MasterBullionCreateWithoutPurchasesInput, MasterBullionUncheckedCreateWithoutPurchasesInput>
    connectOrCreate?: MasterBullionCreateOrConnectWithoutPurchasesInput
    upsert?: MasterBullionUpsertWithoutPurchasesInput
    connect?: MasterBullionWhereUniqueInput
    update?: XOR<XOR<MasterBullionUpdateToOneWithWhereWithoutPurchasesInput, MasterBullionUpdateWithoutPurchasesInput>, MasterBullionUncheckedUpdateWithoutPurchasesInput>
  }

  export type GivenDetailUpdateManyWithoutBullionPurchaseNestedInput = {
    create?: XOR<GivenDetailCreateWithoutBullionPurchaseInput, GivenDetailUncheckedCreateWithoutBullionPurchaseInput> | GivenDetailCreateWithoutBullionPurchaseInput[] | GivenDetailUncheckedCreateWithoutBullionPurchaseInput[]
    connectOrCreate?: GivenDetailCreateOrConnectWithoutBullionPurchaseInput | GivenDetailCreateOrConnectWithoutBullionPurchaseInput[]
    upsert?: GivenDetailUpsertWithWhereUniqueWithoutBullionPurchaseInput | GivenDetailUpsertWithWhereUniqueWithoutBullionPurchaseInput[]
    createMany?: GivenDetailCreateManyBullionPurchaseInputEnvelope
    set?: GivenDetailWhereUniqueInput | GivenDetailWhereUniqueInput[]
    disconnect?: GivenDetailWhereUniqueInput | GivenDetailWhereUniqueInput[]
    delete?: GivenDetailWhereUniqueInput | GivenDetailWhereUniqueInput[]
    connect?: GivenDetailWhereUniqueInput | GivenDetailWhereUniqueInput[]
    update?: GivenDetailUpdateWithWhereUniqueWithoutBullionPurchaseInput | GivenDetailUpdateWithWhereUniqueWithoutBullionPurchaseInput[]
    updateMany?: GivenDetailUpdateManyWithWhereWithoutBullionPurchaseInput | GivenDetailUpdateManyWithWhereWithoutBullionPurchaseInput[]
    deleteMany?: GivenDetailScalarWhereInput | GivenDetailScalarWhereInput[]
  }

  export type GivenDetailUncheckedUpdateManyWithoutBullionPurchaseNestedInput = {
    create?: XOR<GivenDetailCreateWithoutBullionPurchaseInput, GivenDetailUncheckedCreateWithoutBullionPurchaseInput> | GivenDetailCreateWithoutBullionPurchaseInput[] | GivenDetailUncheckedCreateWithoutBullionPurchaseInput[]
    connectOrCreate?: GivenDetailCreateOrConnectWithoutBullionPurchaseInput | GivenDetailCreateOrConnectWithoutBullionPurchaseInput[]
    upsert?: GivenDetailUpsertWithWhereUniqueWithoutBullionPurchaseInput | GivenDetailUpsertWithWhereUniqueWithoutBullionPurchaseInput[]
    createMany?: GivenDetailCreateManyBullionPurchaseInputEnvelope
    set?: GivenDetailWhereUniqueInput | GivenDetailWhereUniqueInput[]
    disconnect?: GivenDetailWhereUniqueInput | GivenDetailWhereUniqueInput[]
    delete?: GivenDetailWhereUniqueInput | GivenDetailWhereUniqueInput[]
    connect?: GivenDetailWhereUniqueInput | GivenDetailWhereUniqueInput[]
    update?: GivenDetailUpdateWithWhereUniqueWithoutBullionPurchaseInput | GivenDetailUpdateWithWhereUniqueWithoutBullionPurchaseInput[]
    updateMany?: GivenDetailUpdateManyWithWhereWithoutBullionPurchaseInput | GivenDetailUpdateManyWithWhereWithoutBullionPurchaseInput[]
    deleteMany?: GivenDetailScalarWhereInput | GivenDetailScalarWhereInput[]
  }

  export type BullionPurchaseCreateNestedOneWithoutGivenDetailsInput = {
    create?: XOR<BullionPurchaseCreateWithoutGivenDetailsInput, BullionPurchaseUncheckedCreateWithoutGivenDetailsInput>
    connectOrCreate?: BullionPurchaseCreateOrConnectWithoutGivenDetailsInput
    connect?: BullionPurchaseWhereUniqueInput
  }

  export type BullionPurchaseUpdateOneRequiredWithoutGivenDetailsNestedInput = {
    create?: XOR<BullionPurchaseCreateWithoutGivenDetailsInput, BullionPurchaseUncheckedCreateWithoutGivenDetailsInput>
    connectOrCreate?: BullionPurchaseCreateOrConnectWithoutGivenDetailsInput
    upsert?: BullionPurchaseUpsertWithoutGivenDetailsInput
    connect?: BullionPurchaseWhereUniqueInput
    update?: XOR<XOR<BullionPurchaseUpdateToOneWithWhereWithoutGivenDetailsInput, BullionPurchaseUpdateWithoutGivenDetailsInput>, BullionPurchaseUncheckedUpdateWithoutGivenDetailsInput>
  }

  export type JobcardCreateNestedManyWithoutGoldsmithInput = {
    create?: XOR<JobcardCreateWithoutGoldsmithInput, JobcardUncheckedCreateWithoutGoldsmithInput> | JobcardCreateWithoutGoldsmithInput[] | JobcardUncheckedCreateWithoutGoldsmithInput[]
    connectOrCreate?: JobcardCreateOrConnectWithoutGoldsmithInput | JobcardCreateOrConnectWithoutGoldsmithInput[]
    createMany?: JobcardCreateManyGoldsmithInputEnvelope
    connect?: JobcardWhereUniqueInput | JobcardWhereUniqueInput[]
  }

  export type TotalCreateNestedManyWithoutGoldsmithInput = {
    create?: XOR<TotalCreateWithoutGoldsmithInput, TotalUncheckedCreateWithoutGoldsmithInput> | TotalCreateWithoutGoldsmithInput[] | TotalUncheckedCreateWithoutGoldsmithInput[]
    connectOrCreate?: TotalCreateOrConnectWithoutGoldsmithInput | TotalCreateOrConnectWithoutGoldsmithInput[]
    createMany?: TotalCreateManyGoldsmithInputEnvelope
    connect?: TotalWhereUniqueInput | TotalWhereUniqueInput[]
  }

  export type givenGoldCreateNestedManyWithoutGoldsmithInput = {
    create?: XOR<givenGoldCreateWithoutGoldsmithInput, givenGoldUncheckedCreateWithoutGoldsmithInput> | givenGoldCreateWithoutGoldsmithInput[] | givenGoldUncheckedCreateWithoutGoldsmithInput[]
    connectOrCreate?: givenGoldCreateOrConnectWithoutGoldsmithInput | givenGoldCreateOrConnectWithoutGoldsmithInput[]
    createMany?: givenGoldCreateManyGoldsmithInputEnvelope
    connect?: givenGoldWhereUniqueInput | givenGoldWhereUniqueInput[]
  }

  export type itemDeliveryCreateNestedManyWithoutGoldsmithInput = {
    create?: XOR<itemDeliveryCreateWithoutGoldsmithInput, itemDeliveryUncheckedCreateWithoutGoldsmithInput> | itemDeliveryCreateWithoutGoldsmithInput[] | itemDeliveryUncheckedCreateWithoutGoldsmithInput[]
    connectOrCreate?: itemDeliveryCreateOrConnectWithoutGoldsmithInput | itemDeliveryCreateOrConnectWithoutGoldsmithInput[]
    createMany?: itemDeliveryCreateManyGoldsmithInputEnvelope
    connect?: itemDeliveryWhereUniqueInput | itemDeliveryWhereUniqueInput[]
  }

  export type ReceivedsectionCreateNestedManyWithoutGoldsmithInput = {
    create?: XOR<ReceivedsectionCreateWithoutGoldsmithInput, ReceivedsectionUncheckedCreateWithoutGoldsmithInput> | ReceivedsectionCreateWithoutGoldsmithInput[] | ReceivedsectionUncheckedCreateWithoutGoldsmithInput[]
    connectOrCreate?: ReceivedsectionCreateOrConnectWithoutGoldsmithInput | ReceivedsectionCreateOrConnectWithoutGoldsmithInput[]
    createMany?: ReceivedsectionCreateManyGoldsmithInputEnvelope
    connect?: ReceivedsectionWhereUniqueInput | ReceivedsectionWhereUniqueInput[]
  }

  export type RepairCreateNestedManyWithoutGoldsmithInput = {
    create?: XOR<RepairCreateWithoutGoldsmithInput, RepairUncheckedCreateWithoutGoldsmithInput> | RepairCreateWithoutGoldsmithInput[] | RepairUncheckedCreateWithoutGoldsmithInput[]
    connectOrCreate?: RepairCreateOrConnectWithoutGoldsmithInput | RepairCreateOrConnectWithoutGoldsmithInput[]
    createMany?: RepairCreateManyGoldsmithInputEnvelope
    connect?: RepairWhereUniqueInput | RepairWhereUniqueInput[]
  }

  export type BalancesCreateNestedManyWithoutGoldsmithInput = {
    create?: XOR<BalancesCreateWithoutGoldsmithInput, BalancesUncheckedCreateWithoutGoldsmithInput> | BalancesCreateWithoutGoldsmithInput[] | BalancesUncheckedCreateWithoutGoldsmithInput[]
    connectOrCreate?: BalancesCreateOrConnectWithoutGoldsmithInput | BalancesCreateOrConnectWithoutGoldsmithInput[]
    createMany?: BalancesCreateManyGoldsmithInputEnvelope
    connect?: BalancesWhereUniqueInput | BalancesWhereUniqueInput[]
  }

  export type JobcardUncheckedCreateNestedManyWithoutGoldsmithInput = {
    create?: XOR<JobcardCreateWithoutGoldsmithInput, JobcardUncheckedCreateWithoutGoldsmithInput> | JobcardCreateWithoutGoldsmithInput[] | JobcardUncheckedCreateWithoutGoldsmithInput[]
    connectOrCreate?: JobcardCreateOrConnectWithoutGoldsmithInput | JobcardCreateOrConnectWithoutGoldsmithInput[]
    createMany?: JobcardCreateManyGoldsmithInputEnvelope
    connect?: JobcardWhereUniqueInput | JobcardWhereUniqueInput[]
  }

  export type TotalUncheckedCreateNestedManyWithoutGoldsmithInput = {
    create?: XOR<TotalCreateWithoutGoldsmithInput, TotalUncheckedCreateWithoutGoldsmithInput> | TotalCreateWithoutGoldsmithInput[] | TotalUncheckedCreateWithoutGoldsmithInput[]
    connectOrCreate?: TotalCreateOrConnectWithoutGoldsmithInput | TotalCreateOrConnectWithoutGoldsmithInput[]
    createMany?: TotalCreateManyGoldsmithInputEnvelope
    connect?: TotalWhereUniqueInput | TotalWhereUniqueInput[]
  }

  export type givenGoldUncheckedCreateNestedManyWithoutGoldsmithInput = {
    create?: XOR<givenGoldCreateWithoutGoldsmithInput, givenGoldUncheckedCreateWithoutGoldsmithInput> | givenGoldCreateWithoutGoldsmithInput[] | givenGoldUncheckedCreateWithoutGoldsmithInput[]
    connectOrCreate?: givenGoldCreateOrConnectWithoutGoldsmithInput | givenGoldCreateOrConnectWithoutGoldsmithInput[]
    createMany?: givenGoldCreateManyGoldsmithInputEnvelope
    connect?: givenGoldWhereUniqueInput | givenGoldWhereUniqueInput[]
  }

  export type itemDeliveryUncheckedCreateNestedManyWithoutGoldsmithInput = {
    create?: XOR<itemDeliveryCreateWithoutGoldsmithInput, itemDeliveryUncheckedCreateWithoutGoldsmithInput> | itemDeliveryCreateWithoutGoldsmithInput[] | itemDeliveryUncheckedCreateWithoutGoldsmithInput[]
    connectOrCreate?: itemDeliveryCreateOrConnectWithoutGoldsmithInput | itemDeliveryCreateOrConnectWithoutGoldsmithInput[]
    createMany?: itemDeliveryCreateManyGoldsmithInputEnvelope
    connect?: itemDeliveryWhereUniqueInput | itemDeliveryWhereUniqueInput[]
  }

  export type ReceivedsectionUncheckedCreateNestedManyWithoutGoldsmithInput = {
    create?: XOR<ReceivedsectionCreateWithoutGoldsmithInput, ReceivedsectionUncheckedCreateWithoutGoldsmithInput> | ReceivedsectionCreateWithoutGoldsmithInput[] | ReceivedsectionUncheckedCreateWithoutGoldsmithInput[]
    connectOrCreate?: ReceivedsectionCreateOrConnectWithoutGoldsmithInput | ReceivedsectionCreateOrConnectWithoutGoldsmithInput[]
    createMany?: ReceivedsectionCreateManyGoldsmithInputEnvelope
    connect?: ReceivedsectionWhereUniqueInput | ReceivedsectionWhereUniqueInput[]
  }

  export type RepairUncheckedCreateNestedManyWithoutGoldsmithInput = {
    create?: XOR<RepairCreateWithoutGoldsmithInput, RepairUncheckedCreateWithoutGoldsmithInput> | RepairCreateWithoutGoldsmithInput[] | RepairUncheckedCreateWithoutGoldsmithInput[]
    connectOrCreate?: RepairCreateOrConnectWithoutGoldsmithInput | RepairCreateOrConnectWithoutGoldsmithInput[]
    createMany?: RepairCreateManyGoldsmithInputEnvelope
    connect?: RepairWhereUniqueInput | RepairWhereUniqueInput[]
  }

  export type BalancesUncheckedCreateNestedManyWithoutGoldsmithInput = {
    create?: XOR<BalancesCreateWithoutGoldsmithInput, BalancesUncheckedCreateWithoutGoldsmithInput> | BalancesCreateWithoutGoldsmithInput[] | BalancesUncheckedCreateWithoutGoldsmithInput[]
    connectOrCreate?: BalancesCreateOrConnectWithoutGoldsmithInput | BalancesCreateOrConnectWithoutGoldsmithInput[]
    createMany?: BalancesCreateManyGoldsmithInputEnvelope
    connect?: BalancesWhereUniqueInput | BalancesWhereUniqueInput[]
  }

  export type JobcardUpdateManyWithoutGoldsmithNestedInput = {
    create?: XOR<JobcardCreateWithoutGoldsmithInput, JobcardUncheckedCreateWithoutGoldsmithInput> | JobcardCreateWithoutGoldsmithInput[] | JobcardUncheckedCreateWithoutGoldsmithInput[]
    connectOrCreate?: JobcardCreateOrConnectWithoutGoldsmithInput | JobcardCreateOrConnectWithoutGoldsmithInput[]
    upsert?: JobcardUpsertWithWhereUniqueWithoutGoldsmithInput | JobcardUpsertWithWhereUniqueWithoutGoldsmithInput[]
    createMany?: JobcardCreateManyGoldsmithInputEnvelope
    set?: JobcardWhereUniqueInput | JobcardWhereUniqueInput[]
    disconnect?: JobcardWhereUniqueInput | JobcardWhereUniqueInput[]
    delete?: JobcardWhereUniqueInput | JobcardWhereUniqueInput[]
    connect?: JobcardWhereUniqueInput | JobcardWhereUniqueInput[]
    update?: JobcardUpdateWithWhereUniqueWithoutGoldsmithInput | JobcardUpdateWithWhereUniqueWithoutGoldsmithInput[]
    updateMany?: JobcardUpdateManyWithWhereWithoutGoldsmithInput | JobcardUpdateManyWithWhereWithoutGoldsmithInput[]
    deleteMany?: JobcardScalarWhereInput | JobcardScalarWhereInput[]
  }

  export type TotalUpdateManyWithoutGoldsmithNestedInput = {
    create?: XOR<TotalCreateWithoutGoldsmithInput, TotalUncheckedCreateWithoutGoldsmithInput> | TotalCreateWithoutGoldsmithInput[] | TotalUncheckedCreateWithoutGoldsmithInput[]
    connectOrCreate?: TotalCreateOrConnectWithoutGoldsmithInput | TotalCreateOrConnectWithoutGoldsmithInput[]
    upsert?: TotalUpsertWithWhereUniqueWithoutGoldsmithInput | TotalUpsertWithWhereUniqueWithoutGoldsmithInput[]
    createMany?: TotalCreateManyGoldsmithInputEnvelope
    set?: TotalWhereUniqueInput | TotalWhereUniqueInput[]
    disconnect?: TotalWhereUniqueInput | TotalWhereUniqueInput[]
    delete?: TotalWhereUniqueInput | TotalWhereUniqueInput[]
    connect?: TotalWhereUniqueInput | TotalWhereUniqueInput[]
    update?: TotalUpdateWithWhereUniqueWithoutGoldsmithInput | TotalUpdateWithWhereUniqueWithoutGoldsmithInput[]
    updateMany?: TotalUpdateManyWithWhereWithoutGoldsmithInput | TotalUpdateManyWithWhereWithoutGoldsmithInput[]
    deleteMany?: TotalScalarWhereInput | TotalScalarWhereInput[]
  }

  export type givenGoldUpdateManyWithoutGoldsmithNestedInput = {
    create?: XOR<givenGoldCreateWithoutGoldsmithInput, givenGoldUncheckedCreateWithoutGoldsmithInput> | givenGoldCreateWithoutGoldsmithInput[] | givenGoldUncheckedCreateWithoutGoldsmithInput[]
    connectOrCreate?: givenGoldCreateOrConnectWithoutGoldsmithInput | givenGoldCreateOrConnectWithoutGoldsmithInput[]
    upsert?: givenGoldUpsertWithWhereUniqueWithoutGoldsmithInput | givenGoldUpsertWithWhereUniqueWithoutGoldsmithInput[]
    createMany?: givenGoldCreateManyGoldsmithInputEnvelope
    set?: givenGoldWhereUniqueInput | givenGoldWhereUniqueInput[]
    disconnect?: givenGoldWhereUniqueInput | givenGoldWhereUniqueInput[]
    delete?: givenGoldWhereUniqueInput | givenGoldWhereUniqueInput[]
    connect?: givenGoldWhereUniqueInput | givenGoldWhereUniqueInput[]
    update?: givenGoldUpdateWithWhereUniqueWithoutGoldsmithInput | givenGoldUpdateWithWhereUniqueWithoutGoldsmithInput[]
    updateMany?: givenGoldUpdateManyWithWhereWithoutGoldsmithInput | givenGoldUpdateManyWithWhereWithoutGoldsmithInput[]
    deleteMany?: givenGoldScalarWhereInput | givenGoldScalarWhereInput[]
  }

  export type itemDeliveryUpdateManyWithoutGoldsmithNestedInput = {
    create?: XOR<itemDeliveryCreateWithoutGoldsmithInput, itemDeliveryUncheckedCreateWithoutGoldsmithInput> | itemDeliveryCreateWithoutGoldsmithInput[] | itemDeliveryUncheckedCreateWithoutGoldsmithInput[]
    connectOrCreate?: itemDeliveryCreateOrConnectWithoutGoldsmithInput | itemDeliveryCreateOrConnectWithoutGoldsmithInput[]
    upsert?: itemDeliveryUpsertWithWhereUniqueWithoutGoldsmithInput | itemDeliveryUpsertWithWhereUniqueWithoutGoldsmithInput[]
    createMany?: itemDeliveryCreateManyGoldsmithInputEnvelope
    set?: itemDeliveryWhereUniqueInput | itemDeliveryWhereUniqueInput[]
    disconnect?: itemDeliveryWhereUniqueInput | itemDeliveryWhereUniqueInput[]
    delete?: itemDeliveryWhereUniqueInput | itemDeliveryWhereUniqueInput[]
    connect?: itemDeliveryWhereUniqueInput | itemDeliveryWhereUniqueInput[]
    update?: itemDeliveryUpdateWithWhereUniqueWithoutGoldsmithInput | itemDeliveryUpdateWithWhereUniqueWithoutGoldsmithInput[]
    updateMany?: itemDeliveryUpdateManyWithWhereWithoutGoldsmithInput | itemDeliveryUpdateManyWithWhereWithoutGoldsmithInput[]
    deleteMany?: itemDeliveryScalarWhereInput | itemDeliveryScalarWhereInput[]
  }

  export type ReceivedsectionUpdateManyWithoutGoldsmithNestedInput = {
    create?: XOR<ReceivedsectionCreateWithoutGoldsmithInput, ReceivedsectionUncheckedCreateWithoutGoldsmithInput> | ReceivedsectionCreateWithoutGoldsmithInput[] | ReceivedsectionUncheckedCreateWithoutGoldsmithInput[]
    connectOrCreate?: ReceivedsectionCreateOrConnectWithoutGoldsmithInput | ReceivedsectionCreateOrConnectWithoutGoldsmithInput[]
    upsert?: ReceivedsectionUpsertWithWhereUniqueWithoutGoldsmithInput | ReceivedsectionUpsertWithWhereUniqueWithoutGoldsmithInput[]
    createMany?: ReceivedsectionCreateManyGoldsmithInputEnvelope
    set?: ReceivedsectionWhereUniqueInput | ReceivedsectionWhereUniqueInput[]
    disconnect?: ReceivedsectionWhereUniqueInput | ReceivedsectionWhereUniqueInput[]
    delete?: ReceivedsectionWhereUniqueInput | ReceivedsectionWhereUniqueInput[]
    connect?: ReceivedsectionWhereUniqueInput | ReceivedsectionWhereUniqueInput[]
    update?: ReceivedsectionUpdateWithWhereUniqueWithoutGoldsmithInput | ReceivedsectionUpdateWithWhereUniqueWithoutGoldsmithInput[]
    updateMany?: ReceivedsectionUpdateManyWithWhereWithoutGoldsmithInput | ReceivedsectionUpdateManyWithWhereWithoutGoldsmithInput[]
    deleteMany?: ReceivedsectionScalarWhereInput | ReceivedsectionScalarWhereInput[]
  }

  export type RepairUpdateManyWithoutGoldsmithNestedInput = {
    create?: XOR<RepairCreateWithoutGoldsmithInput, RepairUncheckedCreateWithoutGoldsmithInput> | RepairCreateWithoutGoldsmithInput[] | RepairUncheckedCreateWithoutGoldsmithInput[]
    connectOrCreate?: RepairCreateOrConnectWithoutGoldsmithInput | RepairCreateOrConnectWithoutGoldsmithInput[]
    upsert?: RepairUpsertWithWhereUniqueWithoutGoldsmithInput | RepairUpsertWithWhereUniqueWithoutGoldsmithInput[]
    createMany?: RepairCreateManyGoldsmithInputEnvelope
    set?: RepairWhereUniqueInput | RepairWhereUniqueInput[]
    disconnect?: RepairWhereUniqueInput | RepairWhereUniqueInput[]
    delete?: RepairWhereUniqueInput | RepairWhereUniqueInput[]
    connect?: RepairWhereUniqueInput | RepairWhereUniqueInput[]
    update?: RepairUpdateWithWhereUniqueWithoutGoldsmithInput | RepairUpdateWithWhereUniqueWithoutGoldsmithInput[]
    updateMany?: RepairUpdateManyWithWhereWithoutGoldsmithInput | RepairUpdateManyWithWhereWithoutGoldsmithInput[]
    deleteMany?: RepairScalarWhereInput | RepairScalarWhereInput[]
  }

  export type BalancesUpdateManyWithoutGoldsmithNestedInput = {
    create?: XOR<BalancesCreateWithoutGoldsmithInput, BalancesUncheckedCreateWithoutGoldsmithInput> | BalancesCreateWithoutGoldsmithInput[] | BalancesUncheckedCreateWithoutGoldsmithInput[]
    connectOrCreate?: BalancesCreateOrConnectWithoutGoldsmithInput | BalancesCreateOrConnectWithoutGoldsmithInput[]
    upsert?: BalancesUpsertWithWhereUniqueWithoutGoldsmithInput | BalancesUpsertWithWhereUniqueWithoutGoldsmithInput[]
    createMany?: BalancesCreateManyGoldsmithInputEnvelope
    set?: BalancesWhereUniqueInput | BalancesWhereUniqueInput[]
    disconnect?: BalancesWhereUniqueInput | BalancesWhereUniqueInput[]
    delete?: BalancesWhereUniqueInput | BalancesWhereUniqueInput[]
    connect?: BalancesWhereUniqueInput | BalancesWhereUniqueInput[]
    update?: BalancesUpdateWithWhereUniqueWithoutGoldsmithInput | BalancesUpdateWithWhereUniqueWithoutGoldsmithInput[]
    updateMany?: BalancesUpdateManyWithWhereWithoutGoldsmithInput | BalancesUpdateManyWithWhereWithoutGoldsmithInput[]
    deleteMany?: BalancesScalarWhereInput | BalancesScalarWhereInput[]
  }

  export type JobcardUncheckedUpdateManyWithoutGoldsmithNestedInput = {
    create?: XOR<JobcardCreateWithoutGoldsmithInput, JobcardUncheckedCreateWithoutGoldsmithInput> | JobcardCreateWithoutGoldsmithInput[] | JobcardUncheckedCreateWithoutGoldsmithInput[]
    connectOrCreate?: JobcardCreateOrConnectWithoutGoldsmithInput | JobcardCreateOrConnectWithoutGoldsmithInput[]
    upsert?: JobcardUpsertWithWhereUniqueWithoutGoldsmithInput | JobcardUpsertWithWhereUniqueWithoutGoldsmithInput[]
    createMany?: JobcardCreateManyGoldsmithInputEnvelope
    set?: JobcardWhereUniqueInput | JobcardWhereUniqueInput[]
    disconnect?: JobcardWhereUniqueInput | JobcardWhereUniqueInput[]
    delete?: JobcardWhereUniqueInput | JobcardWhereUniqueInput[]
    connect?: JobcardWhereUniqueInput | JobcardWhereUniqueInput[]
    update?: JobcardUpdateWithWhereUniqueWithoutGoldsmithInput | JobcardUpdateWithWhereUniqueWithoutGoldsmithInput[]
    updateMany?: JobcardUpdateManyWithWhereWithoutGoldsmithInput | JobcardUpdateManyWithWhereWithoutGoldsmithInput[]
    deleteMany?: JobcardScalarWhereInput | JobcardScalarWhereInput[]
  }

  export type TotalUncheckedUpdateManyWithoutGoldsmithNestedInput = {
    create?: XOR<TotalCreateWithoutGoldsmithInput, TotalUncheckedCreateWithoutGoldsmithInput> | TotalCreateWithoutGoldsmithInput[] | TotalUncheckedCreateWithoutGoldsmithInput[]
    connectOrCreate?: TotalCreateOrConnectWithoutGoldsmithInput | TotalCreateOrConnectWithoutGoldsmithInput[]
    upsert?: TotalUpsertWithWhereUniqueWithoutGoldsmithInput | TotalUpsertWithWhereUniqueWithoutGoldsmithInput[]
    createMany?: TotalCreateManyGoldsmithInputEnvelope
    set?: TotalWhereUniqueInput | TotalWhereUniqueInput[]
    disconnect?: TotalWhereUniqueInput | TotalWhereUniqueInput[]
    delete?: TotalWhereUniqueInput | TotalWhereUniqueInput[]
    connect?: TotalWhereUniqueInput | TotalWhereUniqueInput[]
    update?: TotalUpdateWithWhereUniqueWithoutGoldsmithInput | TotalUpdateWithWhereUniqueWithoutGoldsmithInput[]
    updateMany?: TotalUpdateManyWithWhereWithoutGoldsmithInput | TotalUpdateManyWithWhereWithoutGoldsmithInput[]
    deleteMany?: TotalScalarWhereInput | TotalScalarWhereInput[]
  }

  export type givenGoldUncheckedUpdateManyWithoutGoldsmithNestedInput = {
    create?: XOR<givenGoldCreateWithoutGoldsmithInput, givenGoldUncheckedCreateWithoutGoldsmithInput> | givenGoldCreateWithoutGoldsmithInput[] | givenGoldUncheckedCreateWithoutGoldsmithInput[]
    connectOrCreate?: givenGoldCreateOrConnectWithoutGoldsmithInput | givenGoldCreateOrConnectWithoutGoldsmithInput[]
    upsert?: givenGoldUpsertWithWhereUniqueWithoutGoldsmithInput | givenGoldUpsertWithWhereUniqueWithoutGoldsmithInput[]
    createMany?: givenGoldCreateManyGoldsmithInputEnvelope
    set?: givenGoldWhereUniqueInput | givenGoldWhereUniqueInput[]
    disconnect?: givenGoldWhereUniqueInput | givenGoldWhereUniqueInput[]
    delete?: givenGoldWhereUniqueInput | givenGoldWhereUniqueInput[]
    connect?: givenGoldWhereUniqueInput | givenGoldWhereUniqueInput[]
    update?: givenGoldUpdateWithWhereUniqueWithoutGoldsmithInput | givenGoldUpdateWithWhereUniqueWithoutGoldsmithInput[]
    updateMany?: givenGoldUpdateManyWithWhereWithoutGoldsmithInput | givenGoldUpdateManyWithWhereWithoutGoldsmithInput[]
    deleteMany?: givenGoldScalarWhereInput | givenGoldScalarWhereInput[]
  }

  export type itemDeliveryUncheckedUpdateManyWithoutGoldsmithNestedInput = {
    create?: XOR<itemDeliveryCreateWithoutGoldsmithInput, itemDeliveryUncheckedCreateWithoutGoldsmithInput> | itemDeliveryCreateWithoutGoldsmithInput[] | itemDeliveryUncheckedCreateWithoutGoldsmithInput[]
    connectOrCreate?: itemDeliveryCreateOrConnectWithoutGoldsmithInput | itemDeliveryCreateOrConnectWithoutGoldsmithInput[]
    upsert?: itemDeliveryUpsertWithWhereUniqueWithoutGoldsmithInput | itemDeliveryUpsertWithWhereUniqueWithoutGoldsmithInput[]
    createMany?: itemDeliveryCreateManyGoldsmithInputEnvelope
    set?: itemDeliveryWhereUniqueInput | itemDeliveryWhereUniqueInput[]
    disconnect?: itemDeliveryWhereUniqueInput | itemDeliveryWhereUniqueInput[]
    delete?: itemDeliveryWhereUniqueInput | itemDeliveryWhereUniqueInput[]
    connect?: itemDeliveryWhereUniqueInput | itemDeliveryWhereUniqueInput[]
    update?: itemDeliveryUpdateWithWhereUniqueWithoutGoldsmithInput | itemDeliveryUpdateWithWhereUniqueWithoutGoldsmithInput[]
    updateMany?: itemDeliveryUpdateManyWithWhereWithoutGoldsmithInput | itemDeliveryUpdateManyWithWhereWithoutGoldsmithInput[]
    deleteMany?: itemDeliveryScalarWhereInput | itemDeliveryScalarWhereInput[]
  }

  export type ReceivedsectionUncheckedUpdateManyWithoutGoldsmithNestedInput = {
    create?: XOR<ReceivedsectionCreateWithoutGoldsmithInput, ReceivedsectionUncheckedCreateWithoutGoldsmithInput> | ReceivedsectionCreateWithoutGoldsmithInput[] | ReceivedsectionUncheckedCreateWithoutGoldsmithInput[]
    connectOrCreate?: ReceivedsectionCreateOrConnectWithoutGoldsmithInput | ReceivedsectionCreateOrConnectWithoutGoldsmithInput[]
    upsert?: ReceivedsectionUpsertWithWhereUniqueWithoutGoldsmithInput | ReceivedsectionUpsertWithWhereUniqueWithoutGoldsmithInput[]
    createMany?: ReceivedsectionCreateManyGoldsmithInputEnvelope
    set?: ReceivedsectionWhereUniqueInput | ReceivedsectionWhereUniqueInput[]
    disconnect?: ReceivedsectionWhereUniqueInput | ReceivedsectionWhereUniqueInput[]
    delete?: ReceivedsectionWhereUniqueInput | ReceivedsectionWhereUniqueInput[]
    connect?: ReceivedsectionWhereUniqueInput | ReceivedsectionWhereUniqueInput[]
    update?: ReceivedsectionUpdateWithWhereUniqueWithoutGoldsmithInput | ReceivedsectionUpdateWithWhereUniqueWithoutGoldsmithInput[]
    updateMany?: ReceivedsectionUpdateManyWithWhereWithoutGoldsmithInput | ReceivedsectionUpdateManyWithWhereWithoutGoldsmithInput[]
    deleteMany?: ReceivedsectionScalarWhereInput | ReceivedsectionScalarWhereInput[]
  }

  export type RepairUncheckedUpdateManyWithoutGoldsmithNestedInput = {
    create?: XOR<RepairCreateWithoutGoldsmithInput, RepairUncheckedCreateWithoutGoldsmithInput> | RepairCreateWithoutGoldsmithInput[] | RepairUncheckedCreateWithoutGoldsmithInput[]
    connectOrCreate?: RepairCreateOrConnectWithoutGoldsmithInput | RepairCreateOrConnectWithoutGoldsmithInput[]
    upsert?: RepairUpsertWithWhereUniqueWithoutGoldsmithInput | RepairUpsertWithWhereUniqueWithoutGoldsmithInput[]
    createMany?: RepairCreateManyGoldsmithInputEnvelope
    set?: RepairWhereUniqueInput | RepairWhereUniqueInput[]
    disconnect?: RepairWhereUniqueInput | RepairWhereUniqueInput[]
    delete?: RepairWhereUniqueInput | RepairWhereUniqueInput[]
    connect?: RepairWhereUniqueInput | RepairWhereUniqueInput[]
    update?: RepairUpdateWithWhereUniqueWithoutGoldsmithInput | RepairUpdateWithWhereUniqueWithoutGoldsmithInput[]
    updateMany?: RepairUpdateManyWithWhereWithoutGoldsmithInput | RepairUpdateManyWithWhereWithoutGoldsmithInput[]
    deleteMany?: RepairScalarWhereInput | RepairScalarWhereInput[]
  }

  export type BalancesUncheckedUpdateManyWithoutGoldsmithNestedInput = {
    create?: XOR<BalancesCreateWithoutGoldsmithInput, BalancesUncheckedCreateWithoutGoldsmithInput> | BalancesCreateWithoutGoldsmithInput[] | BalancesUncheckedCreateWithoutGoldsmithInput[]
    connectOrCreate?: BalancesCreateOrConnectWithoutGoldsmithInput | BalancesCreateOrConnectWithoutGoldsmithInput[]
    upsert?: BalancesUpsertWithWhereUniqueWithoutGoldsmithInput | BalancesUpsertWithWhereUniqueWithoutGoldsmithInput[]
    createMany?: BalancesCreateManyGoldsmithInputEnvelope
    set?: BalancesWhereUniqueInput | BalancesWhereUniqueInput[]
    disconnect?: BalancesWhereUniqueInput | BalancesWhereUniqueInput[]
    delete?: BalancesWhereUniqueInput | BalancesWhereUniqueInput[]
    connect?: BalancesWhereUniqueInput | BalancesWhereUniqueInput[]
    update?: BalancesUpdateWithWhereUniqueWithoutGoldsmithInput | BalancesUpdateWithWhereUniqueWithoutGoldsmithInput[]
    updateMany?: BalancesUpdateManyWithWhereWithoutGoldsmithInput | BalancesUpdateManyWithWhereWithoutGoldsmithInput[]
    deleteMany?: BalancesScalarWhereInput | BalancesScalarWhereInput[]
  }

  export type GoldsmithCreateNestedOneWithoutJobcardsInput = {
    create?: XOR<GoldsmithCreateWithoutJobcardsInput, GoldsmithUncheckedCreateWithoutJobcardsInput>
    connectOrCreate?: GoldsmithCreateOrConnectWithoutJobcardsInput
    connect?: GoldsmithWhereUniqueInput
  }

  export type givenGoldCreateNestedManyWithoutJobcardInput = {
    create?: XOR<givenGoldCreateWithoutJobcardInput, givenGoldUncheckedCreateWithoutJobcardInput> | givenGoldCreateWithoutJobcardInput[] | givenGoldUncheckedCreateWithoutJobcardInput[]
    connectOrCreate?: givenGoldCreateOrConnectWithoutJobcardInput | givenGoldCreateOrConnectWithoutJobcardInput[]
    createMany?: givenGoldCreateManyJobcardInputEnvelope
    connect?: givenGoldWhereUniqueInput | givenGoldWhereUniqueInput[]
  }

  export type itemDeliveryCreateNestedManyWithoutJobcardInput = {
    create?: XOR<itemDeliveryCreateWithoutJobcardInput, itemDeliveryUncheckedCreateWithoutJobcardInput> | itemDeliveryCreateWithoutJobcardInput[] | itemDeliveryUncheckedCreateWithoutJobcardInput[]
    connectOrCreate?: itemDeliveryCreateOrConnectWithoutJobcardInput | itemDeliveryCreateOrConnectWithoutJobcardInput[]
    createMany?: itemDeliveryCreateManyJobcardInputEnvelope
    connect?: itemDeliveryWhereUniqueInput | itemDeliveryWhereUniqueInput[]
  }

  export type ReceivedsectionCreateNestedManyWithoutJobcardInput = {
    create?: XOR<ReceivedsectionCreateWithoutJobcardInput, ReceivedsectionUncheckedCreateWithoutJobcardInput> | ReceivedsectionCreateWithoutJobcardInput[] | ReceivedsectionUncheckedCreateWithoutJobcardInput[]
    connectOrCreate?: ReceivedsectionCreateOrConnectWithoutJobcardInput | ReceivedsectionCreateOrConnectWithoutJobcardInput[]
    createMany?: ReceivedsectionCreateManyJobcardInputEnvelope
    connect?: ReceivedsectionWhereUniqueInput | ReceivedsectionWhereUniqueInput[]
  }

  export type givenGoldUncheckedCreateNestedManyWithoutJobcardInput = {
    create?: XOR<givenGoldCreateWithoutJobcardInput, givenGoldUncheckedCreateWithoutJobcardInput> | givenGoldCreateWithoutJobcardInput[] | givenGoldUncheckedCreateWithoutJobcardInput[]
    connectOrCreate?: givenGoldCreateOrConnectWithoutJobcardInput | givenGoldCreateOrConnectWithoutJobcardInput[]
    createMany?: givenGoldCreateManyJobcardInputEnvelope
    connect?: givenGoldWhereUniqueInput | givenGoldWhereUniqueInput[]
  }

  export type itemDeliveryUncheckedCreateNestedManyWithoutJobcardInput = {
    create?: XOR<itemDeliveryCreateWithoutJobcardInput, itemDeliveryUncheckedCreateWithoutJobcardInput> | itemDeliveryCreateWithoutJobcardInput[] | itemDeliveryUncheckedCreateWithoutJobcardInput[]
    connectOrCreate?: itemDeliveryCreateOrConnectWithoutJobcardInput | itemDeliveryCreateOrConnectWithoutJobcardInput[]
    createMany?: itemDeliveryCreateManyJobcardInputEnvelope
    connect?: itemDeliveryWhereUniqueInput | itemDeliveryWhereUniqueInput[]
  }

  export type ReceivedsectionUncheckedCreateNestedManyWithoutJobcardInput = {
    create?: XOR<ReceivedsectionCreateWithoutJobcardInput, ReceivedsectionUncheckedCreateWithoutJobcardInput> | ReceivedsectionCreateWithoutJobcardInput[] | ReceivedsectionUncheckedCreateWithoutJobcardInput[]
    connectOrCreate?: ReceivedsectionCreateOrConnectWithoutJobcardInput | ReceivedsectionCreateOrConnectWithoutJobcardInput[]
    createMany?: ReceivedsectionCreateManyJobcardInputEnvelope
    connect?: ReceivedsectionWhereUniqueInput | ReceivedsectionWhereUniqueInput[]
  }

  export type GoldsmithUpdateOneRequiredWithoutJobcardsNestedInput = {
    create?: XOR<GoldsmithCreateWithoutJobcardsInput, GoldsmithUncheckedCreateWithoutJobcardsInput>
    connectOrCreate?: GoldsmithCreateOrConnectWithoutJobcardsInput
    upsert?: GoldsmithUpsertWithoutJobcardsInput
    connect?: GoldsmithWhereUniqueInput
    update?: XOR<XOR<GoldsmithUpdateToOneWithWhereWithoutJobcardsInput, GoldsmithUpdateWithoutJobcardsInput>, GoldsmithUncheckedUpdateWithoutJobcardsInput>
  }

  export type givenGoldUpdateManyWithoutJobcardNestedInput = {
    create?: XOR<givenGoldCreateWithoutJobcardInput, givenGoldUncheckedCreateWithoutJobcardInput> | givenGoldCreateWithoutJobcardInput[] | givenGoldUncheckedCreateWithoutJobcardInput[]
    connectOrCreate?: givenGoldCreateOrConnectWithoutJobcardInput | givenGoldCreateOrConnectWithoutJobcardInput[]
    upsert?: givenGoldUpsertWithWhereUniqueWithoutJobcardInput | givenGoldUpsertWithWhereUniqueWithoutJobcardInput[]
    createMany?: givenGoldCreateManyJobcardInputEnvelope
    set?: givenGoldWhereUniqueInput | givenGoldWhereUniqueInput[]
    disconnect?: givenGoldWhereUniqueInput | givenGoldWhereUniqueInput[]
    delete?: givenGoldWhereUniqueInput | givenGoldWhereUniqueInput[]
    connect?: givenGoldWhereUniqueInput | givenGoldWhereUniqueInput[]
    update?: givenGoldUpdateWithWhereUniqueWithoutJobcardInput | givenGoldUpdateWithWhereUniqueWithoutJobcardInput[]
    updateMany?: givenGoldUpdateManyWithWhereWithoutJobcardInput | givenGoldUpdateManyWithWhereWithoutJobcardInput[]
    deleteMany?: givenGoldScalarWhereInput | givenGoldScalarWhereInput[]
  }

  export type itemDeliveryUpdateManyWithoutJobcardNestedInput = {
    create?: XOR<itemDeliveryCreateWithoutJobcardInput, itemDeliveryUncheckedCreateWithoutJobcardInput> | itemDeliveryCreateWithoutJobcardInput[] | itemDeliveryUncheckedCreateWithoutJobcardInput[]
    connectOrCreate?: itemDeliveryCreateOrConnectWithoutJobcardInput | itemDeliveryCreateOrConnectWithoutJobcardInput[]
    upsert?: itemDeliveryUpsertWithWhereUniqueWithoutJobcardInput | itemDeliveryUpsertWithWhereUniqueWithoutJobcardInput[]
    createMany?: itemDeliveryCreateManyJobcardInputEnvelope
    set?: itemDeliveryWhereUniqueInput | itemDeliveryWhereUniqueInput[]
    disconnect?: itemDeliveryWhereUniqueInput | itemDeliveryWhereUniqueInput[]
    delete?: itemDeliveryWhereUniqueInput | itemDeliveryWhereUniqueInput[]
    connect?: itemDeliveryWhereUniqueInput | itemDeliveryWhereUniqueInput[]
    update?: itemDeliveryUpdateWithWhereUniqueWithoutJobcardInput | itemDeliveryUpdateWithWhereUniqueWithoutJobcardInput[]
    updateMany?: itemDeliveryUpdateManyWithWhereWithoutJobcardInput | itemDeliveryUpdateManyWithWhereWithoutJobcardInput[]
    deleteMany?: itemDeliveryScalarWhereInput | itemDeliveryScalarWhereInput[]
  }

  export type ReceivedsectionUpdateManyWithoutJobcardNestedInput = {
    create?: XOR<ReceivedsectionCreateWithoutJobcardInput, ReceivedsectionUncheckedCreateWithoutJobcardInput> | ReceivedsectionCreateWithoutJobcardInput[] | ReceivedsectionUncheckedCreateWithoutJobcardInput[]
    connectOrCreate?: ReceivedsectionCreateOrConnectWithoutJobcardInput | ReceivedsectionCreateOrConnectWithoutJobcardInput[]
    upsert?: ReceivedsectionUpsertWithWhereUniqueWithoutJobcardInput | ReceivedsectionUpsertWithWhereUniqueWithoutJobcardInput[]
    createMany?: ReceivedsectionCreateManyJobcardInputEnvelope
    set?: ReceivedsectionWhereUniqueInput | ReceivedsectionWhereUniqueInput[]
    disconnect?: ReceivedsectionWhereUniqueInput | ReceivedsectionWhereUniqueInput[]
    delete?: ReceivedsectionWhereUniqueInput | ReceivedsectionWhereUniqueInput[]
    connect?: ReceivedsectionWhereUniqueInput | ReceivedsectionWhereUniqueInput[]
    update?: ReceivedsectionUpdateWithWhereUniqueWithoutJobcardInput | ReceivedsectionUpdateWithWhereUniqueWithoutJobcardInput[]
    updateMany?: ReceivedsectionUpdateManyWithWhereWithoutJobcardInput | ReceivedsectionUpdateManyWithWhereWithoutJobcardInput[]
    deleteMany?: ReceivedsectionScalarWhereInput | ReceivedsectionScalarWhereInput[]
  }

  export type givenGoldUncheckedUpdateManyWithoutJobcardNestedInput = {
    create?: XOR<givenGoldCreateWithoutJobcardInput, givenGoldUncheckedCreateWithoutJobcardInput> | givenGoldCreateWithoutJobcardInput[] | givenGoldUncheckedCreateWithoutJobcardInput[]
    connectOrCreate?: givenGoldCreateOrConnectWithoutJobcardInput | givenGoldCreateOrConnectWithoutJobcardInput[]
    upsert?: givenGoldUpsertWithWhereUniqueWithoutJobcardInput | givenGoldUpsertWithWhereUniqueWithoutJobcardInput[]
    createMany?: givenGoldCreateManyJobcardInputEnvelope
    set?: givenGoldWhereUniqueInput | givenGoldWhereUniqueInput[]
    disconnect?: givenGoldWhereUniqueInput | givenGoldWhereUniqueInput[]
    delete?: givenGoldWhereUniqueInput | givenGoldWhereUniqueInput[]
    connect?: givenGoldWhereUniqueInput | givenGoldWhereUniqueInput[]
    update?: givenGoldUpdateWithWhereUniqueWithoutJobcardInput | givenGoldUpdateWithWhereUniqueWithoutJobcardInput[]
    updateMany?: givenGoldUpdateManyWithWhereWithoutJobcardInput | givenGoldUpdateManyWithWhereWithoutJobcardInput[]
    deleteMany?: givenGoldScalarWhereInput | givenGoldScalarWhereInput[]
  }

  export type itemDeliveryUncheckedUpdateManyWithoutJobcardNestedInput = {
    create?: XOR<itemDeliveryCreateWithoutJobcardInput, itemDeliveryUncheckedCreateWithoutJobcardInput> | itemDeliveryCreateWithoutJobcardInput[] | itemDeliveryUncheckedCreateWithoutJobcardInput[]
    connectOrCreate?: itemDeliveryCreateOrConnectWithoutJobcardInput | itemDeliveryCreateOrConnectWithoutJobcardInput[]
    upsert?: itemDeliveryUpsertWithWhereUniqueWithoutJobcardInput | itemDeliveryUpsertWithWhereUniqueWithoutJobcardInput[]
    createMany?: itemDeliveryCreateManyJobcardInputEnvelope
    set?: itemDeliveryWhereUniqueInput | itemDeliveryWhereUniqueInput[]
    disconnect?: itemDeliveryWhereUniqueInput | itemDeliveryWhereUniqueInput[]
    delete?: itemDeliveryWhereUniqueInput | itemDeliveryWhereUniqueInput[]
    connect?: itemDeliveryWhereUniqueInput | itemDeliveryWhereUniqueInput[]
    update?: itemDeliveryUpdateWithWhereUniqueWithoutJobcardInput | itemDeliveryUpdateWithWhereUniqueWithoutJobcardInput[]
    updateMany?: itemDeliveryUpdateManyWithWhereWithoutJobcardInput | itemDeliveryUpdateManyWithWhereWithoutJobcardInput[]
    deleteMany?: itemDeliveryScalarWhereInput | itemDeliveryScalarWhereInput[]
  }

  export type ReceivedsectionUncheckedUpdateManyWithoutJobcardNestedInput = {
    create?: XOR<ReceivedsectionCreateWithoutJobcardInput, ReceivedsectionUncheckedCreateWithoutJobcardInput> | ReceivedsectionCreateWithoutJobcardInput[] | ReceivedsectionUncheckedCreateWithoutJobcardInput[]
    connectOrCreate?: ReceivedsectionCreateOrConnectWithoutJobcardInput | ReceivedsectionCreateOrConnectWithoutJobcardInput[]
    upsert?: ReceivedsectionUpsertWithWhereUniqueWithoutJobcardInput | ReceivedsectionUpsertWithWhereUniqueWithoutJobcardInput[]
    createMany?: ReceivedsectionCreateManyJobcardInputEnvelope
    set?: ReceivedsectionWhereUniqueInput | ReceivedsectionWhereUniqueInput[]
    disconnect?: ReceivedsectionWhereUniqueInput | ReceivedsectionWhereUniqueInput[]
    delete?: ReceivedsectionWhereUniqueInput | ReceivedsectionWhereUniqueInput[]
    connect?: ReceivedsectionWhereUniqueInput | ReceivedsectionWhereUniqueInput[]
    update?: ReceivedsectionUpdateWithWhereUniqueWithoutJobcardInput | ReceivedsectionUpdateWithWhereUniqueWithoutJobcardInput[]
    updateMany?: ReceivedsectionUpdateManyWithWhereWithoutJobcardInput | ReceivedsectionUpdateManyWithWhereWithoutJobcardInput[]
    deleteMany?: ReceivedsectionScalarWhereInput | ReceivedsectionScalarWhereInput[]
  }

  export type GoldsmithCreateNestedOneWithoutGivenGoldInput = {
    create?: XOR<GoldsmithCreateWithoutGivenGoldInput, GoldsmithUncheckedCreateWithoutGivenGoldInput>
    connectOrCreate?: GoldsmithCreateOrConnectWithoutGivenGoldInput
    connect?: GoldsmithWhereUniqueInput
  }

  export type JobcardCreateNestedOneWithoutGivenGoldInput = {
    create?: XOR<JobcardCreateWithoutGivenGoldInput, JobcardUncheckedCreateWithoutGivenGoldInput>
    connectOrCreate?: JobcardCreateOrConnectWithoutGivenGoldInput
    connect?: JobcardWhereUniqueInput
  }

  export type GoldsmithUpdateOneWithoutGivenGoldNestedInput = {
    create?: XOR<GoldsmithCreateWithoutGivenGoldInput, GoldsmithUncheckedCreateWithoutGivenGoldInput>
    connectOrCreate?: GoldsmithCreateOrConnectWithoutGivenGoldInput
    upsert?: GoldsmithUpsertWithoutGivenGoldInput
    disconnect?: GoldsmithWhereInput | boolean
    delete?: GoldsmithWhereInput | boolean
    connect?: GoldsmithWhereUniqueInput
    update?: XOR<XOR<GoldsmithUpdateToOneWithWhereWithoutGivenGoldInput, GoldsmithUpdateWithoutGivenGoldInput>, GoldsmithUncheckedUpdateWithoutGivenGoldInput>
  }

  export type JobcardUpdateOneWithoutGivenGoldNestedInput = {
    create?: XOR<JobcardCreateWithoutGivenGoldInput, JobcardUncheckedCreateWithoutGivenGoldInput>
    connectOrCreate?: JobcardCreateOrConnectWithoutGivenGoldInput
    upsert?: JobcardUpsertWithoutGivenGoldInput
    disconnect?: JobcardWhereInput | boolean
    delete?: JobcardWhereInput | boolean
    connect?: JobcardWhereUniqueInput
    update?: XOR<XOR<JobcardUpdateToOneWithWhereWithoutGivenGoldInput, JobcardUpdateWithoutGivenGoldInput>, JobcardUncheckedUpdateWithoutGivenGoldInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type GoldsmithCreateNestedOneWithoutTotalsInput = {
    create?: XOR<GoldsmithCreateWithoutTotalsInput, GoldsmithUncheckedCreateWithoutTotalsInput>
    connectOrCreate?: GoldsmithCreateOrConnectWithoutTotalsInput
    connect?: GoldsmithWhereUniqueInput
  }

  export type GoldsmithUpdateOneRequiredWithoutTotalsNestedInput = {
    create?: XOR<GoldsmithCreateWithoutTotalsInput, GoldsmithUncheckedCreateWithoutTotalsInput>
    connectOrCreate?: GoldsmithCreateOrConnectWithoutTotalsInput
    upsert?: GoldsmithUpsertWithoutTotalsInput
    connect?: GoldsmithWhereUniqueInput
    update?: XOR<XOR<GoldsmithUpdateToOneWithWhereWithoutTotalsInput, GoldsmithUpdateWithoutTotalsInput>, GoldsmithUncheckedUpdateWithoutTotalsInput>
  }

  export type GoldsmithCreateNestedOneWithoutDeliveriesInput = {
    create?: XOR<GoldsmithCreateWithoutDeliveriesInput, GoldsmithUncheckedCreateWithoutDeliveriesInput>
    connectOrCreate?: GoldsmithCreateOrConnectWithoutDeliveriesInput
    connect?: GoldsmithWhereUniqueInput
  }

  export type JobcardCreateNestedOneWithoutDeliveriesInput = {
    create?: XOR<JobcardCreateWithoutDeliveriesInput, JobcardUncheckedCreateWithoutDeliveriesInput>
    connectOrCreate?: JobcardCreateOrConnectWithoutDeliveriesInput
    connect?: JobcardWhereUniqueInput
  }

  export type EnumWastageTypeFieldUpdateOperationsInput = {
    set?: $Enums.WastageType
  }

  export type GoldsmithUpdateOneWithoutDeliveriesNestedInput = {
    create?: XOR<GoldsmithCreateWithoutDeliveriesInput, GoldsmithUncheckedCreateWithoutDeliveriesInput>
    connectOrCreate?: GoldsmithCreateOrConnectWithoutDeliveriesInput
    upsert?: GoldsmithUpsertWithoutDeliveriesInput
    disconnect?: GoldsmithWhereInput | boolean
    delete?: GoldsmithWhereInput | boolean
    connect?: GoldsmithWhereUniqueInput
    update?: XOR<XOR<GoldsmithUpdateToOneWithWhereWithoutDeliveriesInput, GoldsmithUpdateWithoutDeliveriesInput>, GoldsmithUncheckedUpdateWithoutDeliveriesInput>
  }

  export type JobcardUpdateOneWithoutDeliveriesNestedInput = {
    create?: XOR<JobcardCreateWithoutDeliveriesInput, JobcardUncheckedCreateWithoutDeliveriesInput>
    connectOrCreate?: JobcardCreateOrConnectWithoutDeliveriesInput
    upsert?: JobcardUpsertWithoutDeliveriesInput
    disconnect?: JobcardWhereInput | boolean
    delete?: JobcardWhereInput | boolean
    connect?: JobcardWhereUniqueInput
    update?: XOR<XOR<JobcardUpdateToOneWithWhereWithoutDeliveriesInput, JobcardUpdateWithoutDeliveriesInput>, JobcardUncheckedUpdateWithoutDeliveriesInput>
  }

  export type JobcardCreateNestedOneWithoutReceivedInput = {
    create?: XOR<JobcardCreateWithoutReceivedInput, JobcardUncheckedCreateWithoutReceivedInput>
    connectOrCreate?: JobcardCreateOrConnectWithoutReceivedInput
    connect?: JobcardWhereUniqueInput
  }

  export type GoldsmithCreateNestedOneWithoutReceivedInput = {
    create?: XOR<GoldsmithCreateWithoutReceivedInput, GoldsmithUncheckedCreateWithoutReceivedInput>
    connectOrCreate?: GoldsmithCreateOrConnectWithoutReceivedInput
    connect?: GoldsmithWhereUniqueInput
  }

  export type JobcardUpdateOneWithoutReceivedNestedInput = {
    create?: XOR<JobcardCreateWithoutReceivedInput, JobcardUncheckedCreateWithoutReceivedInput>
    connectOrCreate?: JobcardCreateOrConnectWithoutReceivedInput
    upsert?: JobcardUpsertWithoutReceivedInput
    disconnect?: JobcardWhereInput | boolean
    delete?: JobcardWhereInput | boolean
    connect?: JobcardWhereUniqueInput
    update?: XOR<XOR<JobcardUpdateToOneWithWhereWithoutReceivedInput, JobcardUpdateWithoutReceivedInput>, JobcardUncheckedUpdateWithoutReceivedInput>
  }

  export type GoldsmithUpdateOneWithoutReceivedNestedInput = {
    create?: XOR<GoldsmithCreateWithoutReceivedInput, GoldsmithUncheckedCreateWithoutReceivedInput>
    connectOrCreate?: GoldsmithCreateOrConnectWithoutReceivedInput
    upsert?: GoldsmithUpsertWithoutReceivedInput
    disconnect?: GoldsmithWhereInput | boolean
    delete?: GoldsmithWhereInput | boolean
    connect?: GoldsmithWhereUniqueInput
    update?: XOR<XOR<GoldsmithUpdateToOneWithWhereWithoutReceivedInput, GoldsmithUpdateWithoutReceivedInput>, GoldsmithUncheckedUpdateWithoutReceivedInput>
  }

  export type GoldsmithCreateNestedOneWithoutSummariesInput = {
    create?: XOR<GoldsmithCreateWithoutSummariesInput, GoldsmithUncheckedCreateWithoutSummariesInput>
    connectOrCreate?: GoldsmithCreateOrConnectWithoutSummariesInput
    connect?: GoldsmithWhereUniqueInput
  }

  export type GoldsmithUpdateOneRequiredWithoutSummariesNestedInput = {
    create?: XOR<GoldsmithCreateWithoutSummariesInput, GoldsmithUncheckedCreateWithoutSummariesInput>
    connectOrCreate?: GoldsmithCreateOrConnectWithoutSummariesInput
    upsert?: GoldsmithUpsertWithoutSummariesInput
    connect?: GoldsmithWhereUniqueInput
    update?: XOR<XOR<GoldsmithUpdateToOneWithWhereWithoutSummariesInput, GoldsmithUpdateWithoutSummariesInput>, GoldsmithUncheckedUpdateWithoutSummariesInput>
  }

  export type GoldsmithCreateNestedOneWithoutRepairsInput = {
    create?: XOR<GoldsmithCreateWithoutRepairsInput, GoldsmithUncheckedCreateWithoutRepairsInput>
    connectOrCreate?: GoldsmithCreateOrConnectWithoutRepairsInput
    connect?: GoldsmithWhereUniqueInput
  }

  export type GoldsmithUpdateOneRequiredWithoutRepairsNestedInput = {
    create?: XOR<GoldsmithCreateWithoutRepairsInput, GoldsmithUncheckedCreateWithoutRepairsInput>
    connectOrCreate?: GoldsmithCreateOrConnectWithoutRepairsInput
    upsert?: GoldsmithUpsertWithoutRepairsInput
    connect?: GoldsmithWhereUniqueInput
    update?: XOR<XOR<GoldsmithUpdateToOneWithWhereWithoutRepairsInput, GoldsmithUpdateWithoutRepairsInput>, GoldsmithUncheckedUpdateWithoutRepairsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedEnumWastageTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.WastageType | EnumWastageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WastageType[]
    notIn?: $Enums.WastageType[]
    not?: NestedEnumWastageTypeFilter<$PrismaModel> | $Enums.WastageType
  }

  export type NestedEnumWastageTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WastageType | EnumWastageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WastageType[]
    notIn?: $Enums.WastageType[]
    not?: NestedEnumWastageTypeWithAggregatesFilter<$PrismaModel> | $Enums.WastageType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWastageTypeFilter<$PrismaModel>
    _max?: NestedEnumWastageTypeFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type TransactionCreateWithoutCustomerInput = {
    date: Date | string
    type: string
    value: number
    goldRate?: number | null
    purity: number
    touch?: number | null
    createdAt?: Date | string
  }

  export type TransactionUncheckedCreateWithoutCustomerInput = {
    id?: number
    date: Date | string
    type: string
    value: number
    goldRate?: number | null
    purity: number
    touch?: number | null
    createdAt?: Date | string
  }

  export type TransactionCreateOrConnectWithoutCustomerInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutCustomerInput, TransactionUncheckedCreateWithoutCustomerInput>
  }

  export type TransactionCreateManyCustomerInputEnvelope = {
    data: TransactionCreateManyCustomerInput | TransactionCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type customer_orderCreateWithoutCustomersInput = {
    order_group_id: number
    item_name: string
    description: string
    weight: number
    image?: string | null
    due_date?: Date | string | null
    status?: string
    worker_name?: string | null
    created_at?: Date | string
    updatedAt?: Date | string
    productImages?: product_multiple_imagesCreateNestedManyWithoutCustomerOrderDetailsInput
  }

  export type customer_orderUncheckedCreateWithoutCustomersInput = {
    id?: number
    order_group_id: number
    item_name: string
    description: string
    weight: number
    image?: string | null
    due_date?: Date | string | null
    status?: string
    worker_name?: string | null
    created_at?: Date | string
    updatedAt?: Date | string
    productImages?: product_multiple_imagesUncheckedCreateNestedManyWithoutCustomerOrderDetailsInput
  }

  export type customer_orderCreateOrConnectWithoutCustomersInput = {
    where: customer_orderWhereUniqueInput
    create: XOR<customer_orderCreateWithoutCustomersInput, customer_orderUncheckedCreateWithoutCustomersInput>
  }

  export type customer_orderCreateManyCustomersInputEnvelope = {
    data: customer_orderCreateManyCustomersInput | customer_orderCreateManyCustomersInput[]
    skipDuplicates?: boolean
  }

  export type TransactionUpsertWithWhereUniqueWithoutCustomerInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutCustomerInput, TransactionUncheckedUpdateWithoutCustomerInput>
    create: XOR<TransactionCreateWithoutCustomerInput, TransactionUncheckedCreateWithoutCustomerInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutCustomerInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutCustomerInput, TransactionUncheckedUpdateWithoutCustomerInput>
  }

  export type TransactionUpdateManyWithWhereWithoutCustomerInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutCustomerInput>
  }

  export type TransactionScalarWhereInput = {
    AND?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    OR?: TransactionScalarWhereInput[]
    NOT?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    id?: IntFilter<"Transaction"> | number
    date?: DateTimeFilter<"Transaction"> | Date | string
    type?: StringFilter<"Transaction"> | string
    value?: FloatFilter<"Transaction"> | number
    goldRate?: FloatNullableFilter<"Transaction"> | number | null
    purity?: FloatFilter<"Transaction"> | number
    touch?: FloatNullableFilter<"Transaction"> | number | null
    customerId?: IntFilter<"Transaction"> | number
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
  }

  export type customer_orderUpsertWithWhereUniqueWithoutCustomersInput = {
    where: customer_orderWhereUniqueInput
    update: XOR<customer_orderUpdateWithoutCustomersInput, customer_orderUncheckedUpdateWithoutCustomersInput>
    create: XOR<customer_orderCreateWithoutCustomersInput, customer_orderUncheckedCreateWithoutCustomersInput>
  }

  export type customer_orderUpdateWithWhereUniqueWithoutCustomersInput = {
    where: customer_orderWhereUniqueInput
    data: XOR<customer_orderUpdateWithoutCustomersInput, customer_orderUncheckedUpdateWithoutCustomersInput>
  }

  export type customer_orderUpdateManyWithWhereWithoutCustomersInput = {
    where: customer_orderScalarWhereInput
    data: XOR<customer_orderUpdateManyMutationInput, customer_orderUncheckedUpdateManyWithoutCustomersInput>
  }

  export type customer_orderScalarWhereInput = {
    AND?: customer_orderScalarWhereInput | customer_orderScalarWhereInput[]
    OR?: customer_orderScalarWhereInput[]
    NOT?: customer_orderScalarWhereInput | customer_orderScalarWhereInput[]
    id?: IntFilter<"customer_order"> | number
    customer_id?: IntFilter<"customer_order"> | number
    order_group_id?: IntFilter<"customer_order"> | number
    item_name?: StringFilter<"customer_order"> | string
    description?: StringFilter<"customer_order"> | string
    weight?: FloatFilter<"customer_order"> | number
    image?: StringNullableFilter<"customer_order"> | string | null
    due_date?: DateTimeNullableFilter<"customer_order"> | Date | string | null
    status?: StringFilter<"customer_order"> | string
    worker_name?: StringNullableFilter<"customer_order"> | string | null
    created_at?: DateTimeFilter<"customer_order"> | Date | string
    updatedAt?: DateTimeFilter<"customer_order"> | Date | string
  }

  export type CustomerCreateWithoutTransactionsInput = {
    name: string
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    customerOrders?: customer_orderCreateNestedManyWithoutCustomersInput
  }

  export type CustomerUncheckedCreateWithoutTransactionsInput = {
    id?: number
    name: string
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    customerOrders?: customer_orderUncheckedCreateNestedManyWithoutCustomersInput
  }

  export type CustomerCreateOrConnectWithoutTransactionsInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutTransactionsInput, CustomerUncheckedCreateWithoutTransactionsInput>
  }

  export type CustomerUpsertWithoutTransactionsInput = {
    update: XOR<CustomerUpdateWithoutTransactionsInput, CustomerUncheckedUpdateWithoutTransactionsInput>
    create: XOR<CustomerCreateWithoutTransactionsInput, CustomerUncheckedCreateWithoutTransactionsInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutTransactionsInput, CustomerUncheckedUpdateWithoutTransactionsInput>
  }

  export type CustomerUpdateWithoutTransactionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerOrders?: customer_orderUpdateManyWithoutCustomersNestedInput
  }

  export type CustomerUncheckedUpdateWithoutTransactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerOrders?: customer_orderUncheckedUpdateManyWithoutCustomersNestedInput
  }

  export type CustomerCreateWithoutCustomerOrdersInput = {
    name: string
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    transactions?: TransactionCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutCustomerOrdersInput = {
    id?: number
    name: string
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutCustomerOrdersInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutCustomerOrdersInput, CustomerUncheckedCreateWithoutCustomerOrdersInput>
  }

  export type product_multiple_imagesCreateWithoutCustomerOrderDetailsInput = {
    filename: string
  }

  export type product_multiple_imagesUncheckedCreateWithoutCustomerOrderDetailsInput = {
    id?: number
    filename: string
  }

  export type product_multiple_imagesCreateOrConnectWithoutCustomerOrderDetailsInput = {
    where: product_multiple_imagesWhereUniqueInput
    create: XOR<product_multiple_imagesCreateWithoutCustomerOrderDetailsInput, product_multiple_imagesUncheckedCreateWithoutCustomerOrderDetailsInput>
  }

  export type product_multiple_imagesCreateManyCustomerOrderDetailsInputEnvelope = {
    data: product_multiple_imagesCreateManyCustomerOrderDetailsInput | product_multiple_imagesCreateManyCustomerOrderDetailsInput[]
    skipDuplicates?: boolean
  }

  export type CustomerUpsertWithoutCustomerOrdersInput = {
    update: XOR<CustomerUpdateWithoutCustomerOrdersInput, CustomerUncheckedUpdateWithoutCustomerOrdersInput>
    create: XOR<CustomerCreateWithoutCustomerOrdersInput, CustomerUncheckedCreateWithoutCustomerOrdersInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutCustomerOrdersInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutCustomerOrdersInput, CustomerUncheckedUpdateWithoutCustomerOrdersInput>
  }

  export type CustomerUpdateWithoutCustomerOrdersInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutCustomerOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type product_multiple_imagesUpsertWithWhereUniqueWithoutCustomerOrderDetailsInput = {
    where: product_multiple_imagesWhereUniqueInput
    update: XOR<product_multiple_imagesUpdateWithoutCustomerOrderDetailsInput, product_multiple_imagesUncheckedUpdateWithoutCustomerOrderDetailsInput>
    create: XOR<product_multiple_imagesCreateWithoutCustomerOrderDetailsInput, product_multiple_imagesUncheckedCreateWithoutCustomerOrderDetailsInput>
  }

  export type product_multiple_imagesUpdateWithWhereUniqueWithoutCustomerOrderDetailsInput = {
    where: product_multiple_imagesWhereUniqueInput
    data: XOR<product_multiple_imagesUpdateWithoutCustomerOrderDetailsInput, product_multiple_imagesUncheckedUpdateWithoutCustomerOrderDetailsInput>
  }

  export type product_multiple_imagesUpdateManyWithWhereWithoutCustomerOrderDetailsInput = {
    where: product_multiple_imagesScalarWhereInput
    data: XOR<product_multiple_imagesUpdateManyMutationInput, product_multiple_imagesUncheckedUpdateManyWithoutCustomerOrderDetailsInput>
  }

  export type product_multiple_imagesScalarWhereInput = {
    AND?: product_multiple_imagesScalarWhereInput | product_multiple_imagesScalarWhereInput[]
    OR?: product_multiple_imagesScalarWhereInput[]
    NOT?: product_multiple_imagesScalarWhereInput | product_multiple_imagesScalarWhereInput[]
    id?: IntFilter<"product_multiple_images"> | number
    customer_order_id?: IntFilter<"product_multiple_images"> | number
    filename?: StringFilter<"product_multiple_images"> | string
  }

  export type customer_orderCreateWithoutProductImagesInput = {
    order_group_id: number
    item_name: string
    description: string
    weight: number
    image?: string | null
    due_date?: Date | string | null
    status?: string
    worker_name?: string | null
    created_at?: Date | string
    updatedAt?: Date | string
    customers: CustomerCreateNestedOneWithoutCustomerOrdersInput
  }

  export type customer_orderUncheckedCreateWithoutProductImagesInput = {
    id?: number
    customer_id: number
    order_group_id: number
    item_name: string
    description: string
    weight: number
    image?: string | null
    due_date?: Date | string | null
    status?: string
    worker_name?: string | null
    created_at?: Date | string
    updatedAt?: Date | string
  }

  export type customer_orderCreateOrConnectWithoutProductImagesInput = {
    where: customer_orderWhereUniqueInput
    create: XOR<customer_orderCreateWithoutProductImagesInput, customer_orderUncheckedCreateWithoutProductImagesInput>
  }

  export type customer_orderUpsertWithoutProductImagesInput = {
    update: XOR<customer_orderUpdateWithoutProductImagesInput, customer_orderUncheckedUpdateWithoutProductImagesInput>
    create: XOR<customer_orderCreateWithoutProductImagesInput, customer_orderUncheckedCreateWithoutProductImagesInput>
    where?: customer_orderWhereInput
  }

  export type customer_orderUpdateToOneWithWhereWithoutProductImagesInput = {
    where?: customer_orderWhereInput
    data: XOR<customer_orderUpdateWithoutProductImagesInput, customer_orderUncheckedUpdateWithoutProductImagesInput>
  }

  export type customer_orderUpdateWithoutProductImagesInput = {
    order_group_id?: IntFieldUpdateOperationsInput | number
    item_name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    weight?: FloatFieldUpdateOperationsInput | number
    image?: NullableStringFieldUpdateOperationsInput | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    worker_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customers?: CustomerUpdateOneRequiredWithoutCustomerOrdersNestedInput
  }

  export type customer_orderUncheckedUpdateWithoutProductImagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    customer_id?: IntFieldUpdateOperationsInput | number
    order_group_id?: IntFieldUpdateOperationsInput | number
    item_name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    weight?: FloatFieldUpdateOperationsInput | number
    image?: NullableStringFieldUpdateOperationsInput | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    worker_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BullionPurchaseCreateWithoutBullionInput = {
    grams: number
    touch?: number | null
    purity?: number | null
    rate: number
    amount: number
    balance: number
    createdAt?: Date | string
    givenDetails?: GivenDetailCreateNestedManyWithoutBullionPurchaseInput
  }

  export type BullionPurchaseUncheckedCreateWithoutBullionInput = {
    id?: number
    grams: number
    touch?: number | null
    purity?: number | null
    rate: number
    amount: number
    balance: number
    createdAt?: Date | string
    givenDetails?: GivenDetailUncheckedCreateNestedManyWithoutBullionPurchaseInput
  }

  export type BullionPurchaseCreateOrConnectWithoutBullionInput = {
    where: BullionPurchaseWhereUniqueInput
    create: XOR<BullionPurchaseCreateWithoutBullionInput, BullionPurchaseUncheckedCreateWithoutBullionInput>
  }

  export type BullionPurchaseCreateManyBullionInputEnvelope = {
    data: BullionPurchaseCreateManyBullionInput | BullionPurchaseCreateManyBullionInput[]
    skipDuplicates?: boolean
  }

  export type BullionPurchaseUpsertWithWhereUniqueWithoutBullionInput = {
    where: BullionPurchaseWhereUniqueInput
    update: XOR<BullionPurchaseUpdateWithoutBullionInput, BullionPurchaseUncheckedUpdateWithoutBullionInput>
    create: XOR<BullionPurchaseCreateWithoutBullionInput, BullionPurchaseUncheckedCreateWithoutBullionInput>
  }

  export type BullionPurchaseUpdateWithWhereUniqueWithoutBullionInput = {
    where: BullionPurchaseWhereUniqueInput
    data: XOR<BullionPurchaseUpdateWithoutBullionInput, BullionPurchaseUncheckedUpdateWithoutBullionInput>
  }

  export type BullionPurchaseUpdateManyWithWhereWithoutBullionInput = {
    where: BullionPurchaseScalarWhereInput
    data: XOR<BullionPurchaseUpdateManyMutationInput, BullionPurchaseUncheckedUpdateManyWithoutBullionInput>
  }

  export type BullionPurchaseScalarWhereInput = {
    AND?: BullionPurchaseScalarWhereInput | BullionPurchaseScalarWhereInput[]
    OR?: BullionPurchaseScalarWhereInput[]
    NOT?: BullionPurchaseScalarWhereInput | BullionPurchaseScalarWhereInput[]
    id?: IntFilter<"BullionPurchase"> | number
    bullionId?: IntFilter<"BullionPurchase"> | number
    grams?: FloatFilter<"BullionPurchase"> | number
    touch?: FloatNullableFilter<"BullionPurchase"> | number | null
    purity?: FloatNullableFilter<"BullionPurchase"> | number | null
    rate?: FloatFilter<"BullionPurchase"> | number
    amount?: FloatFilter<"BullionPurchase"> | number
    balance?: FloatFilter<"BullionPurchase"> | number
    createdAt?: DateTimeFilter<"BullionPurchase"> | Date | string
  }

  export type MasterBullionCreateWithoutPurchasesInput = {
    name: string
    phone?: string | null
    address?: string | null
  }

  export type MasterBullionUncheckedCreateWithoutPurchasesInput = {
    id?: number
    name: string
    phone?: string | null
    address?: string | null
  }

  export type MasterBullionCreateOrConnectWithoutPurchasesInput = {
    where: MasterBullionWhereUniqueInput
    create: XOR<MasterBullionCreateWithoutPurchasesInput, MasterBullionUncheckedCreateWithoutPurchasesInput>
  }

  export type GivenDetailCreateWithoutBullionPurchaseInput = {
    amount: number
    grams: number
    touch?: number | null
    purity?: number | null
  }

  export type GivenDetailUncheckedCreateWithoutBullionPurchaseInput = {
    id?: number
    amount: number
    grams: number
    touch?: number | null
    purity?: number | null
  }

  export type GivenDetailCreateOrConnectWithoutBullionPurchaseInput = {
    where: GivenDetailWhereUniqueInput
    create: XOR<GivenDetailCreateWithoutBullionPurchaseInput, GivenDetailUncheckedCreateWithoutBullionPurchaseInput>
  }

  export type GivenDetailCreateManyBullionPurchaseInputEnvelope = {
    data: GivenDetailCreateManyBullionPurchaseInput | GivenDetailCreateManyBullionPurchaseInput[]
    skipDuplicates?: boolean
  }

  export type MasterBullionUpsertWithoutPurchasesInput = {
    update: XOR<MasterBullionUpdateWithoutPurchasesInput, MasterBullionUncheckedUpdateWithoutPurchasesInput>
    create: XOR<MasterBullionCreateWithoutPurchasesInput, MasterBullionUncheckedCreateWithoutPurchasesInput>
    where?: MasterBullionWhereInput
  }

  export type MasterBullionUpdateToOneWithWhereWithoutPurchasesInput = {
    where?: MasterBullionWhereInput
    data: XOR<MasterBullionUpdateWithoutPurchasesInput, MasterBullionUncheckedUpdateWithoutPurchasesInput>
  }

  export type MasterBullionUpdateWithoutPurchasesInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MasterBullionUncheckedUpdateWithoutPurchasesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GivenDetailUpsertWithWhereUniqueWithoutBullionPurchaseInput = {
    where: GivenDetailWhereUniqueInput
    update: XOR<GivenDetailUpdateWithoutBullionPurchaseInput, GivenDetailUncheckedUpdateWithoutBullionPurchaseInput>
    create: XOR<GivenDetailCreateWithoutBullionPurchaseInput, GivenDetailUncheckedCreateWithoutBullionPurchaseInput>
  }

  export type GivenDetailUpdateWithWhereUniqueWithoutBullionPurchaseInput = {
    where: GivenDetailWhereUniqueInput
    data: XOR<GivenDetailUpdateWithoutBullionPurchaseInput, GivenDetailUncheckedUpdateWithoutBullionPurchaseInput>
  }

  export type GivenDetailUpdateManyWithWhereWithoutBullionPurchaseInput = {
    where: GivenDetailScalarWhereInput
    data: XOR<GivenDetailUpdateManyMutationInput, GivenDetailUncheckedUpdateManyWithoutBullionPurchaseInput>
  }

  export type GivenDetailScalarWhereInput = {
    AND?: GivenDetailScalarWhereInput | GivenDetailScalarWhereInput[]
    OR?: GivenDetailScalarWhereInput[]
    NOT?: GivenDetailScalarWhereInput | GivenDetailScalarWhereInput[]
    id?: IntFilter<"GivenDetail"> | number
    amount?: FloatFilter<"GivenDetail"> | number
    grams?: FloatFilter<"GivenDetail"> | number
    touch?: FloatNullableFilter<"GivenDetail"> | number | null
    purity?: FloatNullableFilter<"GivenDetail"> | number | null
    purchaseId?: IntFilter<"GivenDetail"> | number
  }

  export type BullionPurchaseCreateWithoutGivenDetailsInput = {
    grams: number
    touch?: number | null
    purity?: number | null
    rate: number
    amount: number
    balance: number
    createdAt?: Date | string
    bullion: MasterBullionCreateNestedOneWithoutPurchasesInput
  }

  export type BullionPurchaseUncheckedCreateWithoutGivenDetailsInput = {
    id?: number
    bullionId: number
    grams: number
    touch?: number | null
    purity?: number | null
    rate: number
    amount: number
    balance: number
    createdAt?: Date | string
  }

  export type BullionPurchaseCreateOrConnectWithoutGivenDetailsInput = {
    where: BullionPurchaseWhereUniqueInput
    create: XOR<BullionPurchaseCreateWithoutGivenDetailsInput, BullionPurchaseUncheckedCreateWithoutGivenDetailsInput>
  }

  export type BullionPurchaseUpsertWithoutGivenDetailsInput = {
    update: XOR<BullionPurchaseUpdateWithoutGivenDetailsInput, BullionPurchaseUncheckedUpdateWithoutGivenDetailsInput>
    create: XOR<BullionPurchaseCreateWithoutGivenDetailsInput, BullionPurchaseUncheckedCreateWithoutGivenDetailsInput>
    where?: BullionPurchaseWhereInput
  }

  export type BullionPurchaseUpdateToOneWithWhereWithoutGivenDetailsInput = {
    where?: BullionPurchaseWhereInput
    data: XOR<BullionPurchaseUpdateWithoutGivenDetailsInput, BullionPurchaseUncheckedUpdateWithoutGivenDetailsInput>
  }

  export type BullionPurchaseUpdateWithoutGivenDetailsInput = {
    grams?: FloatFieldUpdateOperationsInput | number
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bullion?: MasterBullionUpdateOneRequiredWithoutPurchasesNestedInput
  }

  export type BullionPurchaseUncheckedUpdateWithoutGivenDetailsInput = {
    id?: IntFieldUpdateOperationsInput | number
    bullionId?: IntFieldUpdateOperationsInput | number
    grams?: FloatFieldUpdateOperationsInput | number
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobcardCreateWithoutGoldsmithInput = {
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    givenGold?: givenGoldCreateNestedManyWithoutJobcardInput
    deliveries?: itemDeliveryCreateNestedManyWithoutJobcardInput
    received?: ReceivedsectionCreateNestedManyWithoutJobcardInput
  }

  export type JobcardUncheckedCreateWithoutGoldsmithInput = {
    id?: number
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    givenGold?: givenGoldUncheckedCreateNestedManyWithoutJobcardInput
    deliveries?: itemDeliveryUncheckedCreateNestedManyWithoutJobcardInput
    received?: ReceivedsectionUncheckedCreateNestedManyWithoutJobcardInput
  }

  export type JobcardCreateOrConnectWithoutGoldsmithInput = {
    where: JobcardWhereUniqueInput
    create: XOR<JobcardCreateWithoutGoldsmithInput, JobcardUncheckedCreateWithoutGoldsmithInput>
  }

  export type JobcardCreateManyGoldsmithInputEnvelope = {
    data: JobcardCreateManyGoldsmithInput | JobcardCreateManyGoldsmithInput[]
    skipDuplicates?: boolean
  }

  export type TotalCreateWithoutGoldsmithInput = {
    totalPurity: number
    openingBalance: number
    totalBalance: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TotalUncheckedCreateWithoutGoldsmithInput = {
    id?: number
    totalPurity: number
    openingBalance: number
    totalBalance: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TotalCreateOrConnectWithoutGoldsmithInput = {
    where: TotalWhereUniqueInput
    create: XOR<TotalCreateWithoutGoldsmithInput, TotalUncheckedCreateWithoutGoldsmithInput>
  }

  export type TotalCreateManyGoldsmithInputEnvelope = {
    data: TotalCreateManyGoldsmithInput | TotalCreateManyGoldsmithInput[]
    skipDuplicates?: boolean
  }

  export type givenGoldCreateWithoutGoldsmithInput = {
    weight: number
    touch: number
    purity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    jobcard?: JobcardCreateNestedOneWithoutGivenGoldInput
  }

  export type givenGoldUncheckedCreateWithoutGoldsmithInput = {
    id?: number
    jobcardId?: number | null
    weight: number
    touch: number
    purity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type givenGoldCreateOrConnectWithoutGoldsmithInput = {
    where: givenGoldWhereUniqueInput
    create: XOR<givenGoldCreateWithoutGoldsmithInput, givenGoldUncheckedCreateWithoutGoldsmithInput>
  }

  export type givenGoldCreateManyGoldsmithInputEnvelope = {
    data: givenGoldCreateManyGoldsmithInput | givenGoldCreateManyGoldsmithInput[]
    skipDuplicates?: boolean
  }

  export type itemDeliveryCreateWithoutGoldsmithInput = {
    itemName: string
    itemWeight: number
    type: string
    stoneWeight: number
    netWeight: number
    wastageType: $Enums.WastageType
    wastageValue: number
    finalPurity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    jobcard?: JobcardCreateNestedOneWithoutDeliveriesInput
  }

  export type itemDeliveryUncheckedCreateWithoutGoldsmithInput = {
    id?: number
    itemName: string
    itemWeight: number
    type: string
    stoneWeight: number
    netWeight: number
    wastageType: $Enums.WastageType
    wastageValue: number
    finalPurity: number
    jobcardId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type itemDeliveryCreateOrConnectWithoutGoldsmithInput = {
    where: itemDeliveryWhereUniqueInput
    create: XOR<itemDeliveryCreateWithoutGoldsmithInput, itemDeliveryUncheckedCreateWithoutGoldsmithInput>
  }

  export type itemDeliveryCreateManyGoldsmithInputEnvelope = {
    data: itemDeliveryCreateManyGoldsmithInput | itemDeliveryCreateManyGoldsmithInput[]
    skipDuplicates?: boolean
  }

  export type ReceivedsectionCreateWithoutGoldsmithInput = {
    weight: number
    touch: number
    purity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    jobcard?: JobcardCreateNestedOneWithoutReceivedInput
  }

  export type ReceivedsectionUncheckedCreateWithoutGoldsmithInput = {
    id?: number
    weight: number
    touch: number
    purity: number
    jobcardId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReceivedsectionCreateOrConnectWithoutGoldsmithInput = {
    where: ReceivedsectionWhereUniqueInput
    create: XOR<ReceivedsectionCreateWithoutGoldsmithInput, ReceivedsectionUncheckedCreateWithoutGoldsmithInput>
  }

  export type ReceivedsectionCreateManyGoldsmithInputEnvelope = {
    data: ReceivedsectionCreateManyGoldsmithInput | ReceivedsectionCreateManyGoldsmithInput[]
    skipDuplicates?: boolean
  }

  export type RepairCreateWithoutGoldsmithInput = {
    givenWeights: JsonNullValueInput | InputJsonValue
    totalGiven: number
    itemWeights: JsonNullValueInput | InputJsonValue
    totalItem: number
    stone: number
    wastageType: string
    touch: number
    netWeight: number
    createdAt?: Date | string
  }

  export type RepairUncheckedCreateWithoutGoldsmithInput = {
    id?: number
    givenWeights: JsonNullValueInput | InputJsonValue
    totalGiven: number
    itemWeights: JsonNullValueInput | InputJsonValue
    totalItem: number
    stone: number
    wastageType: string
    touch: number
    netWeight: number
    createdAt?: Date | string
  }

  export type RepairCreateOrConnectWithoutGoldsmithInput = {
    where: RepairWhereUniqueInput
    create: XOR<RepairCreateWithoutGoldsmithInput, RepairUncheckedCreateWithoutGoldsmithInput>
  }

  export type RepairCreateManyGoldsmithInputEnvelope = {
    data: RepairCreateManyGoldsmithInput | RepairCreateManyGoldsmithInput[]
    skipDuplicates?: boolean
  }

  export type BalancesCreateWithoutGoldsmithInput = {
    totalDeliveries: number
    totalItemWeight: number
    totalNetWeight: number
    totalPurity: number
    totalReceivedWeight: number
    totalReceivedTouch: number
    totalReceivedPurity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BalancesUncheckedCreateWithoutGoldsmithInput = {
    id?: number
    totalDeliveries: number
    totalItemWeight: number
    totalNetWeight: number
    totalPurity: number
    totalReceivedWeight: number
    totalReceivedTouch: number
    totalReceivedPurity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BalancesCreateOrConnectWithoutGoldsmithInput = {
    where: BalancesWhereUniqueInput
    create: XOR<BalancesCreateWithoutGoldsmithInput, BalancesUncheckedCreateWithoutGoldsmithInput>
  }

  export type BalancesCreateManyGoldsmithInputEnvelope = {
    data: BalancesCreateManyGoldsmithInput | BalancesCreateManyGoldsmithInput[]
    skipDuplicates?: boolean
  }

  export type JobcardUpsertWithWhereUniqueWithoutGoldsmithInput = {
    where: JobcardWhereUniqueInput
    update: XOR<JobcardUpdateWithoutGoldsmithInput, JobcardUncheckedUpdateWithoutGoldsmithInput>
    create: XOR<JobcardCreateWithoutGoldsmithInput, JobcardUncheckedCreateWithoutGoldsmithInput>
  }

  export type JobcardUpdateWithWhereUniqueWithoutGoldsmithInput = {
    where: JobcardWhereUniqueInput
    data: XOR<JobcardUpdateWithoutGoldsmithInput, JobcardUncheckedUpdateWithoutGoldsmithInput>
  }

  export type JobcardUpdateManyWithWhereWithoutGoldsmithInput = {
    where: JobcardScalarWhereInput
    data: XOR<JobcardUpdateManyMutationInput, JobcardUncheckedUpdateManyWithoutGoldsmithInput>
  }

  export type JobcardScalarWhereInput = {
    AND?: JobcardScalarWhereInput | JobcardScalarWhereInput[]
    OR?: JobcardScalarWhereInput[]
    NOT?: JobcardScalarWhereInput | JobcardScalarWhereInput[]
    id?: IntFilter<"Jobcard"> | number
    goldsmithId?: IntFilter<"Jobcard"> | number
    description?: StringFilter<"Jobcard"> | string
    createdAt?: DateTimeFilter<"Jobcard"> | Date | string
    updatedAt?: DateTimeFilter<"Jobcard"> | Date | string
  }

  export type TotalUpsertWithWhereUniqueWithoutGoldsmithInput = {
    where: TotalWhereUniqueInput
    update: XOR<TotalUpdateWithoutGoldsmithInput, TotalUncheckedUpdateWithoutGoldsmithInput>
    create: XOR<TotalCreateWithoutGoldsmithInput, TotalUncheckedCreateWithoutGoldsmithInput>
  }

  export type TotalUpdateWithWhereUniqueWithoutGoldsmithInput = {
    where: TotalWhereUniqueInput
    data: XOR<TotalUpdateWithoutGoldsmithInput, TotalUncheckedUpdateWithoutGoldsmithInput>
  }

  export type TotalUpdateManyWithWhereWithoutGoldsmithInput = {
    where: TotalScalarWhereInput
    data: XOR<TotalUpdateManyMutationInput, TotalUncheckedUpdateManyWithoutGoldsmithInput>
  }

  export type TotalScalarWhereInput = {
    AND?: TotalScalarWhereInput | TotalScalarWhereInput[]
    OR?: TotalScalarWhereInput[]
    NOT?: TotalScalarWhereInput | TotalScalarWhereInput[]
    id?: IntFilter<"Total"> | number
    goldsmithId?: IntFilter<"Total"> | number
    totalPurity?: FloatFilter<"Total"> | number
    openingBalance?: FloatFilter<"Total"> | number
    totalBalance?: FloatFilter<"Total"> | number
    createdAt?: DateTimeFilter<"Total"> | Date | string
    updatedAt?: DateTimeFilter<"Total"> | Date | string
  }

  export type givenGoldUpsertWithWhereUniqueWithoutGoldsmithInput = {
    where: givenGoldWhereUniqueInput
    update: XOR<givenGoldUpdateWithoutGoldsmithInput, givenGoldUncheckedUpdateWithoutGoldsmithInput>
    create: XOR<givenGoldCreateWithoutGoldsmithInput, givenGoldUncheckedCreateWithoutGoldsmithInput>
  }

  export type givenGoldUpdateWithWhereUniqueWithoutGoldsmithInput = {
    where: givenGoldWhereUniqueInput
    data: XOR<givenGoldUpdateWithoutGoldsmithInput, givenGoldUncheckedUpdateWithoutGoldsmithInput>
  }

  export type givenGoldUpdateManyWithWhereWithoutGoldsmithInput = {
    where: givenGoldScalarWhereInput
    data: XOR<givenGoldUpdateManyMutationInput, givenGoldUncheckedUpdateManyWithoutGoldsmithInput>
  }

  export type givenGoldScalarWhereInput = {
    AND?: givenGoldScalarWhereInput | givenGoldScalarWhereInput[]
    OR?: givenGoldScalarWhereInput[]
    NOT?: givenGoldScalarWhereInput | givenGoldScalarWhereInput[]
    id?: IntFilter<"givenGold"> | number
    goldsmithId?: IntNullableFilter<"givenGold"> | number | null
    jobcardId?: IntNullableFilter<"givenGold"> | number | null
    weight?: FloatFilter<"givenGold"> | number
    touch?: FloatFilter<"givenGold"> | number
    purity?: FloatFilter<"givenGold"> | number
    createdAt?: DateTimeFilter<"givenGold"> | Date | string
    updatedAt?: DateTimeFilter<"givenGold"> | Date | string
  }

  export type itemDeliveryUpsertWithWhereUniqueWithoutGoldsmithInput = {
    where: itemDeliveryWhereUniqueInput
    update: XOR<itemDeliveryUpdateWithoutGoldsmithInput, itemDeliveryUncheckedUpdateWithoutGoldsmithInput>
    create: XOR<itemDeliveryCreateWithoutGoldsmithInput, itemDeliveryUncheckedCreateWithoutGoldsmithInput>
  }

  export type itemDeliveryUpdateWithWhereUniqueWithoutGoldsmithInput = {
    where: itemDeliveryWhereUniqueInput
    data: XOR<itemDeliveryUpdateWithoutGoldsmithInput, itemDeliveryUncheckedUpdateWithoutGoldsmithInput>
  }

  export type itemDeliveryUpdateManyWithWhereWithoutGoldsmithInput = {
    where: itemDeliveryScalarWhereInput
    data: XOR<itemDeliveryUpdateManyMutationInput, itemDeliveryUncheckedUpdateManyWithoutGoldsmithInput>
  }

  export type itemDeliveryScalarWhereInput = {
    AND?: itemDeliveryScalarWhereInput | itemDeliveryScalarWhereInput[]
    OR?: itemDeliveryScalarWhereInput[]
    NOT?: itemDeliveryScalarWhereInput | itemDeliveryScalarWhereInput[]
    id?: IntFilter<"itemDelivery"> | number
    itemName?: StringFilter<"itemDelivery"> | string
    itemWeight?: FloatFilter<"itemDelivery"> | number
    type?: StringFilter<"itemDelivery"> | string
    stoneWeight?: FloatFilter<"itemDelivery"> | number
    netWeight?: FloatFilter<"itemDelivery"> | number
    wastageType?: EnumWastageTypeFilter<"itemDelivery"> | $Enums.WastageType
    wastageValue?: FloatFilter<"itemDelivery"> | number
    finalPurity?: FloatFilter<"itemDelivery"> | number
    goldsmithId?: IntNullableFilter<"itemDelivery"> | number | null
    jobcardId?: IntNullableFilter<"itemDelivery"> | number | null
    createdAt?: DateTimeFilter<"itemDelivery"> | Date | string
    updatedAt?: DateTimeFilter<"itemDelivery"> | Date | string
  }

  export type ReceivedsectionUpsertWithWhereUniqueWithoutGoldsmithInput = {
    where: ReceivedsectionWhereUniqueInput
    update: XOR<ReceivedsectionUpdateWithoutGoldsmithInput, ReceivedsectionUncheckedUpdateWithoutGoldsmithInput>
    create: XOR<ReceivedsectionCreateWithoutGoldsmithInput, ReceivedsectionUncheckedCreateWithoutGoldsmithInput>
  }

  export type ReceivedsectionUpdateWithWhereUniqueWithoutGoldsmithInput = {
    where: ReceivedsectionWhereUniqueInput
    data: XOR<ReceivedsectionUpdateWithoutGoldsmithInput, ReceivedsectionUncheckedUpdateWithoutGoldsmithInput>
  }

  export type ReceivedsectionUpdateManyWithWhereWithoutGoldsmithInput = {
    where: ReceivedsectionScalarWhereInput
    data: XOR<ReceivedsectionUpdateManyMutationInput, ReceivedsectionUncheckedUpdateManyWithoutGoldsmithInput>
  }

  export type ReceivedsectionScalarWhereInput = {
    AND?: ReceivedsectionScalarWhereInput | ReceivedsectionScalarWhereInput[]
    OR?: ReceivedsectionScalarWhereInput[]
    NOT?: ReceivedsectionScalarWhereInput | ReceivedsectionScalarWhereInput[]
    id?: IntFilter<"Receivedsection"> | number
    weight?: FloatFilter<"Receivedsection"> | number
    touch?: FloatFilter<"Receivedsection"> | number
    purity?: FloatFilter<"Receivedsection"> | number
    jobcardId?: IntNullableFilter<"Receivedsection"> | number | null
    goldsmithId?: IntNullableFilter<"Receivedsection"> | number | null
    createdAt?: DateTimeFilter<"Receivedsection"> | Date | string
    updatedAt?: DateTimeFilter<"Receivedsection"> | Date | string
  }

  export type RepairUpsertWithWhereUniqueWithoutGoldsmithInput = {
    where: RepairWhereUniqueInput
    update: XOR<RepairUpdateWithoutGoldsmithInput, RepairUncheckedUpdateWithoutGoldsmithInput>
    create: XOR<RepairCreateWithoutGoldsmithInput, RepairUncheckedCreateWithoutGoldsmithInput>
  }

  export type RepairUpdateWithWhereUniqueWithoutGoldsmithInput = {
    where: RepairWhereUniqueInput
    data: XOR<RepairUpdateWithoutGoldsmithInput, RepairUncheckedUpdateWithoutGoldsmithInput>
  }

  export type RepairUpdateManyWithWhereWithoutGoldsmithInput = {
    where: RepairScalarWhereInput
    data: XOR<RepairUpdateManyMutationInput, RepairUncheckedUpdateManyWithoutGoldsmithInput>
  }

  export type RepairScalarWhereInput = {
    AND?: RepairScalarWhereInput | RepairScalarWhereInput[]
    OR?: RepairScalarWhereInput[]
    NOT?: RepairScalarWhereInput | RepairScalarWhereInput[]
    id?: IntFilter<"Repair"> | number
    goldsmithId?: IntFilter<"Repair"> | number
    givenWeights?: JsonFilter<"Repair">
    totalGiven?: FloatFilter<"Repair"> | number
    itemWeights?: JsonFilter<"Repair">
    totalItem?: FloatFilter<"Repair"> | number
    stone?: FloatFilter<"Repair"> | number
    wastageType?: StringFilter<"Repair"> | string
    touch?: FloatFilter<"Repair"> | number
    netWeight?: FloatFilter<"Repair"> | number
    createdAt?: DateTimeFilter<"Repair"> | Date | string
  }

  export type BalancesUpsertWithWhereUniqueWithoutGoldsmithInput = {
    where: BalancesWhereUniqueInput
    update: XOR<BalancesUpdateWithoutGoldsmithInput, BalancesUncheckedUpdateWithoutGoldsmithInput>
    create: XOR<BalancesCreateWithoutGoldsmithInput, BalancesUncheckedCreateWithoutGoldsmithInput>
  }

  export type BalancesUpdateWithWhereUniqueWithoutGoldsmithInput = {
    where: BalancesWhereUniqueInput
    data: XOR<BalancesUpdateWithoutGoldsmithInput, BalancesUncheckedUpdateWithoutGoldsmithInput>
  }

  export type BalancesUpdateManyWithWhereWithoutGoldsmithInput = {
    where: BalancesScalarWhereInput
    data: XOR<BalancesUpdateManyMutationInput, BalancesUncheckedUpdateManyWithoutGoldsmithInput>
  }

  export type BalancesScalarWhereInput = {
    AND?: BalancesScalarWhereInput | BalancesScalarWhereInput[]
    OR?: BalancesScalarWhereInput[]
    NOT?: BalancesScalarWhereInput | BalancesScalarWhereInput[]
    id?: IntFilter<"Balances"> | number
    goldsmithId?: IntFilter<"Balances"> | number
    totalDeliveries?: IntFilter<"Balances"> | number
    totalItemWeight?: FloatFilter<"Balances"> | number
    totalNetWeight?: FloatFilter<"Balances"> | number
    totalPurity?: FloatFilter<"Balances"> | number
    totalReceivedWeight?: FloatFilter<"Balances"> | number
    totalReceivedTouch?: FloatFilter<"Balances"> | number
    totalReceivedPurity?: FloatFilter<"Balances"> | number
    createdAt?: DateTimeFilter<"Balances"> | Date | string
    updatedAt?: DateTimeFilter<"Balances"> | Date | string
  }

  export type GoldsmithCreateWithoutJobcardsInput = {
    name: string
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    totals?: TotalCreateNestedManyWithoutGoldsmithInput
    givenGold?: givenGoldCreateNestedManyWithoutGoldsmithInput
    deliveries?: itemDeliveryCreateNestedManyWithoutGoldsmithInput
    received?: ReceivedsectionCreateNestedManyWithoutGoldsmithInput
    repairs?: RepairCreateNestedManyWithoutGoldsmithInput
    summaries?: BalancesCreateNestedManyWithoutGoldsmithInput
  }

  export type GoldsmithUncheckedCreateWithoutJobcardsInput = {
    id?: number
    name: string
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    totals?: TotalUncheckedCreateNestedManyWithoutGoldsmithInput
    givenGold?: givenGoldUncheckedCreateNestedManyWithoutGoldsmithInput
    deliveries?: itemDeliveryUncheckedCreateNestedManyWithoutGoldsmithInput
    received?: ReceivedsectionUncheckedCreateNestedManyWithoutGoldsmithInput
    repairs?: RepairUncheckedCreateNestedManyWithoutGoldsmithInput
    summaries?: BalancesUncheckedCreateNestedManyWithoutGoldsmithInput
  }

  export type GoldsmithCreateOrConnectWithoutJobcardsInput = {
    where: GoldsmithWhereUniqueInput
    create: XOR<GoldsmithCreateWithoutJobcardsInput, GoldsmithUncheckedCreateWithoutJobcardsInput>
  }

  export type givenGoldCreateWithoutJobcardInput = {
    weight: number
    touch: number
    purity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    goldsmith?: GoldsmithCreateNestedOneWithoutGivenGoldInput
  }

  export type givenGoldUncheckedCreateWithoutJobcardInput = {
    id?: number
    goldsmithId?: number | null
    weight: number
    touch: number
    purity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type givenGoldCreateOrConnectWithoutJobcardInput = {
    where: givenGoldWhereUniqueInput
    create: XOR<givenGoldCreateWithoutJobcardInput, givenGoldUncheckedCreateWithoutJobcardInput>
  }

  export type givenGoldCreateManyJobcardInputEnvelope = {
    data: givenGoldCreateManyJobcardInput | givenGoldCreateManyJobcardInput[]
    skipDuplicates?: boolean
  }

  export type itemDeliveryCreateWithoutJobcardInput = {
    itemName: string
    itemWeight: number
    type: string
    stoneWeight: number
    netWeight: number
    wastageType: $Enums.WastageType
    wastageValue: number
    finalPurity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    goldsmith?: GoldsmithCreateNestedOneWithoutDeliveriesInput
  }

  export type itemDeliveryUncheckedCreateWithoutJobcardInput = {
    id?: number
    itemName: string
    itemWeight: number
    type: string
    stoneWeight: number
    netWeight: number
    wastageType: $Enums.WastageType
    wastageValue: number
    finalPurity: number
    goldsmithId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type itemDeliveryCreateOrConnectWithoutJobcardInput = {
    where: itemDeliveryWhereUniqueInput
    create: XOR<itemDeliveryCreateWithoutJobcardInput, itemDeliveryUncheckedCreateWithoutJobcardInput>
  }

  export type itemDeliveryCreateManyJobcardInputEnvelope = {
    data: itemDeliveryCreateManyJobcardInput | itemDeliveryCreateManyJobcardInput[]
    skipDuplicates?: boolean
  }

  export type ReceivedsectionCreateWithoutJobcardInput = {
    weight: number
    touch: number
    purity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    goldsmith?: GoldsmithCreateNestedOneWithoutReceivedInput
  }

  export type ReceivedsectionUncheckedCreateWithoutJobcardInput = {
    id?: number
    weight: number
    touch: number
    purity: number
    goldsmithId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReceivedsectionCreateOrConnectWithoutJobcardInput = {
    where: ReceivedsectionWhereUniqueInput
    create: XOR<ReceivedsectionCreateWithoutJobcardInput, ReceivedsectionUncheckedCreateWithoutJobcardInput>
  }

  export type ReceivedsectionCreateManyJobcardInputEnvelope = {
    data: ReceivedsectionCreateManyJobcardInput | ReceivedsectionCreateManyJobcardInput[]
    skipDuplicates?: boolean
  }

  export type GoldsmithUpsertWithoutJobcardsInput = {
    update: XOR<GoldsmithUpdateWithoutJobcardsInput, GoldsmithUncheckedUpdateWithoutJobcardsInput>
    create: XOR<GoldsmithCreateWithoutJobcardsInput, GoldsmithUncheckedCreateWithoutJobcardsInput>
    where?: GoldsmithWhereInput
  }

  export type GoldsmithUpdateToOneWithWhereWithoutJobcardsInput = {
    where?: GoldsmithWhereInput
    data: XOR<GoldsmithUpdateWithoutJobcardsInput, GoldsmithUncheckedUpdateWithoutJobcardsInput>
  }

  export type GoldsmithUpdateWithoutJobcardsInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totals?: TotalUpdateManyWithoutGoldsmithNestedInput
    givenGold?: givenGoldUpdateManyWithoutGoldsmithNestedInput
    deliveries?: itemDeliveryUpdateManyWithoutGoldsmithNestedInput
    received?: ReceivedsectionUpdateManyWithoutGoldsmithNestedInput
    repairs?: RepairUpdateManyWithoutGoldsmithNestedInput
    summaries?: BalancesUpdateManyWithoutGoldsmithNestedInput
  }

  export type GoldsmithUncheckedUpdateWithoutJobcardsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totals?: TotalUncheckedUpdateManyWithoutGoldsmithNestedInput
    givenGold?: givenGoldUncheckedUpdateManyWithoutGoldsmithNestedInput
    deliveries?: itemDeliveryUncheckedUpdateManyWithoutGoldsmithNestedInput
    received?: ReceivedsectionUncheckedUpdateManyWithoutGoldsmithNestedInput
    repairs?: RepairUncheckedUpdateManyWithoutGoldsmithNestedInput
    summaries?: BalancesUncheckedUpdateManyWithoutGoldsmithNestedInput
  }

  export type givenGoldUpsertWithWhereUniqueWithoutJobcardInput = {
    where: givenGoldWhereUniqueInput
    update: XOR<givenGoldUpdateWithoutJobcardInput, givenGoldUncheckedUpdateWithoutJobcardInput>
    create: XOR<givenGoldCreateWithoutJobcardInput, givenGoldUncheckedCreateWithoutJobcardInput>
  }

  export type givenGoldUpdateWithWhereUniqueWithoutJobcardInput = {
    where: givenGoldWhereUniqueInput
    data: XOR<givenGoldUpdateWithoutJobcardInput, givenGoldUncheckedUpdateWithoutJobcardInput>
  }

  export type givenGoldUpdateManyWithWhereWithoutJobcardInput = {
    where: givenGoldScalarWhereInput
    data: XOR<givenGoldUpdateManyMutationInput, givenGoldUncheckedUpdateManyWithoutJobcardInput>
  }

  export type itemDeliveryUpsertWithWhereUniqueWithoutJobcardInput = {
    where: itemDeliveryWhereUniqueInput
    update: XOR<itemDeliveryUpdateWithoutJobcardInput, itemDeliveryUncheckedUpdateWithoutJobcardInput>
    create: XOR<itemDeliveryCreateWithoutJobcardInput, itemDeliveryUncheckedCreateWithoutJobcardInput>
  }

  export type itemDeliveryUpdateWithWhereUniqueWithoutJobcardInput = {
    where: itemDeliveryWhereUniqueInput
    data: XOR<itemDeliveryUpdateWithoutJobcardInput, itemDeliveryUncheckedUpdateWithoutJobcardInput>
  }

  export type itemDeliveryUpdateManyWithWhereWithoutJobcardInput = {
    where: itemDeliveryScalarWhereInput
    data: XOR<itemDeliveryUpdateManyMutationInput, itemDeliveryUncheckedUpdateManyWithoutJobcardInput>
  }

  export type ReceivedsectionUpsertWithWhereUniqueWithoutJobcardInput = {
    where: ReceivedsectionWhereUniqueInput
    update: XOR<ReceivedsectionUpdateWithoutJobcardInput, ReceivedsectionUncheckedUpdateWithoutJobcardInput>
    create: XOR<ReceivedsectionCreateWithoutJobcardInput, ReceivedsectionUncheckedCreateWithoutJobcardInput>
  }

  export type ReceivedsectionUpdateWithWhereUniqueWithoutJobcardInput = {
    where: ReceivedsectionWhereUniqueInput
    data: XOR<ReceivedsectionUpdateWithoutJobcardInput, ReceivedsectionUncheckedUpdateWithoutJobcardInput>
  }

  export type ReceivedsectionUpdateManyWithWhereWithoutJobcardInput = {
    where: ReceivedsectionScalarWhereInput
    data: XOR<ReceivedsectionUpdateManyMutationInput, ReceivedsectionUncheckedUpdateManyWithoutJobcardInput>
  }

  export type GoldsmithCreateWithoutGivenGoldInput = {
    name: string
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    jobcards?: JobcardCreateNestedManyWithoutGoldsmithInput
    totals?: TotalCreateNestedManyWithoutGoldsmithInput
    deliveries?: itemDeliveryCreateNestedManyWithoutGoldsmithInput
    received?: ReceivedsectionCreateNestedManyWithoutGoldsmithInput
    repairs?: RepairCreateNestedManyWithoutGoldsmithInput
    summaries?: BalancesCreateNestedManyWithoutGoldsmithInput
  }

  export type GoldsmithUncheckedCreateWithoutGivenGoldInput = {
    id?: number
    name: string
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    jobcards?: JobcardUncheckedCreateNestedManyWithoutGoldsmithInput
    totals?: TotalUncheckedCreateNestedManyWithoutGoldsmithInput
    deliveries?: itemDeliveryUncheckedCreateNestedManyWithoutGoldsmithInput
    received?: ReceivedsectionUncheckedCreateNestedManyWithoutGoldsmithInput
    repairs?: RepairUncheckedCreateNestedManyWithoutGoldsmithInput
    summaries?: BalancesUncheckedCreateNestedManyWithoutGoldsmithInput
  }

  export type GoldsmithCreateOrConnectWithoutGivenGoldInput = {
    where: GoldsmithWhereUniqueInput
    create: XOR<GoldsmithCreateWithoutGivenGoldInput, GoldsmithUncheckedCreateWithoutGivenGoldInput>
  }

  export type JobcardCreateWithoutGivenGoldInput = {
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    goldsmith: GoldsmithCreateNestedOneWithoutJobcardsInput
    deliveries?: itemDeliveryCreateNestedManyWithoutJobcardInput
    received?: ReceivedsectionCreateNestedManyWithoutJobcardInput
  }

  export type JobcardUncheckedCreateWithoutGivenGoldInput = {
    id?: number
    goldsmithId: number
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deliveries?: itemDeliveryUncheckedCreateNestedManyWithoutJobcardInput
    received?: ReceivedsectionUncheckedCreateNestedManyWithoutJobcardInput
  }

  export type JobcardCreateOrConnectWithoutGivenGoldInput = {
    where: JobcardWhereUniqueInput
    create: XOR<JobcardCreateWithoutGivenGoldInput, JobcardUncheckedCreateWithoutGivenGoldInput>
  }

  export type GoldsmithUpsertWithoutGivenGoldInput = {
    update: XOR<GoldsmithUpdateWithoutGivenGoldInput, GoldsmithUncheckedUpdateWithoutGivenGoldInput>
    create: XOR<GoldsmithCreateWithoutGivenGoldInput, GoldsmithUncheckedCreateWithoutGivenGoldInput>
    where?: GoldsmithWhereInput
  }

  export type GoldsmithUpdateToOneWithWhereWithoutGivenGoldInput = {
    where?: GoldsmithWhereInput
    data: XOR<GoldsmithUpdateWithoutGivenGoldInput, GoldsmithUncheckedUpdateWithoutGivenGoldInput>
  }

  export type GoldsmithUpdateWithoutGivenGoldInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobcards?: JobcardUpdateManyWithoutGoldsmithNestedInput
    totals?: TotalUpdateManyWithoutGoldsmithNestedInput
    deliveries?: itemDeliveryUpdateManyWithoutGoldsmithNestedInput
    received?: ReceivedsectionUpdateManyWithoutGoldsmithNestedInput
    repairs?: RepairUpdateManyWithoutGoldsmithNestedInput
    summaries?: BalancesUpdateManyWithoutGoldsmithNestedInput
  }

  export type GoldsmithUncheckedUpdateWithoutGivenGoldInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobcards?: JobcardUncheckedUpdateManyWithoutGoldsmithNestedInput
    totals?: TotalUncheckedUpdateManyWithoutGoldsmithNestedInput
    deliveries?: itemDeliveryUncheckedUpdateManyWithoutGoldsmithNestedInput
    received?: ReceivedsectionUncheckedUpdateManyWithoutGoldsmithNestedInput
    repairs?: RepairUncheckedUpdateManyWithoutGoldsmithNestedInput
    summaries?: BalancesUncheckedUpdateManyWithoutGoldsmithNestedInput
  }

  export type JobcardUpsertWithoutGivenGoldInput = {
    update: XOR<JobcardUpdateWithoutGivenGoldInput, JobcardUncheckedUpdateWithoutGivenGoldInput>
    create: XOR<JobcardCreateWithoutGivenGoldInput, JobcardUncheckedCreateWithoutGivenGoldInput>
    where?: JobcardWhereInput
  }

  export type JobcardUpdateToOneWithWhereWithoutGivenGoldInput = {
    where?: JobcardWhereInput
    data: XOR<JobcardUpdateWithoutGivenGoldInput, JobcardUncheckedUpdateWithoutGivenGoldInput>
  }

  export type JobcardUpdateWithoutGivenGoldInput = {
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    goldsmith?: GoldsmithUpdateOneRequiredWithoutJobcardsNestedInput
    deliveries?: itemDeliveryUpdateManyWithoutJobcardNestedInput
    received?: ReceivedsectionUpdateManyWithoutJobcardNestedInput
  }

  export type JobcardUncheckedUpdateWithoutGivenGoldInput = {
    id?: IntFieldUpdateOperationsInput | number
    goldsmithId?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveries?: itemDeliveryUncheckedUpdateManyWithoutJobcardNestedInput
    received?: ReceivedsectionUncheckedUpdateManyWithoutJobcardNestedInput
  }

  export type GoldsmithCreateWithoutTotalsInput = {
    name: string
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    jobcards?: JobcardCreateNestedManyWithoutGoldsmithInput
    givenGold?: givenGoldCreateNestedManyWithoutGoldsmithInput
    deliveries?: itemDeliveryCreateNestedManyWithoutGoldsmithInput
    received?: ReceivedsectionCreateNestedManyWithoutGoldsmithInput
    repairs?: RepairCreateNestedManyWithoutGoldsmithInput
    summaries?: BalancesCreateNestedManyWithoutGoldsmithInput
  }

  export type GoldsmithUncheckedCreateWithoutTotalsInput = {
    id?: number
    name: string
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    jobcards?: JobcardUncheckedCreateNestedManyWithoutGoldsmithInput
    givenGold?: givenGoldUncheckedCreateNestedManyWithoutGoldsmithInput
    deliveries?: itemDeliveryUncheckedCreateNestedManyWithoutGoldsmithInput
    received?: ReceivedsectionUncheckedCreateNestedManyWithoutGoldsmithInput
    repairs?: RepairUncheckedCreateNestedManyWithoutGoldsmithInput
    summaries?: BalancesUncheckedCreateNestedManyWithoutGoldsmithInput
  }

  export type GoldsmithCreateOrConnectWithoutTotalsInput = {
    where: GoldsmithWhereUniqueInput
    create: XOR<GoldsmithCreateWithoutTotalsInput, GoldsmithUncheckedCreateWithoutTotalsInput>
  }

  export type GoldsmithUpsertWithoutTotalsInput = {
    update: XOR<GoldsmithUpdateWithoutTotalsInput, GoldsmithUncheckedUpdateWithoutTotalsInput>
    create: XOR<GoldsmithCreateWithoutTotalsInput, GoldsmithUncheckedCreateWithoutTotalsInput>
    where?: GoldsmithWhereInput
  }

  export type GoldsmithUpdateToOneWithWhereWithoutTotalsInput = {
    where?: GoldsmithWhereInput
    data: XOR<GoldsmithUpdateWithoutTotalsInput, GoldsmithUncheckedUpdateWithoutTotalsInput>
  }

  export type GoldsmithUpdateWithoutTotalsInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobcards?: JobcardUpdateManyWithoutGoldsmithNestedInput
    givenGold?: givenGoldUpdateManyWithoutGoldsmithNestedInput
    deliveries?: itemDeliveryUpdateManyWithoutGoldsmithNestedInput
    received?: ReceivedsectionUpdateManyWithoutGoldsmithNestedInput
    repairs?: RepairUpdateManyWithoutGoldsmithNestedInput
    summaries?: BalancesUpdateManyWithoutGoldsmithNestedInput
  }

  export type GoldsmithUncheckedUpdateWithoutTotalsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobcards?: JobcardUncheckedUpdateManyWithoutGoldsmithNestedInput
    givenGold?: givenGoldUncheckedUpdateManyWithoutGoldsmithNestedInput
    deliveries?: itemDeliveryUncheckedUpdateManyWithoutGoldsmithNestedInput
    received?: ReceivedsectionUncheckedUpdateManyWithoutGoldsmithNestedInput
    repairs?: RepairUncheckedUpdateManyWithoutGoldsmithNestedInput
    summaries?: BalancesUncheckedUpdateManyWithoutGoldsmithNestedInput
  }

  export type GoldsmithCreateWithoutDeliveriesInput = {
    name: string
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    jobcards?: JobcardCreateNestedManyWithoutGoldsmithInput
    totals?: TotalCreateNestedManyWithoutGoldsmithInput
    givenGold?: givenGoldCreateNestedManyWithoutGoldsmithInput
    received?: ReceivedsectionCreateNestedManyWithoutGoldsmithInput
    repairs?: RepairCreateNestedManyWithoutGoldsmithInput
    summaries?: BalancesCreateNestedManyWithoutGoldsmithInput
  }

  export type GoldsmithUncheckedCreateWithoutDeliveriesInput = {
    id?: number
    name: string
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    jobcards?: JobcardUncheckedCreateNestedManyWithoutGoldsmithInput
    totals?: TotalUncheckedCreateNestedManyWithoutGoldsmithInput
    givenGold?: givenGoldUncheckedCreateNestedManyWithoutGoldsmithInput
    received?: ReceivedsectionUncheckedCreateNestedManyWithoutGoldsmithInput
    repairs?: RepairUncheckedCreateNestedManyWithoutGoldsmithInput
    summaries?: BalancesUncheckedCreateNestedManyWithoutGoldsmithInput
  }

  export type GoldsmithCreateOrConnectWithoutDeliveriesInput = {
    where: GoldsmithWhereUniqueInput
    create: XOR<GoldsmithCreateWithoutDeliveriesInput, GoldsmithUncheckedCreateWithoutDeliveriesInput>
  }

  export type JobcardCreateWithoutDeliveriesInput = {
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    goldsmith: GoldsmithCreateNestedOneWithoutJobcardsInput
    givenGold?: givenGoldCreateNestedManyWithoutJobcardInput
    received?: ReceivedsectionCreateNestedManyWithoutJobcardInput
  }

  export type JobcardUncheckedCreateWithoutDeliveriesInput = {
    id?: number
    goldsmithId: number
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    givenGold?: givenGoldUncheckedCreateNestedManyWithoutJobcardInput
    received?: ReceivedsectionUncheckedCreateNestedManyWithoutJobcardInput
  }

  export type JobcardCreateOrConnectWithoutDeliveriesInput = {
    where: JobcardWhereUniqueInput
    create: XOR<JobcardCreateWithoutDeliveriesInput, JobcardUncheckedCreateWithoutDeliveriesInput>
  }

  export type GoldsmithUpsertWithoutDeliveriesInput = {
    update: XOR<GoldsmithUpdateWithoutDeliveriesInput, GoldsmithUncheckedUpdateWithoutDeliveriesInput>
    create: XOR<GoldsmithCreateWithoutDeliveriesInput, GoldsmithUncheckedCreateWithoutDeliveriesInput>
    where?: GoldsmithWhereInput
  }

  export type GoldsmithUpdateToOneWithWhereWithoutDeliveriesInput = {
    where?: GoldsmithWhereInput
    data: XOR<GoldsmithUpdateWithoutDeliveriesInput, GoldsmithUncheckedUpdateWithoutDeliveriesInput>
  }

  export type GoldsmithUpdateWithoutDeliveriesInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobcards?: JobcardUpdateManyWithoutGoldsmithNestedInput
    totals?: TotalUpdateManyWithoutGoldsmithNestedInput
    givenGold?: givenGoldUpdateManyWithoutGoldsmithNestedInput
    received?: ReceivedsectionUpdateManyWithoutGoldsmithNestedInput
    repairs?: RepairUpdateManyWithoutGoldsmithNestedInput
    summaries?: BalancesUpdateManyWithoutGoldsmithNestedInput
  }

  export type GoldsmithUncheckedUpdateWithoutDeliveriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobcards?: JobcardUncheckedUpdateManyWithoutGoldsmithNestedInput
    totals?: TotalUncheckedUpdateManyWithoutGoldsmithNestedInput
    givenGold?: givenGoldUncheckedUpdateManyWithoutGoldsmithNestedInput
    received?: ReceivedsectionUncheckedUpdateManyWithoutGoldsmithNestedInput
    repairs?: RepairUncheckedUpdateManyWithoutGoldsmithNestedInput
    summaries?: BalancesUncheckedUpdateManyWithoutGoldsmithNestedInput
  }

  export type JobcardUpsertWithoutDeliveriesInput = {
    update: XOR<JobcardUpdateWithoutDeliveriesInput, JobcardUncheckedUpdateWithoutDeliveriesInput>
    create: XOR<JobcardCreateWithoutDeliveriesInput, JobcardUncheckedCreateWithoutDeliveriesInput>
    where?: JobcardWhereInput
  }

  export type JobcardUpdateToOneWithWhereWithoutDeliveriesInput = {
    where?: JobcardWhereInput
    data: XOR<JobcardUpdateWithoutDeliveriesInput, JobcardUncheckedUpdateWithoutDeliveriesInput>
  }

  export type JobcardUpdateWithoutDeliveriesInput = {
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    goldsmith?: GoldsmithUpdateOneRequiredWithoutJobcardsNestedInput
    givenGold?: givenGoldUpdateManyWithoutJobcardNestedInput
    received?: ReceivedsectionUpdateManyWithoutJobcardNestedInput
  }

  export type JobcardUncheckedUpdateWithoutDeliveriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    goldsmithId?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    givenGold?: givenGoldUncheckedUpdateManyWithoutJobcardNestedInput
    received?: ReceivedsectionUncheckedUpdateManyWithoutJobcardNestedInput
  }

  export type JobcardCreateWithoutReceivedInput = {
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    goldsmith: GoldsmithCreateNestedOneWithoutJobcardsInput
    givenGold?: givenGoldCreateNestedManyWithoutJobcardInput
    deliveries?: itemDeliveryCreateNestedManyWithoutJobcardInput
  }

  export type JobcardUncheckedCreateWithoutReceivedInput = {
    id?: number
    goldsmithId: number
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    givenGold?: givenGoldUncheckedCreateNestedManyWithoutJobcardInput
    deliveries?: itemDeliveryUncheckedCreateNestedManyWithoutJobcardInput
  }

  export type JobcardCreateOrConnectWithoutReceivedInput = {
    where: JobcardWhereUniqueInput
    create: XOR<JobcardCreateWithoutReceivedInput, JobcardUncheckedCreateWithoutReceivedInput>
  }

  export type GoldsmithCreateWithoutReceivedInput = {
    name: string
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    jobcards?: JobcardCreateNestedManyWithoutGoldsmithInput
    totals?: TotalCreateNestedManyWithoutGoldsmithInput
    givenGold?: givenGoldCreateNestedManyWithoutGoldsmithInput
    deliveries?: itemDeliveryCreateNestedManyWithoutGoldsmithInput
    repairs?: RepairCreateNestedManyWithoutGoldsmithInput
    summaries?: BalancesCreateNestedManyWithoutGoldsmithInput
  }

  export type GoldsmithUncheckedCreateWithoutReceivedInput = {
    id?: number
    name: string
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    jobcards?: JobcardUncheckedCreateNestedManyWithoutGoldsmithInput
    totals?: TotalUncheckedCreateNestedManyWithoutGoldsmithInput
    givenGold?: givenGoldUncheckedCreateNestedManyWithoutGoldsmithInput
    deliveries?: itemDeliveryUncheckedCreateNestedManyWithoutGoldsmithInput
    repairs?: RepairUncheckedCreateNestedManyWithoutGoldsmithInput
    summaries?: BalancesUncheckedCreateNestedManyWithoutGoldsmithInput
  }

  export type GoldsmithCreateOrConnectWithoutReceivedInput = {
    where: GoldsmithWhereUniqueInput
    create: XOR<GoldsmithCreateWithoutReceivedInput, GoldsmithUncheckedCreateWithoutReceivedInput>
  }

  export type JobcardUpsertWithoutReceivedInput = {
    update: XOR<JobcardUpdateWithoutReceivedInput, JobcardUncheckedUpdateWithoutReceivedInput>
    create: XOR<JobcardCreateWithoutReceivedInput, JobcardUncheckedCreateWithoutReceivedInput>
    where?: JobcardWhereInput
  }

  export type JobcardUpdateToOneWithWhereWithoutReceivedInput = {
    where?: JobcardWhereInput
    data: XOR<JobcardUpdateWithoutReceivedInput, JobcardUncheckedUpdateWithoutReceivedInput>
  }

  export type JobcardUpdateWithoutReceivedInput = {
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    goldsmith?: GoldsmithUpdateOneRequiredWithoutJobcardsNestedInput
    givenGold?: givenGoldUpdateManyWithoutJobcardNestedInput
    deliveries?: itemDeliveryUpdateManyWithoutJobcardNestedInput
  }

  export type JobcardUncheckedUpdateWithoutReceivedInput = {
    id?: IntFieldUpdateOperationsInput | number
    goldsmithId?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    givenGold?: givenGoldUncheckedUpdateManyWithoutJobcardNestedInput
    deliveries?: itemDeliveryUncheckedUpdateManyWithoutJobcardNestedInput
  }

  export type GoldsmithUpsertWithoutReceivedInput = {
    update: XOR<GoldsmithUpdateWithoutReceivedInput, GoldsmithUncheckedUpdateWithoutReceivedInput>
    create: XOR<GoldsmithCreateWithoutReceivedInput, GoldsmithUncheckedCreateWithoutReceivedInput>
    where?: GoldsmithWhereInput
  }

  export type GoldsmithUpdateToOneWithWhereWithoutReceivedInput = {
    where?: GoldsmithWhereInput
    data: XOR<GoldsmithUpdateWithoutReceivedInput, GoldsmithUncheckedUpdateWithoutReceivedInput>
  }

  export type GoldsmithUpdateWithoutReceivedInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobcards?: JobcardUpdateManyWithoutGoldsmithNestedInput
    totals?: TotalUpdateManyWithoutGoldsmithNestedInput
    givenGold?: givenGoldUpdateManyWithoutGoldsmithNestedInput
    deliveries?: itemDeliveryUpdateManyWithoutGoldsmithNestedInput
    repairs?: RepairUpdateManyWithoutGoldsmithNestedInput
    summaries?: BalancesUpdateManyWithoutGoldsmithNestedInput
  }

  export type GoldsmithUncheckedUpdateWithoutReceivedInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobcards?: JobcardUncheckedUpdateManyWithoutGoldsmithNestedInput
    totals?: TotalUncheckedUpdateManyWithoutGoldsmithNestedInput
    givenGold?: givenGoldUncheckedUpdateManyWithoutGoldsmithNestedInput
    deliveries?: itemDeliveryUncheckedUpdateManyWithoutGoldsmithNestedInput
    repairs?: RepairUncheckedUpdateManyWithoutGoldsmithNestedInput
    summaries?: BalancesUncheckedUpdateManyWithoutGoldsmithNestedInput
  }

  export type GoldsmithCreateWithoutSummariesInput = {
    name: string
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    jobcards?: JobcardCreateNestedManyWithoutGoldsmithInput
    totals?: TotalCreateNestedManyWithoutGoldsmithInput
    givenGold?: givenGoldCreateNestedManyWithoutGoldsmithInput
    deliveries?: itemDeliveryCreateNestedManyWithoutGoldsmithInput
    received?: ReceivedsectionCreateNestedManyWithoutGoldsmithInput
    repairs?: RepairCreateNestedManyWithoutGoldsmithInput
  }

  export type GoldsmithUncheckedCreateWithoutSummariesInput = {
    id?: number
    name: string
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    jobcards?: JobcardUncheckedCreateNestedManyWithoutGoldsmithInput
    totals?: TotalUncheckedCreateNestedManyWithoutGoldsmithInput
    givenGold?: givenGoldUncheckedCreateNestedManyWithoutGoldsmithInput
    deliveries?: itemDeliveryUncheckedCreateNestedManyWithoutGoldsmithInput
    received?: ReceivedsectionUncheckedCreateNestedManyWithoutGoldsmithInput
    repairs?: RepairUncheckedCreateNestedManyWithoutGoldsmithInput
  }

  export type GoldsmithCreateOrConnectWithoutSummariesInput = {
    where: GoldsmithWhereUniqueInput
    create: XOR<GoldsmithCreateWithoutSummariesInput, GoldsmithUncheckedCreateWithoutSummariesInput>
  }

  export type GoldsmithUpsertWithoutSummariesInput = {
    update: XOR<GoldsmithUpdateWithoutSummariesInput, GoldsmithUncheckedUpdateWithoutSummariesInput>
    create: XOR<GoldsmithCreateWithoutSummariesInput, GoldsmithUncheckedCreateWithoutSummariesInput>
    where?: GoldsmithWhereInput
  }

  export type GoldsmithUpdateToOneWithWhereWithoutSummariesInput = {
    where?: GoldsmithWhereInput
    data: XOR<GoldsmithUpdateWithoutSummariesInput, GoldsmithUncheckedUpdateWithoutSummariesInput>
  }

  export type GoldsmithUpdateWithoutSummariesInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobcards?: JobcardUpdateManyWithoutGoldsmithNestedInput
    totals?: TotalUpdateManyWithoutGoldsmithNestedInput
    givenGold?: givenGoldUpdateManyWithoutGoldsmithNestedInput
    deliveries?: itemDeliveryUpdateManyWithoutGoldsmithNestedInput
    received?: ReceivedsectionUpdateManyWithoutGoldsmithNestedInput
    repairs?: RepairUpdateManyWithoutGoldsmithNestedInput
  }

  export type GoldsmithUncheckedUpdateWithoutSummariesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobcards?: JobcardUncheckedUpdateManyWithoutGoldsmithNestedInput
    totals?: TotalUncheckedUpdateManyWithoutGoldsmithNestedInput
    givenGold?: givenGoldUncheckedUpdateManyWithoutGoldsmithNestedInput
    deliveries?: itemDeliveryUncheckedUpdateManyWithoutGoldsmithNestedInput
    received?: ReceivedsectionUncheckedUpdateManyWithoutGoldsmithNestedInput
    repairs?: RepairUncheckedUpdateManyWithoutGoldsmithNestedInput
  }

  export type GoldsmithCreateWithoutRepairsInput = {
    name: string
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    jobcards?: JobcardCreateNestedManyWithoutGoldsmithInput
    totals?: TotalCreateNestedManyWithoutGoldsmithInput
    givenGold?: givenGoldCreateNestedManyWithoutGoldsmithInput
    deliveries?: itemDeliveryCreateNestedManyWithoutGoldsmithInput
    received?: ReceivedsectionCreateNestedManyWithoutGoldsmithInput
    summaries?: BalancesCreateNestedManyWithoutGoldsmithInput
  }

  export type GoldsmithUncheckedCreateWithoutRepairsInput = {
    id?: number
    name: string
    phone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    jobcards?: JobcardUncheckedCreateNestedManyWithoutGoldsmithInput
    totals?: TotalUncheckedCreateNestedManyWithoutGoldsmithInput
    givenGold?: givenGoldUncheckedCreateNestedManyWithoutGoldsmithInput
    deliveries?: itemDeliveryUncheckedCreateNestedManyWithoutGoldsmithInput
    received?: ReceivedsectionUncheckedCreateNestedManyWithoutGoldsmithInput
    summaries?: BalancesUncheckedCreateNestedManyWithoutGoldsmithInput
  }

  export type GoldsmithCreateOrConnectWithoutRepairsInput = {
    where: GoldsmithWhereUniqueInput
    create: XOR<GoldsmithCreateWithoutRepairsInput, GoldsmithUncheckedCreateWithoutRepairsInput>
  }

  export type GoldsmithUpsertWithoutRepairsInput = {
    update: XOR<GoldsmithUpdateWithoutRepairsInput, GoldsmithUncheckedUpdateWithoutRepairsInput>
    create: XOR<GoldsmithCreateWithoutRepairsInput, GoldsmithUncheckedCreateWithoutRepairsInput>
    where?: GoldsmithWhereInput
  }

  export type GoldsmithUpdateToOneWithWhereWithoutRepairsInput = {
    where?: GoldsmithWhereInput
    data: XOR<GoldsmithUpdateWithoutRepairsInput, GoldsmithUncheckedUpdateWithoutRepairsInput>
  }

  export type GoldsmithUpdateWithoutRepairsInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobcards?: JobcardUpdateManyWithoutGoldsmithNestedInput
    totals?: TotalUpdateManyWithoutGoldsmithNestedInput
    givenGold?: givenGoldUpdateManyWithoutGoldsmithNestedInput
    deliveries?: itemDeliveryUpdateManyWithoutGoldsmithNestedInput
    received?: ReceivedsectionUpdateManyWithoutGoldsmithNestedInput
    summaries?: BalancesUpdateManyWithoutGoldsmithNestedInput
  }

  export type GoldsmithUncheckedUpdateWithoutRepairsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobcards?: JobcardUncheckedUpdateManyWithoutGoldsmithNestedInput
    totals?: TotalUncheckedUpdateManyWithoutGoldsmithNestedInput
    givenGold?: givenGoldUncheckedUpdateManyWithoutGoldsmithNestedInput
    deliveries?: itemDeliveryUncheckedUpdateManyWithoutGoldsmithNestedInput
    received?: ReceivedsectionUncheckedUpdateManyWithoutGoldsmithNestedInput
    summaries?: BalancesUncheckedUpdateManyWithoutGoldsmithNestedInput
  }

  export type TransactionCreateManyCustomerInput = {
    id?: number
    date: Date | string
    type: string
    value: number
    goldRate?: number | null
    purity: number
    touch?: number | null
    createdAt?: Date | string
  }

  export type customer_orderCreateManyCustomersInput = {
    id?: number
    order_group_id: number
    item_name: string
    description: string
    weight: number
    image?: string | null
    due_date?: Date | string | null
    status?: string
    worker_name?: string | null
    created_at?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionUpdateWithoutCustomerInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    goldRate?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: FloatFieldUpdateOperationsInput | number
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    goldRate?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: FloatFieldUpdateOperationsInput | number
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    goldRate?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: FloatFieldUpdateOperationsInput | number
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type customer_orderUpdateWithoutCustomersInput = {
    order_group_id?: IntFieldUpdateOperationsInput | number
    item_name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    weight?: FloatFieldUpdateOperationsInput | number
    image?: NullableStringFieldUpdateOperationsInput | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    worker_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productImages?: product_multiple_imagesUpdateManyWithoutCustomerOrderDetailsNestedInput
  }

  export type customer_orderUncheckedUpdateWithoutCustomersInput = {
    id?: IntFieldUpdateOperationsInput | number
    order_group_id?: IntFieldUpdateOperationsInput | number
    item_name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    weight?: FloatFieldUpdateOperationsInput | number
    image?: NullableStringFieldUpdateOperationsInput | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    worker_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productImages?: product_multiple_imagesUncheckedUpdateManyWithoutCustomerOrderDetailsNestedInput
  }

  export type customer_orderUncheckedUpdateManyWithoutCustomersInput = {
    id?: IntFieldUpdateOperationsInput | number
    order_group_id?: IntFieldUpdateOperationsInput | number
    item_name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    weight?: FloatFieldUpdateOperationsInput | number
    image?: NullableStringFieldUpdateOperationsInput | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    worker_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type product_multiple_imagesCreateManyCustomerOrderDetailsInput = {
    id?: number
    filename: string
  }

  export type product_multiple_imagesUpdateWithoutCustomerOrderDetailsInput = {
    filename?: StringFieldUpdateOperationsInput | string
  }

  export type product_multiple_imagesUncheckedUpdateWithoutCustomerOrderDetailsInput = {
    id?: IntFieldUpdateOperationsInput | number
    filename?: StringFieldUpdateOperationsInput | string
  }

  export type product_multiple_imagesUncheckedUpdateManyWithoutCustomerOrderDetailsInput = {
    id?: IntFieldUpdateOperationsInput | number
    filename?: StringFieldUpdateOperationsInput | string
  }

  export type BullionPurchaseCreateManyBullionInput = {
    id?: number
    grams: number
    touch?: number | null
    purity?: number | null
    rate: number
    amount: number
    balance: number
    createdAt?: Date | string
  }

  export type BullionPurchaseUpdateWithoutBullionInput = {
    grams?: FloatFieldUpdateOperationsInput | number
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    givenDetails?: GivenDetailUpdateManyWithoutBullionPurchaseNestedInput
  }

  export type BullionPurchaseUncheckedUpdateWithoutBullionInput = {
    id?: IntFieldUpdateOperationsInput | number
    grams?: FloatFieldUpdateOperationsInput | number
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    givenDetails?: GivenDetailUncheckedUpdateManyWithoutBullionPurchaseNestedInput
  }

  export type BullionPurchaseUncheckedUpdateManyWithoutBullionInput = {
    id?: IntFieldUpdateOperationsInput | number
    grams?: FloatFieldUpdateOperationsInput | number
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GivenDetailCreateManyBullionPurchaseInput = {
    id?: number
    amount: number
    grams: number
    touch?: number | null
    purity?: number | null
  }

  export type GivenDetailUpdateWithoutBullionPurchaseInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    grams?: FloatFieldUpdateOperationsInput | number
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type GivenDetailUncheckedUpdateWithoutBullionPurchaseInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    grams?: FloatFieldUpdateOperationsInput | number
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type GivenDetailUncheckedUpdateManyWithoutBullionPurchaseInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    grams?: FloatFieldUpdateOperationsInput | number
    touch?: NullableFloatFieldUpdateOperationsInput | number | null
    purity?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type JobcardCreateManyGoldsmithInput = {
    id?: number
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TotalCreateManyGoldsmithInput = {
    id?: number
    totalPurity: number
    openingBalance: number
    totalBalance: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type givenGoldCreateManyGoldsmithInput = {
    id?: number
    jobcardId?: number | null
    weight: number
    touch: number
    purity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type itemDeliveryCreateManyGoldsmithInput = {
    id?: number
    itemName: string
    itemWeight: number
    type: string
    stoneWeight: number
    netWeight: number
    wastageType: $Enums.WastageType
    wastageValue: number
    finalPurity: number
    jobcardId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReceivedsectionCreateManyGoldsmithInput = {
    id?: number
    weight: number
    touch: number
    purity: number
    jobcardId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RepairCreateManyGoldsmithInput = {
    id?: number
    givenWeights: JsonNullValueInput | InputJsonValue
    totalGiven: number
    itemWeights: JsonNullValueInput | InputJsonValue
    totalItem: number
    stone: number
    wastageType: string
    touch: number
    netWeight: number
    createdAt?: Date | string
  }

  export type BalancesCreateManyGoldsmithInput = {
    id?: number
    totalDeliveries: number
    totalItemWeight: number
    totalNetWeight: number
    totalPurity: number
    totalReceivedWeight: number
    totalReceivedTouch: number
    totalReceivedPurity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JobcardUpdateWithoutGoldsmithInput = {
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    givenGold?: givenGoldUpdateManyWithoutJobcardNestedInput
    deliveries?: itemDeliveryUpdateManyWithoutJobcardNestedInput
    received?: ReceivedsectionUpdateManyWithoutJobcardNestedInput
  }

  export type JobcardUncheckedUpdateWithoutGoldsmithInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    givenGold?: givenGoldUncheckedUpdateManyWithoutJobcardNestedInput
    deliveries?: itemDeliveryUncheckedUpdateManyWithoutJobcardNestedInput
    received?: ReceivedsectionUncheckedUpdateManyWithoutJobcardNestedInput
  }

  export type JobcardUncheckedUpdateManyWithoutGoldsmithInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TotalUpdateWithoutGoldsmithInput = {
    totalPurity?: FloatFieldUpdateOperationsInput | number
    openingBalance?: FloatFieldUpdateOperationsInput | number
    totalBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TotalUncheckedUpdateWithoutGoldsmithInput = {
    id?: IntFieldUpdateOperationsInput | number
    totalPurity?: FloatFieldUpdateOperationsInput | number
    openingBalance?: FloatFieldUpdateOperationsInput | number
    totalBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TotalUncheckedUpdateManyWithoutGoldsmithInput = {
    id?: IntFieldUpdateOperationsInput | number
    totalPurity?: FloatFieldUpdateOperationsInput | number
    openingBalance?: FloatFieldUpdateOperationsInput | number
    totalBalance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type givenGoldUpdateWithoutGoldsmithInput = {
    weight?: FloatFieldUpdateOperationsInput | number
    touch?: FloatFieldUpdateOperationsInput | number
    purity?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobcard?: JobcardUpdateOneWithoutGivenGoldNestedInput
  }

  export type givenGoldUncheckedUpdateWithoutGoldsmithInput = {
    id?: IntFieldUpdateOperationsInput | number
    jobcardId?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: FloatFieldUpdateOperationsInput | number
    touch?: FloatFieldUpdateOperationsInput | number
    purity?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type givenGoldUncheckedUpdateManyWithoutGoldsmithInput = {
    id?: IntFieldUpdateOperationsInput | number
    jobcardId?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: FloatFieldUpdateOperationsInput | number
    touch?: FloatFieldUpdateOperationsInput | number
    purity?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type itemDeliveryUpdateWithoutGoldsmithInput = {
    itemName?: StringFieldUpdateOperationsInput | string
    itemWeight?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    stoneWeight?: FloatFieldUpdateOperationsInput | number
    netWeight?: FloatFieldUpdateOperationsInput | number
    wastageType?: EnumWastageTypeFieldUpdateOperationsInput | $Enums.WastageType
    wastageValue?: FloatFieldUpdateOperationsInput | number
    finalPurity?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobcard?: JobcardUpdateOneWithoutDeliveriesNestedInput
  }

  export type itemDeliveryUncheckedUpdateWithoutGoldsmithInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemName?: StringFieldUpdateOperationsInput | string
    itemWeight?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    stoneWeight?: FloatFieldUpdateOperationsInput | number
    netWeight?: FloatFieldUpdateOperationsInput | number
    wastageType?: EnumWastageTypeFieldUpdateOperationsInput | $Enums.WastageType
    wastageValue?: FloatFieldUpdateOperationsInput | number
    finalPurity?: FloatFieldUpdateOperationsInput | number
    jobcardId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type itemDeliveryUncheckedUpdateManyWithoutGoldsmithInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemName?: StringFieldUpdateOperationsInput | string
    itemWeight?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    stoneWeight?: FloatFieldUpdateOperationsInput | number
    netWeight?: FloatFieldUpdateOperationsInput | number
    wastageType?: EnumWastageTypeFieldUpdateOperationsInput | $Enums.WastageType
    wastageValue?: FloatFieldUpdateOperationsInput | number
    finalPurity?: FloatFieldUpdateOperationsInput | number
    jobcardId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReceivedsectionUpdateWithoutGoldsmithInput = {
    weight?: FloatFieldUpdateOperationsInput | number
    touch?: FloatFieldUpdateOperationsInput | number
    purity?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobcard?: JobcardUpdateOneWithoutReceivedNestedInput
  }

  export type ReceivedsectionUncheckedUpdateWithoutGoldsmithInput = {
    id?: IntFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    touch?: FloatFieldUpdateOperationsInput | number
    purity?: FloatFieldUpdateOperationsInput | number
    jobcardId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReceivedsectionUncheckedUpdateManyWithoutGoldsmithInput = {
    id?: IntFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    touch?: FloatFieldUpdateOperationsInput | number
    purity?: FloatFieldUpdateOperationsInput | number
    jobcardId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RepairUpdateWithoutGoldsmithInput = {
    givenWeights?: JsonNullValueInput | InputJsonValue
    totalGiven?: FloatFieldUpdateOperationsInput | number
    itemWeights?: JsonNullValueInput | InputJsonValue
    totalItem?: FloatFieldUpdateOperationsInput | number
    stone?: FloatFieldUpdateOperationsInput | number
    wastageType?: StringFieldUpdateOperationsInput | string
    touch?: FloatFieldUpdateOperationsInput | number
    netWeight?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RepairUncheckedUpdateWithoutGoldsmithInput = {
    id?: IntFieldUpdateOperationsInput | number
    givenWeights?: JsonNullValueInput | InputJsonValue
    totalGiven?: FloatFieldUpdateOperationsInput | number
    itemWeights?: JsonNullValueInput | InputJsonValue
    totalItem?: FloatFieldUpdateOperationsInput | number
    stone?: FloatFieldUpdateOperationsInput | number
    wastageType?: StringFieldUpdateOperationsInput | string
    touch?: FloatFieldUpdateOperationsInput | number
    netWeight?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RepairUncheckedUpdateManyWithoutGoldsmithInput = {
    id?: IntFieldUpdateOperationsInput | number
    givenWeights?: JsonNullValueInput | InputJsonValue
    totalGiven?: FloatFieldUpdateOperationsInput | number
    itemWeights?: JsonNullValueInput | InputJsonValue
    totalItem?: FloatFieldUpdateOperationsInput | number
    stone?: FloatFieldUpdateOperationsInput | number
    wastageType?: StringFieldUpdateOperationsInput | string
    touch?: FloatFieldUpdateOperationsInput | number
    netWeight?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BalancesUpdateWithoutGoldsmithInput = {
    totalDeliveries?: IntFieldUpdateOperationsInput | number
    totalItemWeight?: FloatFieldUpdateOperationsInput | number
    totalNetWeight?: FloatFieldUpdateOperationsInput | number
    totalPurity?: FloatFieldUpdateOperationsInput | number
    totalReceivedWeight?: FloatFieldUpdateOperationsInput | number
    totalReceivedTouch?: FloatFieldUpdateOperationsInput | number
    totalReceivedPurity?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BalancesUncheckedUpdateWithoutGoldsmithInput = {
    id?: IntFieldUpdateOperationsInput | number
    totalDeliveries?: IntFieldUpdateOperationsInput | number
    totalItemWeight?: FloatFieldUpdateOperationsInput | number
    totalNetWeight?: FloatFieldUpdateOperationsInput | number
    totalPurity?: FloatFieldUpdateOperationsInput | number
    totalReceivedWeight?: FloatFieldUpdateOperationsInput | number
    totalReceivedTouch?: FloatFieldUpdateOperationsInput | number
    totalReceivedPurity?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BalancesUncheckedUpdateManyWithoutGoldsmithInput = {
    id?: IntFieldUpdateOperationsInput | number
    totalDeliveries?: IntFieldUpdateOperationsInput | number
    totalItemWeight?: FloatFieldUpdateOperationsInput | number
    totalNetWeight?: FloatFieldUpdateOperationsInput | number
    totalPurity?: FloatFieldUpdateOperationsInput | number
    totalReceivedWeight?: FloatFieldUpdateOperationsInput | number
    totalReceivedTouch?: FloatFieldUpdateOperationsInput | number
    totalReceivedPurity?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type givenGoldCreateManyJobcardInput = {
    id?: number
    goldsmithId?: number | null
    weight: number
    touch: number
    purity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type itemDeliveryCreateManyJobcardInput = {
    id?: number
    itemName: string
    itemWeight: number
    type: string
    stoneWeight: number
    netWeight: number
    wastageType: $Enums.WastageType
    wastageValue: number
    finalPurity: number
    goldsmithId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReceivedsectionCreateManyJobcardInput = {
    id?: number
    weight: number
    touch: number
    purity: number
    goldsmithId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type givenGoldUpdateWithoutJobcardInput = {
    weight?: FloatFieldUpdateOperationsInput | number
    touch?: FloatFieldUpdateOperationsInput | number
    purity?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    goldsmith?: GoldsmithUpdateOneWithoutGivenGoldNestedInput
  }

  export type givenGoldUncheckedUpdateWithoutJobcardInput = {
    id?: IntFieldUpdateOperationsInput | number
    goldsmithId?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: FloatFieldUpdateOperationsInput | number
    touch?: FloatFieldUpdateOperationsInput | number
    purity?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type givenGoldUncheckedUpdateManyWithoutJobcardInput = {
    id?: IntFieldUpdateOperationsInput | number
    goldsmithId?: NullableIntFieldUpdateOperationsInput | number | null
    weight?: FloatFieldUpdateOperationsInput | number
    touch?: FloatFieldUpdateOperationsInput | number
    purity?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type itemDeliveryUpdateWithoutJobcardInput = {
    itemName?: StringFieldUpdateOperationsInput | string
    itemWeight?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    stoneWeight?: FloatFieldUpdateOperationsInput | number
    netWeight?: FloatFieldUpdateOperationsInput | number
    wastageType?: EnumWastageTypeFieldUpdateOperationsInput | $Enums.WastageType
    wastageValue?: FloatFieldUpdateOperationsInput | number
    finalPurity?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    goldsmith?: GoldsmithUpdateOneWithoutDeliveriesNestedInput
  }

  export type itemDeliveryUncheckedUpdateWithoutJobcardInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemName?: StringFieldUpdateOperationsInput | string
    itemWeight?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    stoneWeight?: FloatFieldUpdateOperationsInput | number
    netWeight?: FloatFieldUpdateOperationsInput | number
    wastageType?: EnumWastageTypeFieldUpdateOperationsInput | $Enums.WastageType
    wastageValue?: FloatFieldUpdateOperationsInput | number
    finalPurity?: FloatFieldUpdateOperationsInput | number
    goldsmithId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type itemDeliveryUncheckedUpdateManyWithoutJobcardInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemName?: StringFieldUpdateOperationsInput | string
    itemWeight?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    stoneWeight?: FloatFieldUpdateOperationsInput | number
    netWeight?: FloatFieldUpdateOperationsInput | number
    wastageType?: EnumWastageTypeFieldUpdateOperationsInput | $Enums.WastageType
    wastageValue?: FloatFieldUpdateOperationsInput | number
    finalPurity?: FloatFieldUpdateOperationsInput | number
    goldsmithId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReceivedsectionUpdateWithoutJobcardInput = {
    weight?: FloatFieldUpdateOperationsInput | number
    touch?: FloatFieldUpdateOperationsInput | number
    purity?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    goldsmith?: GoldsmithUpdateOneWithoutReceivedNestedInput
  }

  export type ReceivedsectionUncheckedUpdateWithoutJobcardInput = {
    id?: IntFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    touch?: FloatFieldUpdateOperationsInput | number
    purity?: FloatFieldUpdateOperationsInput | number
    goldsmithId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReceivedsectionUncheckedUpdateManyWithoutJobcardInput = {
    id?: IntFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    touch?: FloatFieldUpdateOperationsInput | number
    purity?: FloatFieldUpdateOperationsInput | number
    goldsmithId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}